<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo命令常用</title>
      <link href="/2023/07/04/hexo%E5%91%BD%E4%BB%A4%E5%B8%B8%E7%94%A8/"/>
      <url>/2023/07/04/hexo%E5%91%BD%E4%BB%A4%E5%B8%B8%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>hexo new “一个新的文章”    #这是创建新的文章的命令<br>hexo g    #生成静态网页<br>hexo s    #启动本地服务<br>hexo d    #部署到github或别地方</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arrays类中的sort()方法原理</title>
      <link href="/2022/10/09/Arrays%E7%B1%BB%E4%B8%AD%E7%9A%84sort-%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86/"/>
      <url>/2022/10/09/Arrays%E7%B1%BB%E4%B8%AD%E7%9A%84sort-%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><strong>java中Arrays.sort使用了两种排序方法，快速排序和优化的归并排序。</strong></p><p>快速排序主要是对哪些基本类型数据(int,short,long等)排序，</p><p>而归并排序用于对对象类型进行排序。</p><p>使用不同类型的排序算法主要是由于快速排序是不稳定的，而合并排序是稳定的</p><p>归并排序相对而言比较次数比快速排序少，移动(对象引用的移动)次数比快速排序多，而对于对象来说，比较一般比移动耗时。补充一点合并排序的时间复杂度是nlogn, 快速排序的平均时间复杂度也是nlogn，但是合并排序的需要额外的n个引用的空间。</p><p><strong>源码中的快速排序，主要做了以下几个方面的优化：</strong></p><p>**1)**当待排序的数组中的元素个数较少时，源码中的阀值为7，采用的是插入排序。尽管插入排序的时间复杂度为0(n^2)，但是当数组元素较少时，插入排序优于快速排序，因为这时快速排序的递归操作影响性能。</p><p>**2)**较好的选择了划分元(基准元素)。能够将数组分成大致两个相等的部分，避免出现最坏的情况。例如当数组有序的的情况下，选择第一个元素作为划分元，将使得算法的时间复杂度达到O(n^2).</p><p>**3)*<em>根据划分元 v ，形成不变式 v</em> (</p><p>源码中选择划分元的方法:</p><p>1)当数组大小为 size&#x3D;7 时 ，取数组中间元素作为划分元。int n&#x3D;m&gt;&gt;1;(此方法值得借鉴)。</p><p>2)当数组大小size大于7小于等于40时，取首、中、末三个元素中间大小的元素作为划分元。</p><p>3)当数组大小 size&gt;40 时 ，从待排数组中较均匀的选择9个元素，选出一个伪中数做为划分元。</p><p>普通的快速排序算法，经过一次划分后，将划分元排到素组较中间的位置，左边的元素小于划分元，右边的元素大于划分元，而没有将与划分元相等的元素放在其附近，这一点，在Arrays.sort()中得到了较大的优化。</p><p>举例：15、93、15、41、6、15、22、7、15、20</p><p>举例：15、93、15、41、6、15、22、7、15、20</p><p>因size大于7小于等于40 ,所以在15、6、和20 中选择v &#x3D; 15 作为划分元。</p><p>经过一次换分后： 15、15、7、6、41、20、22、93、15、15. 与划分元相等的元素都移到了素组的两边。</p><p>接下来将与划分元相等的元素移到数组中间来，形成：7、6、15、15、15、15、41、20、22、93.</p><p>最后递归对两个区间进行排序[7、6]和[41、20、22、93].,所以在15、6、和20 中选择v &#x3D; 15 作为划分元。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka和websocket实现主动推送给前端</title>
      <link href="/2022/09/24/kafka%E5%92%8Cwebsocket%E5%AE%9E%E7%8E%B0%E4%B8%BB%E5%8A%A8%E6%8E%A8%E9%80%81%E7%BB%99%E5%89%8D%E7%AB%AF/"/>
      <url>/2022/09/24/kafka%E5%92%8Cwebsocket%E5%AE%9E%E7%8E%B0%E4%B8%BB%E5%8A%A8%E6%8E%A8%E9%80%81%E7%BB%99%E5%89%8D%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="WebSocket和kafka实现数据实时推送到前端"><a href="#WebSocket和kafka实现数据实时推送到前端" class="headerlink" title="WebSocket和kafka实现数据实时推送到前端"></a>WebSocket和kafka实现数据实时推送到前端</h1><h2 id="一-需求背景"><a href="#一-需求背景" class="headerlink" title="一. 需求背景"></a>一. 需求背景</h2><p>需要将kafka中的数据实时推送到前端展示。最开始想到的是前端轮询接口数据，但是无法保证轮询的频率和消费的频率完全一致，或造成数据缺失等问题。最终确定用利用WebSocket实现数据的实时推送。</p><h2 id="二-websocket简介"><a href="#二-websocket简介" class="headerlink" title="二. websocket简介"></a>二. websocket简介</h2><p>WebSocket用于在Web浏览器和服务器之间进行任意的双向数据传输的一种技术。WebSocket协议基于TCP协议实现，包含初始的握手过程，以及后续的多次数据帧双向传输过程。其目的是在WebSocket应用和WebSocket服务器进行频繁双向通信时，可以使服务器避免打开多个HTTP连接进行工作来节约资源，提高了工作效率和资源利用率。</p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>伴随移动互联网的发展，大量移动终端和其上的APP应用接入网络，HTML5技术也提了出来，以便支持WEB上的音视频播放、实时游戏、实时聊天等。催生了这样一个<strong>需求</strong>，当服务器有更新时，需要立即将数据发送给客户端，这就是基于服务器端的<strong>推送</strong>技术。</p><h3 id="WEBSOCKET之前的解决方法大概这么几种："><a href="#WEBSOCKET之前的解决方法大概这么几种：" class="headerlink" title="WEBSOCKET之前的解决方法大概这么几种："></a>WEBSOCKET之前的解决方法大概这么几种：</h3><h5 id="1-轮询："><a href="#1-轮询：" class="headerlink" title="1.轮询："></a>1.轮询：</h5><p>客户端设置一个时间间隔，时间到以后，向服务器发送request询问有无新数据，服务器立即返回response，如果有更新则携带更新的数据。</p><h5 id="2-长连接-long-poll"><a href="#2-长连接-long-poll" class="headerlink" title="2.长连接(long poll):"></a>2.长连接(long poll):</h5><p>和轮询相似，但是为阻塞模式的轮询，客户端请求新的数据request, 服务器会阻塞请求，直到有新数据后才返回response给客户端；然后客户端再重复此过程。这两种方式的特点，不断的建立HTTP连接，然后发送请求request，之后服务器等待处理。服务端体现的是一种被动性，同时这种处理方式，非常耗费网络带宽和服务器资源。</p><p> 服务器向客户端推送更新时，因为被动性，对低延迟的应用体验不好；因为request&#x2F;response的交互方式，对网络带宽和服务器带来了额外的负担（例如多次请求的HTTP头部， TCP连接复用会导致的Head-of-Line Blocking线头阻塞[2]等）。如果在单一的TCP连接中，使用双向通信（全双工通信）就能很好的解决此问题。这就是WebSocket技术的缘由。</p><h3 id="WebSocket技术及协议"><a href="#WebSocket技术及协议" class="headerlink" title="WebSocket技术及协议"></a>WebSocket技术及协议</h3><h5 id="WebSocket技术的优点有："><a href="#WebSocket技术的优点有：" class="headerlink" title="WebSocket技术的优点有："></a>WebSocket技术的优点有：</h5><p>1.通过第一次HTTP Request建立了连接之后，后续的数据交换都不用再重新发送HTTP Request，节省了带宽资源；<br>2.WebSocket的连接是双向通信的连接，在同一个TCP连接上，既可以发送，也可以接收;<br>3.具有多路复用的功能(multiplexing)，也即几个不同的URI可以复用同一个WebSocket连接。这些特点非常类似TCP连接，但是因为它借用了HTTP协议的一些概念，所以被称为了WebSocket。</p><p>接口的内容可以分为三类：状态变量、网络功能和消息处理等。</p><p>1.构造函数WebSocket(url, protocols)：构造WebSocket对象，以及建立和服务器连接; protocols可选字段，代表选择的子协议<br>2.状态变量readyState: 代表当前连接的状态，短整型数据，取值为CONNECTING(值为0)， OPEN(值为1), CLOSING(值为2), CLOSED(值为3)<br>3.方法变量close(code, reason)： 关闭此WebSocket连接。<br>4.状态变量bufferedAmount: send函数调用后，被缓存并且未发送到网络上的数据长度<br>5.方法变量send(data): 将数据data通过此WebSocket发送到对端<br>6.回调函数onopen&#x2F;onmessage&#x2F;onerror&#x2F;onclose: 当相应的事件发生时会触发此回调函数</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>客户端使用例子(JavaScript)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var websocket = new WebSocket(&quot;ws://www.host.com/path&quot;); </span><br><span class="line">websocket.onopen = function(evt) &#123; onOpen(evt) &#125;; </span><br><span class="line">websocket.onclose = function(evt) &#123; onClose(evt) &#125;; </span><br><span class="line">websocket.onmessage = function(evt) &#123; onMessage(evt) &#125;; </span><br><span class="line">websocket.onerror = function(evt) &#123; onError(evt) &#125;; &#125;  </span><br><span class="line">function onMessage(evt) &#123; alert( evt.data); &#125;</span><br><span class="line">function onError(evt) &#123; alert( evt.data); &#125;  </span><br><span class="line">websocket.send(&quot;client to server&quot;);</span><br></pre></td></tr></table></figure><h1 id><a href="#" class="headerlink" title></a></h1><h5 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h5><p>WebSocket看成是一种类似TCP&#x2F;IP的socket技术；此socket在Web应用中实现，并获得了和TCP&#x2F;IP通信一样灵活方便的全双向通信功能。</p><p>2.2 WebSocket协议<br>WebSocket看成是一种类似TCP&#x2F;IP的socket技术；此socket在Web应用中实现，并获得了和TCP&#x2F;IP通信一样灵活方便的全双向通信功能。</p><p>WebSocket协议由RFC 6455定义。协议分为两个部分： 握手阶段和数据通信阶段。</p><p>WebSocket为应用层协议，其定义在TCP&#x2F;IP协议栈之上。WebSocket连接服务器的URI以”ws”或者”wss”开头。ws开头的默认TCP端口为80，wss开头的默认端口为443。</p><h5 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h5><p>客户端和服务器建立TCP连接之后，客户端发送握手请求，随后服务器发送握手响应即完成握手阶段。</p><p>需要关闭连接时，任意一方直接发送类型为关闭帧(Close frame)的控制帧数据给对方即可。</p><h5 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h5><p>WebSocket的数据在发送时，被组织为依次序的一串数据帧(data frame)，然后进行传送。</p><p>传送的帧类型分为两类：数据帧(data frame)和控制帧(Control frame)。数据帧可以携带文本数据或者二进制数据；控制帧包含关闭帧(Close frame)和Ping&#x2F;Pong帧。</p><p>其中最重要的字段为opcode(4bit)和MASK(1bit)：</p><p>MASK值，从客户端进行发送的帧必须置此位为1，从服务器发送的帧必须置为0。如果任何一方收到的帧不符合此要求，则发送关闭帧(Close frame)关闭连接。<br>opcode的值： 0x1代表此帧为文本数据帧, 0x2代表此帧为二进制数据帧, 0x8为控制帧中的连接关闭帧(close frame), 0x9为控制帧中的Ping帧, 0xA(十进制的10)为控制帧中的Pong帧。<br>Ping&#x2F;Pong帧： Ping帧和Pong帧用于连接的保活(keepalive)或者诊断对端是否在线。这两种帧的发送和接收不对WEB应用公开接口，由实现WebSocket协议的底层应用(例如浏览器)来实现它。</p><h5 id="连接关闭"><a href="#连接关闭" class="headerlink" title="连接关闭"></a>连接关闭</h5><p>任何一端发送关闭帧给对方，即可关闭连接。关闭连接时通常都带有关闭连接的状态码(status code)。常见状态码的含义如下：</p><p>1000 连接正常关闭<br>1001 端点离线，例如服务器down，或者浏览器已经离开此页面<br>1002 端点因为协议错误而中断连接<br>1003 端点因为受到不能接受的数据类型而中断连接<br>1004 保留<br>1005 保留, 用于提示应用未收到连接关闭的状态码<br>1006 端点异常关闭<br>1007 端点收到的数据帧类型不一致而导致连接关闭<br>1008 数据违例而关闭连接<br>1009 收到的消息数据太大而关闭连接<br>1010 客户端因为服务器未协商扩展而关闭<br>1011 服务器因为遭遇异常而关闭连接<br>1015 TLS握手失败关闭连接</p><h2 id="三-服务端实现"><a href="#三-服务端实现" class="headerlink" title="三. 服务端实现"></a>三. 服务端实现</h2><h5 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h5><p>这里需要引用三个依赖。第一个为WebSocket需要的依赖，另外两个为kafka的依赖</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;groupId&gt;person&lt;/groupId&gt;&lt;artifactId&gt;wbSocketkafka&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;dependencies&gt;    &lt;!-- webSocket所需依赖 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax&lt;/groupId&gt;        &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;        &lt;version&gt;7.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- kafka 所需依赖 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;        &lt;artifactId&gt;kafka_2.9.2&lt;/artifactId&gt;        &lt;version&gt;0.8.1.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;        &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;        &lt;version&gt;RELEASE&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;&lt;/project&gt;</code></pre><h5 id="webSocket服务端实现"><a href="#webSocket服务端实现" class="headerlink" title="webSocket服务端实现"></a>webSocket服务端实现</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//此处定义接口的uri</span><br><span class="line">@ServerEndpoint(&quot;/wbSocket&quot;)</span><br><span class="line">public class WebSocket &#123;</span><br><span class="line"> private Session session;</span><br><span class="line"> public static CopyOnWriteArraySet&lt;WebSocket&gt; wbSockets = new CopyOnWriteArraySet&lt;WebSocket&gt;(); //此处定义静态变量，以在其他方法中获取到所有连接</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line"></span><br><span class="line">- 建立连接。</span><br><span class="line">- 建立连接时入参为session</span><br><span class="line">  */</span><br><span class="line">   @OnOpen</span><br><span class="line">   public void onOpen(Session session)&#123;</span><br><span class="line">  this.session = session;</span><br><span class="line">  wbSockets.add(this); //将此对象存入集合中以在之后广播用，如果要实现一对一订阅，则类型对应为Map。由于这里广播就可以了随意用Set</span><br><span class="line">  System.out.println(&quot;New session insert,sessionId is &quot;+ session.getId());</span><br><span class="line">   &#125;</span><br><span class="line">   /**</span><br><span class="line">- 关闭连接</span><br><span class="line">  */</span><br><span class="line">   @OnClose</span><br><span class="line">   public void onClose()&#123;</span><br><span class="line">  wbSockets.remove(this);//将socket对象从集合中移除，以便广播时不发送次连接。如果不移除会报错(需要测试)</span><br><span class="line">  System.out.println(&quot;A session insert,sessionId is &quot;+ session.getId());</span><br><span class="line">   &#125;</span><br><span class="line">   /**</span><br><span class="line">- 接收前端传过来的数据。</span><br><span class="line">- 虽然在实现推送逻辑中并不需要接收前端数据，但是作为一个webSocket的教程或叫备忘，还是将接收数据的逻辑加上了。</span><br><span class="line">  */</span><br><span class="line">   @OnMessage</span><br><span class="line">   public void onMessage(String message ,Session session)&#123;</span><br><span class="line">  System.out.println(message + &quot;from &quot; + session.getId());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> public void sendMessage(String message) throws IOException &#123;</span><br><span class="line">     this.session.getBasicRemote().sendText(message);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="kafka消费者实现"><a href="#kafka消费者实现" class="headerlink" title="kafka消费者实现"></a>kafka消费者实现</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class ConsumerKafka extends Thread &#123;</span><br><span class="line"></span><br><span class="line"> private KafkaConsumer&lt;String,String&gt; consumer;</span><br><span class="line"> private String topic = &quot;kafkaTopic&quot;;</span><br><span class="line"></span><br><span class="line"> public ConsumerKafka()&#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public void run()&#123;</span><br><span class="line">     //加载kafka消费者参数</span><br><span class="line">     Properties props = new Properties();</span><br><span class="line">     props.put(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;);</span><br><span class="line">     props.put(&quot;group.id&quot;, &quot;ytna&quot;);</span><br><span class="line">     props.put(&quot;enable.auto.commit&quot;, &quot;true&quot;);</span><br><span class="line">     props.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;);</span><br><span class="line">     props.put(&quot;session.timeout.ms&quot;, &quot;15000&quot;);</span><br><span class="line">     props.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line">     props.put(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line">     //创建消费者对象</span><br><span class="line">     consumer = new KafkaConsumer&lt;String,String&gt;(props);</span><br><span class="line">     consumer.subscribe(Arrays.asList(this.topic));</span><br><span class="line">     //死循环，持续消费kafka</span><br><span class="line">     while (true)&#123;</span><br><span class="line">         try &#123;</span><br><span class="line">            //消费数据，并设置超时时间</span><br><span class="line">             ConsumerRecords&lt;String, String&gt; records = consumer.poll(100);</span><br><span class="line">             //Consumer message</span><br><span class="line">             for (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                 //Send message to every client</span><br><span class="line">                 for (WebSocket webSocket :wbSockets)&#123;</span><br><span class="line">                     webSocket.sendMessage(record.value());</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;catch (IOException e)&#123;</span><br><span class="line">             System.out.println(e.getMessage());</span><br><span class="line">             continue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public void close() &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         consumer.close();</span><br><span class="line">     &#125; catch (Exception e) &#123;</span><br><span class="line">         System.out.println(e.getMessage());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //供测试用，若通过tomcat启动需通过其他方法启动线程</span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line">     ConsumerKafka consumerKafka = new ConsumerKafka();</span><br><span class="line">     consumerKafka.start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P.S. 需要注意的是WebSocket对tomcat版本是有要求的，笔者使用的是7.0.7.8。</p><h2 id="四-前端简单实现"><a href="#四-前端简单实现" class="headerlink" title="四. 前端简单实现"></a>四. 前端简单实现</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;WebSocket client&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        var socket;        if (typeof (WebSocket) == &quot;undefined&quot;)&#123;            alert(&quot;This explorer don&#39;t support WebSocket&quot;)        &#125;   function connect() &#123;        //Connect WebSocket server        socket =new WebSocket(&quot;ws://127.0.0.1:8080/wbSocket&quot;);        //open        socket.onopen = function () &#123;            alert(&quot;WebSocket is open&quot;);        &#125;        //Get message        socket.onmessage = function (msg) &#123;            alert(&quot;Message is &quot; + msg);        &#125;        //close        socket.onclose = function () &#123;            alert(&quot;WebSocket is closed&quot;);        &#125;        //error        socket.onerror = function (e) &#123;            alert(&quot;Error is &quot; + e);        &#125;    &#125;    function close() &#123;        socket.close();    &#125;    function sendMsg() &#123;        socket.send(&quot;This is a client message &quot;);    &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;button onclick=&quot;connect()&quot;&gt;connect&lt;/button&gt;    &lt;button onclick=&quot;close()&quot;&gt;close&lt;/button&gt;    &lt;button onclick=&quot;sendMsg()&quot;&gt;sendMsg&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis如何保证数据一致性</title>
      <link href="/2022/09/17/Redis%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/2022/09/17/Redis%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>在项目中难免会使用到redis作为缓存，去减轻数据库的访问压力，但是涉及到数据更新时，如果redis和数据库的操作设计出现问题，就会导致redis缓存中和数据库中的数据不一致的情况。那么我们如何去保证缓存与数据库中数据一直呢？</p><p>四种同步策略<br>想要保证缓存与数据库的双写一致，一共有四种方式，即四种同步策略<br>1、先更新缓存，再更新数据库<br>2、先更新数据库，再更新缓存<br>3、先删除缓存，在更新数据库<br>4、先更新数据库，再删除缓存</p><h1 id="更新缓存和删除缓存的选择"><a href="#更新缓存和删除缓存的选择" class="headerlink" title="更新缓存和删除缓存的选择"></a>更新缓存和删除缓存的选择</h1><p><strong>更新缓存</strong></p><p>优点：<br>如果每次数据变化都能被及时更新，那么查询数据时不容易出现不命中的情况，<br>缺点：<br>1、如果数据的计算复杂，频繁的更新会造成服务器性能的消耗比较大<br>2、如果数据并不是被频繁使用，那么频繁更新也只是浪费服务器性能，对业务没有多大的帮助<br>适用于数据使用较为频繁，且数据的计算不那么复杂的场景</p><p><strong>删除缓存</strong></p><p>优点：不需要顾忌数据的复杂性，直接删除即可<br>缺点：查询数据时，增大未命中的几率，从而增大数据库的访问压力<br>适用于数据使用频率不高的场景</p><p>在上面四种同步策略中，都存在导致数据不一致的风险</p><h1 id="1、先删除缓存，再更新数据库"><a href="#1、先删除缓存，再更新数据库" class="headerlink" title="1、先删除缓存，再更新数据库"></a>1、先删除缓存，再更新数据库</h1><p><img src="/2022/09/17/Redis%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/MyBlogs\source_posts\Redis如何保证数据一致性\1663382666822.png" alt="1663382666822"></p><p>操作步骤：<br>a、线程A删除缓存中的数据，<br>b、线程A更新数据库中的数据，但是更新失败<br>c、此时线程B去获取缓存中的数据，但是未命中<br>d、线程B，去数据库中获取数据，但此时的数据因为更新失败为旧数据<br>e、线程B将数据库中查到的数据同步到缓存中去<br>f、线程A此时更新数据到数据库成功<br>最后数据库和redis缓存中的数据不一致</p><p><strong>如果在更新数据库时没有出现失败，也同样存在会造成数据不一致的情况</strong></p><p><img src="/2022/09/17/Redis%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/MyBlogs\source_posts\Redis如何保证数据一致性\1663383214079.png" alt="1663383214079"></p><p>操作步骤：<br>a、线程A删除缓存中的数据，<br>b、此时线程B去获取缓存中的数据，但是未命中<br>c、线程B，去数据库中获取数据，但此时的数据因为更新失败为旧数据<br>d、线程B将数据库中查到的数据同步到缓存中去<br>e、线程A此时更新数据到数据库成功<br>最后数据库和redis缓存中的数据不一致,这里造成的数据不一致的原因是线程B在数据库还未更新时就已经获取到了旧的数据。</p><h1 id="2、先更新数据库，再删除缓存"><a href="#2、先更新数据库，再删除缓存" class="headerlink" title="2、先更新数据库，再删除缓存"></a>2、先更新数据库，再删除缓存</h1><p><img src="/2022/09/17/Redis%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/MyBlogs\source_posts\Redis如何保证数据一致性\1663383237401.png" alt="1663383237401"></p><p>操作步骤：<br>1、线程A更新数据库中的数据<br>2、线程A删除缓存中的数据，删除失败<br>3、线程B查询缓存中的数据，查询到旧数据<br>4、线程A异步重试删除缓存<br>这里，删除缓存中数据失败后就会造成线程B获取到缓存中的旧数据，从而导致数据不一致的情况</p><p>如果缓存没有删除失败的情况也可能导致数据不一致</p><p><img src="/2022/09/17/Redis%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/MyBlogs\source_posts\Redis如何保证数据一致性\1663383253681.png" alt="1663383253681"></p><p>操作步骤：<br>1、线程A更新数据库中的数据<br>2、线程B查询缓存中的数据，查询到旧数据<br>3、线程A删除缓存<br>如果线程B在缓存删除前获取到了缓存中的数据，那么线程B获取到的还是旧数据，也会导致数据不一致的情况</p><h1 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h1><p>上面中先删除缓存，在更新数据库在不出现失败时也会出现数据不一致的情况，那么我们要有什么解决方案呢。我们就采用延时双删的策略来保证缓存中的数据时更新后的数据<br>操作步骤<br>1、先删除缓存<br>2、更新数据库<br>3、线程等待 N秒（等待时间根据具体业务来判断）<br>4、再删除缓存<br>这样就保证了缓存中的数据最终会和数据库中的数据保持一致</p><h1 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h1><p>先删除缓存，在更新数据库，如果数据库采用读写分离架构会有什么影响呢？</p><p><img src="/2022/09/17/Redis%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/MyBlogs\source_posts\Redis如何保证数据一致性\1663383309293.png" alt="1663383309293"></p><p>操作步骤：<br>1、线程A删除缓存<br>2、线程A更新从数据库<br>3、线程B查询缓存，未命中<br>4、线程B去从数据库查询数据，还未同步，所以从数据库为旧数据<br>5、线程B将数据更新到缓存中<br>6、主数据库同步数据到从数据中<br>这样还是会出现数据不一致的情况，那么我们要怎么解决呢？<br>如果只是为了更新redis的数据的数据库查询，让线程同步数据时强行指定到主数据库执行</p><p><strong>如何保证缓存与数据库的双写一致性？</strong></p><p>最经典的缓存+数据库读写的模式。</p><p>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。<br>更新的时候，先删除缓存，再更新数据库。<br>为什么是删除缓存而不是更新缓存？</p><p>举个例子，比如说我一条数据，1分钟内修改了10次，那么缓存更新 10 次；但是这个缓存在 1 分钟内可能只被读取了 1 次，那每次更新的意义就不大，还会增加开销。如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用到缓存才去算缓存。</p><p>为什么先删除缓存再更新数据库，而不是先更新数据库再删除缓存？</p><p>先更新数据库，成功了再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。</p><p>先删除缓存，成功了再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中还是旧数据，数据还是一致的，所以没问题</p><p><strong>比较复杂的数据不一致问题分析</strong><br>比如：数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一样了</p><p>解决方案：加锁，比如redisson分布式锁，缺点：串行变成并行，效率更低了</p><p> 优化方案：</p><p><strong>一： 对于读多写少的场景：</strong></p><p>​    了解下分布式读写锁，读锁和读锁之间可以并行，不互斥，所以不影响读的效率； 对同一个产品加写锁时，读锁就要等待， 以下，读锁，多个线程进来时，相当于没有加锁，不影响。只有写锁生效时，读锁才会 等待</p><p>  <strong>二： 对于读多写多的场景</strong></p><p>​      对于这种情况，大多数互联网公司没那么多要求保证实时的。比如商品详情页面上的库存，有时候并不是真正的库存。要到下单的时候才会去数据库取库存。所以。这种情况。我们只需要库存设置为缓存的时候，设置个超时时间为1分钟就行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka如何保证数据不丢失</title>
      <link href="/2022/09/17/kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1/"/>
      <url>/2022/09/17/kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1/</url>
      
        <content type="html"><![CDATA[<p>消息队列发送消息和消费消息的过程，共分为三段，生产过程、服务端持久化过程、消费过程，如下图所示。</p><p><img src="/2022/09/17/kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1/MyBlogs\source_posts\kafka如何保证数据不丢失\1663380334192.png" alt="1663380334192"></p><p>这三个过程都有可能弄丢消息。</p><p><strong>面试官：</strong> 嗯，消息丢失的具体原因是什么？怎么防止丢失消息呢？</p><p><strong>我：</strong> 我详细说一下这种情况：</p><h1 id="一、生产过程丢失消息"><a href="#一、生产过程丢失消息" class="headerlink" title="一、生产过程丢失消息"></a>一、生产过程丢失消息</h1><p>丢失原因：一般可能是网络故障，导致消息没有发送出去。</p><p>解决方案：重发就行了。</p><p>由于<a href="https://so.csdn.net/so/search?q=kafka&spm=1001.2101.3001.7020">kafka</a>为了提高性能，采用了异步发送消息。我们只有获取到发送结果，才能确保消息发送成功。 有两个方案可以获取发送结果。</p><p>一种是kafka把发送结果封装在Future对象中，我可以使用Future的get方法同步阻塞获取结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;RecordMetadata&gt; future = producer.send(new ProducerRecord&lt;&gt;(topic, message));</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">    RecordMetadata recordMetadata = future.get();</span><br><span class="line"></span><br><span class="line">    if (recordMetadata != null) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;发送成功&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种是使用kafka的callback函数获取返回结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">producer.send(new ProducerRecord&lt;&gt;(topic, message), new Callback() &#123;</span><br><span class="line">              </span><br><span class="line">    @Override</span><br><span class="line">    public void onCompletion(RecordMetadata metadata, Exception exception) &#123;</span><br><span class="line"></span><br><span class="line">        if (exception == null) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;发送成功&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;发送失败&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果发送失败了，有两种重试方案：</p><ol><li><p>手动重试 在catch逻辑或else逻辑中，再调用一次send方法。如果还不成功怎么办？ 在数据库中建一张异常消息表，把失败消息存入表中，然后搞个异步任务重试，便于控制重试次数和间隔时间。</p></li><li><p>自动重试 kafka支持自动重试，设置参数如下，当集群Leader选举中或者Follower数量不足等原因返回失败时，就可以自动重试。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置重试次数为3</span></span><br><span class="line"></span><br><span class="line">retries = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置重试间隔为100ms</span></span><br><span class="line"></span><br><span class="line">retry.backoff.ms = <span class="number">100</span></span><br></pre></td></tr></table></figure><p>一般我们不会用kafka自动重试，因为超过重试次数，还是会返回失败，还需要我们手动重试。</p></li></ol><h1 id="二、服务端持久化过程丢失消息"><a href="#二、服务端持久化过程丢失消息" class="headerlink" title="二、服务端持久化过程丢失消息"></a>二、服务端持久化过程丢失消息</h1><p>为了保证性能，kafka采用的是异步刷盘，当我们发送消息成功后，Broker节点在刷盘之前宕机了，就会导致消息丢失。</p><p>当然我们也可以设置刷盘频率：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置每1000条消息刷一次盘</span></span><br><span class="line"></span><br><span class="line">flush.messages = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置每秒刷一次盘</span></span><br><span class="line"></span><br><span class="line">flush.ms = <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>先普及一下kafka集群的架构模型：</p><p>kafka集群由多个broker组成，一个broker就是一个节点（机器）。 一个topic有多个partition（分区），每个partition分布在不同的broker上面，可以充分利用分布式机器性能，扩容时只需要加机器、加partition就行了。</p><p><img src="/2022/09/17/kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1/MyBlogs\source_posts\kafka如何保证数据不丢失\1663380579295.png" alt="1663380579295"></p><p>一个partition又有多个replica（副本），有一个leader replica（主副本）和多个follower replica（从副本），这样设计是为了保证数据的安全性。</p><p>​    </p><p>​    发送消息和消费消息都在leader上面，follower负责定时从leader上面拉取消息，只有follower从leader上面把这条消息拉取回来，才算生产者发送消息成功。</p><p>​    kafka为了加快持久化消息的性能，把性能较好的follower组成一个ISR列表（in-sync replica），把性能较差的follower组成一个OSR列表（out-of-sync replica），ISR+OSR&#x3D;AR（assigned repllicas）。</p><p> 如果某个follower一段时间没有向leader拉取消息，落后leader太多，就把它移出ISR，放到OSR之中。 如果某个follower追上了leader，又会把它重新放到ISR之中。 如果leader挂掉，就会从ISR之中选一个follower做leader。</p><p><img src="/2022/09/17/kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1/MyBlogs\source_posts\kafka如何保证数据不丢失\1663380640810.png" alt="1663380640810"></p><p>为了提升持久化消息性能，我们可以进行一些设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果follower超过一秒没有向leader拉取消息，就把它移出ISR列表</span></span><br><span class="line"></span><br><span class="line">rerplica.lag.time.<span class="built_in">max</span>.ms = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果follower落后leader一千条消息，就把它移出ISR列表</span></span><br><span class="line"></span><br><span class="line">rerplica.lag.<span class="built_in">max</span>.messages = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 至少保证ISR中有3个follower</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">min</span>.insync.replicas = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步消息，不需要leader确认，立即给生产者返回发送成功，丢失消息概率较大</span></span><br><span class="line"></span><br><span class="line">asks = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leader把消息写入本地日志中，不会等所有follower确认，就给生产者返回发送成功，小概率丢失消息</span></span><br><span class="line"></span><br><span class="line">asks = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leader需要所有ISR中follower确认，才给生产者返回发送成功，不会丢失消息</span></span><br><span class="line"></span><br><span class="line">asks = -<span class="number">1</span> 或者 asks = <span class="built_in">all</span></span><br></pre></td></tr></table></figure><h1 id="三、消费过程丢失消息"><a href="#三、消费过程丢失消息" class="headerlink" title="三、消费过程丢失消息"></a>三、消费过程丢失消息</h1><p>kafka中有个offset的概念，consumer从partition中拉取消息，consumer本地处理完成后需要commit一下offset，表示消费完成，下次就不会再拉取到这条消息。<br>所以我们需要关闭自动commit offset的配置，防止consumer拉到消息后，服务宕机，导致消息丢失。</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enable.<span class="keyword">auto</span>.commit = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>面试官：</strong> 还得是你，就你总结的全，我都想不那么全，明天来上班吧，薪资double。</p><h1 id="本文知识点总结："><a href="#本文知识点总结：" class="headerlink" title="本文知识点总结："></a>本文知识点总结：</h1><p><img src="/2022/09/17/kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1/Users\00\AppData\Roaming\Typora\typora-user-images\1663380776262.png" alt="1663380776262"></p><p>消息重复解决方案<br>消息可以使用唯一id标识<br>生产者（ack&#x3D;all 代表至少成功发送一次)<br>消费者 （offset手动提交，业务逻辑成功处理后，提交offset）<br>落表（主键或者唯一索引的方式，避免重复数据）<br>业务逻辑处理（选择唯一主键存储到Redis或者mongdb中，先查询是否存在，若存在则不处理；若不存在，先插入Redis或Mongdb,再进行业务逻辑处理）</p>]]></content>
      
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC拦截器</title>
      <link href="/2022/08/24/SpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
      <url>/2022/08/24/SpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>SpringMVC之拦截器</p><p>目录</p><p>一、什么是拦截器？</p><p>二、拦截器与过滤器</p><p>三、应用场景</p><p>四、拦截器入门案例</p><p>五、拦截器方法说明</p><p>六、用户登录权限控制</p><p>一、什么是拦截器？<br>SpringMVC的处理器拦截器,类似于Servlet开发中的过滤器Filter，用于对处理器进行预处理和后处理。 依赖于web框架，在实现上基于Java的反射机制，属于面向切面编程（AOP）的一种运用。由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个 controller生命周期之内可以多次调用。</p><p>二、拦截器与过滤器<br>2.1 什么是过滤器（Filter）</p><p>依赖于servlet容器。在实现上基于函数回调，可以对几乎所有请求进行过滤，但是缺点是一个过滤器实例，只能在容器初始化时调用一次。使用过滤器的目的是用来做一些过滤操作，比如：在过滤器中修改字符编码； 在过滤器中修改HttpServletRequest的一些参数，包括：过滤低俗文字、危险字符等。</p><p>2.2什么是拦截器(interceptor)？</p><p> 拦截器，在AOP（Aspect-Oriented Programming）中用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。拦截是AOP的一种实现策略。</p><pre><code>在 Webwork的中文文档的解释为——拦截器是动态拦截Action调用的对象。它提供了一种机制可以使开发者可以定义在一个action执行的前后执行的代码，也可以在一个action执行前阻止其执行。同时也是提供了一种可以提取action中可重用的部分的方式。</code></pre><p>2.3拦截器链（多拦截器）</p><pre><code>  拦截器链的概念：如果多个拦截器能够对相同的请求进行拦截，则多个拦截器会形成一个拦截器链，主要理解拦截器链中各个拦截器的执行顺序。拦截器链中多个拦截器的执行顺序，根拦截器的配置顺序有关，先配置的先执行。</code></pre><p>2.3过滤器和拦截器的区别？</p><p>过滤器(filter)：</p><pre><code>1) filter属于Servlet技术，只要是web工程都可以使用2) filter主要对所有请求过滤3) filter的执行时机早于Interceptor</code></pre><p> 拦截器(interceptor)</p><pre><code>1) interceptor属于SpringMVC技术，必须要有SpringMVC环境才可以使用2) interceptor通常对处理器Controller进行拦截3) interceptor只能拦截dispatcherServlet处理的请求</code></pre><p>三、应用场景<br>1）日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算PV（Page View）等。</p><p> 2）权限检查：如登录检测，进入处理器检测是否登录，如果没有直接返回到登录页面；</p><p> 3）性能监控：有时候系统在某段时间莫名其妙的慢，可以通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间（如果有反向代理，如apache可以自动记录）；</p><p> 4）通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个Controller中的处理方法都需要的，我们就可以使用拦截器实现。</p><p>四、拦截器入门案例<br>步骤：</p><p>1、配置拦截器(在springmvc.xml中进行配置)</p><p>2、创建拦截器类实现HandlerInterceptor接口(实现HandlerInterceptor接口，内部有相应的方法需要我们去实现)<br>3、测试拦截器的拦截效果</p><p>4.1单个拦截器</p><p>1)在SpringMVC核心配置文件中配置拦截器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置拦截器--&gt;</span><br><span class="line">    &lt;mvc:interceptors&gt;</span><br><span class="line">        &lt;!--配置拦截器，多个拦截器时，顺序执行--&gt;</span><br><span class="line">        &lt;mvc:interceptor&gt;</span><br><span class="line">            &lt;!--要拦截的具体的方法--&gt;</span><br><span class="line">            &lt;mvc:mapping path=&quot;/*/text&quot;/&gt;</span><br><span class="line">            &lt;!--不去拦截的方法</span><br><span class="line">            &lt;mvc:exclude-mapping path=&quot;&quot;/&gt;</span><br><span class="line">            --&gt;</span><br><span class="line">            &lt;!--配置拦截器对象--&gt;</span><br><span class="line">            &lt;bean class=&quot;com.ftp.interceptor.IndexInterceptor1&quot;/&gt;</span><br><span class="line">        &lt;/mvc:interceptor&gt;</span><br><span class="line">    &lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure><p>2.1）创建IndexController类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class IndexController &#123;</span><br><span class="line">    @RequestMapping(&quot;/&quot;)</span><br><span class="line">    public String toIndex()&#123;</span><br><span class="line">        //视图解析器=前缀+逻辑视图名+后缀=完整路径</span><br><span class="line">        //前缀：/WEB-INF/jsp/</span><br><span class="line">        //逻辑视图名：index</span><br><span class="line">        //后缀 .jsp</span><br><span class="line">        //完整路径=/WEB-INF/jsp/index.jsp</span><br><span class="line">        return &quot;index&quot;;//逻辑视图名</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2)写一个前端页面，展示效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;h1&gt;Hello springmvc之拦截器入门案例&lt;/h1&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>2.3)创建拦截器类HelloInterceptor 实现HandlerInterceptor接口</p><pre><code>public class HelloInterceptor implements HandlerInterceptor &#123;@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;    System.out.println(&quot;【HelloInterceptor】preHandler...&quot;);    return true;&#125; @Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;    System.out.println(&quot;【HelloInterceptor】postHandle....&quot;);&#125; @Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;    System.out.println(&quot;【HelloInterceptor】afterCompletion..&quot;);&#125;</code></pre><p>}</p><p>3)运行IndexController测试结果如下</p><p> 4.2拦截链示例</p><p>1）在SpringMVC核心配置文件中配置多个拦截器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置拦截器--&gt;</span><br><span class="line">   &lt;mvc:interceptors&gt;</span><br><span class="line">       &lt;!--配置拦截器，多个拦截器时，顺序执行--&gt;</span><br><span class="line">       &lt;mvc:interceptor&gt;</span><br><span class="line">           &lt;!--要拦截的具体的方法--&gt;</span><br><span class="line">           &lt;mvc:mapping path=&quot;/*/text&quot;/&gt;</span><br><span class="line">           &lt;!--不去拦截的方法</span><br><span class="line">           &lt;mvc:exclude-mapping path=&quot;&quot;/&gt;</span><br><span class="line">           --&gt;</span><br><span class="line">           &lt;!--配置拦截器对象--&gt;</span><br><span class="line">           &lt;bean class=&quot;com.ftp.interceptor.IndexInterceptor1&quot;/&gt;</span><br><span class="line">       &lt;/mvc:interceptor&gt;</span><br><span class="line">       &lt;mvc:interceptor&gt;</span><br><span class="line">           &lt;!--要拦截的具体的方法--&gt;</span><br><span class="line">           &lt;mvc:mapping path=&quot;/*/text&quot;/&gt;</span><br><span class="line">           &lt;!--不去拦截的方法</span><br><span class="line">           &lt;mvc:exclude-mapping path=&quot;&quot;/&gt;</span><br><span class="line">           --&gt;</span><br><span class="line">           &lt;!--配置拦截器对象--&gt;</span><br><span class="line">           &lt;bean class=&quot;com.ftp.interceptor.IndexInterceptor2&quot;/&gt;</span><br><span class="line">       &lt;/mvc:interceptor&gt;</span><br><span class="line">   &lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure><p>4.2）创建一个拦截器类实现HandlerInterceptor接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class BookInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;【BookInterceptor】preHandler。。。&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><pre><code>@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;    System.out.println(&quot;【BookInterceptor】postHandle。。。&quot;);&#125; @Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;    System.out.println(&quot;【BookInterceptor】afterCompletion。。。&quot;);&#125;</code></pre><p>}</p><p>3）运行测试结果</p><p>五、拦截器方法说明<br> preHandle方法<br>    作用：用于对拦截到的请求进行预处理，方法接收布尔(true,false)类型的返回值，返回true：放行，false：不放行。<br>    执行时机：在处理器方法执行前执行<br>    方法参数：<br>    1）request请求对象<br>    2）response响应对象<br>    3）handler拦截到的方法处理</p><pre><code>postHandle方法作用：用于对拦截到的请求进行后处理，可以在方法中对模型数据和视图进行修改执行时机：在处理器的方法执行后，视图渲染之前方法参数：1）request请求对象2）response响应对象3）handler拦截到的处理器方法4）ModelAndView处理器方法返回的模型和视图对象，可以在方法中修改模型和视图afterCompletion方法作用：用于在整个流程完成之后进行最后的处理，如果请求流程中有异常，可以在方法中获取对象执行时机：视图渲染完成后(整个流程结束之后)方法参数：1）request请求参数2）response响应对象3）handler拦截到的处理器方法4）ex异常对象</code></pre><p>六、用户登录权限控制<br>1、配置spring-mvc.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:interceptor&gt;</span><br><span class="line">            &lt;mvc:mapping path=&quot;/**/&quot;/&gt;</span><br><span class="line">            &lt;bean class=&quot;com.zking.ssm.book.interceptor.LoginInterceptor&quot;/&gt;</span><br><span class="line">        &lt;/mvc:interceptor&gt;</span><br></pre></td></tr></table></figure><p>2、创建LoginController</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.zking.ssm.book.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.ui.Model;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class LoginController &#123;</span><br></pre></td></tr></table></figure><pre><code>/** * 跳转到登录页面 * @return */@RequestMapping(&quot;tologin&quot;)public String toLogin()&#123;    return &quot;login&quot;;&#125; /** * 登录方法 * @param username 账号 * @param password 密码 * @return */@RequestMapping(&quot;/userLogin&quot;)public String userLogin(String username, String password, HttpSession session, Model model)&#123;    if(&quot;admin&quot;.equals(username)|| password.equals(&quot;123&quot;))&#123;       session.setAttribute(&quot;username&quot;,username);        //这里的&quot;/&quot;是跳转的@RequestMapping配置的值        return &quot;redirect:/&quot;;    &#125;     model.addAttribute(&quot;msg&quot;,&quot;账号或者密码错误&quot;);    return &quot;login&quot;;&#125;/** * 安全退出 * @param session * @return */@RequestMapping(&quot;/userLogout&quot;)public String userLogout(HttpSession session)&#123;    //清空session    session.invalidate();     return &quot;redirect:tologin&quot;;&#125;&#125;</code></pre><p>LoginInterceptor</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class LoginInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        //获取请求路径</span><br><span class="line">        String url = request.getRequestURI();</span><br><span class="line">        System.out.println(url);</span><br><span class="line">        //判断是否是跳转登录页面的请求 放行</span><br><span class="line">        if(url.indexOf(&quot;/user/toLogin&quot;)&gt;0)</span><br><span class="line">            return true;</span><br><span class="line">        //判断是否是用户登录 放行</span><br><span class="line">        if(url.indexOf(&quot;/user/userLogin&quot;)&gt;0)</span><br><span class="line">            return true;</span><br><span class="line">        //获取session</span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        //获取session中的用户对象</span><br><span class="line">        String username = (String) session.getAttribute(&quot;username&quot;);</span><br><span class="line">        //判断session中的用户对象是否存在，存在放行，不存在跳转登录页面</span><br><span class="line">        if(username!=null)</span><br><span class="line">            return true;</span><br><span class="line">        request.setAttribute(&quot;msg&quot;,&quot;您还没有登录，请登录！&quot;);</span><br><span class="line">        request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request,response);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><pre><code>@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125;</code></pre><p>3)前端测试登录页面login.jsp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;%@include file=&quot;/common/head.jsp&quot;%&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring整合Mybatis原理</title>
      <link href="/2022/08/21/Spring%E6%95%B4%E5%90%88Mybatis%E5%8E%9F%E7%90%86/"/>
      <url>/2022/08/21/Spring%E6%95%B4%E5%90%88Mybatis%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="spring整合mybatis操作"><a href="#spring整合mybatis操作" class="headerlink" title="spring整合mybatis操作:"></a>spring整合mybatis操作:</h4><p>原始的spring整合mybatis, 我们会在配置文件中, 添加这两个配置,<br>sqlSessionFactoryBean和MapperScannerConfigure, 另外还有一个<br>数据源和事务管理器(这里不再贴出);</p><p>然后我们就可以在spring容器中使用mybatis;</p><p><img src="https://segmentfault.com/img/bVbHvvC" alt="image.png"></p><h4 id="spring整合mybatis过程如下"><a href="#spring整合mybatis过程如下" class="headerlink" title="spring整合mybatis过程如下:"></a>spring整合mybatis过程如下:</h4><ol><li><p>配置文件中配置mapperScannerConfigure, 并在里面配置要扫描包<br>的路径;</p></li><li><p>maaperSacnnerConfigure类实现了BeanDefinitionRegistryPost<br>Processor接口, 执行了其中的postProcessBeanDefinitionRegistry<br>方法(bean实例还未被创建之前执行);</p></li><li><p>这个方法创建了一个ClassPathMapperScanner类, 并将BeanDefini<br>tionRegistry(他可以将BeanDefintion添加到spring容器中)注入进<br>去, 然后为这个scanner设置各种属性, 其中包括mybatis的配置, 以及<br>sqlsessionFactory, 最后调用scan方法;</p></li><li><p>scan方法则是扫描包下的class文件, 然后包下的接口封装成Bean<br>Definition类, 加入到spring容器中;</p></li><li><p>sqlsessionFactoryBean类的初始化, 继承了主要接口FactoryBean<br><SqlSessionFactory>, InitializingBean, ApplicationListener<br><ApplicationEvent>;</ApplicationEvent></SqlSessionFactory></p></li><li><p>InitializingBean会bean初始化完成赋值之后, 执行afterPro<br>pertiesSet方法, 这个方法中创建了一个sqlSessionFactory(这个创建<br>过程中, 涉及到了mapper.xml文件的的解析, 并将它们封装成各种对<br>象);</p></li><li><p>ApplicationListener, spring容器初始化完成之后, 调用onAppli<br>cationEvent, 调试时没有走这个地方(暂时不做解释);</p></li><li><p>FactoryBean<SqlSessionFactory>接口主要为了生成SqlSession<br>Factory实例, 当进行mapper接口实例化的时候, 会调用factoryBean的<br>getObject方法;</SqlSessionFactory></p></li><li><p>当serviveImp进行初始化的时候, 进行mapper的注入, 这里会初始化<br>这个mapper, 初始化的时候会需要设置一些属性, 这里就包括上面的<br>sqlSessionFactory, 设置完之后, 就是用动态代理创建mapper的代理<br>类设置给serviceImpl;</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不推荐使用@Autowied</title>
      <link href="/2022/08/21/%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-Autowied/"/>
      <url>/2022/08/21/%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-Autowied/</url>
      
        <content type="html"><![CDATA[<p>为什么 Spring和IDEA 都不推荐使用 @Autowired 注解</p><p>前言</p><p>为什么推荐使用@Resource,不推荐使用@Autowired<br>@Autowired, @Qualifier, @Resource, 三者有何区别</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>请看下面几个问题</p><p>Spring为什么不推荐使用@Autowired 注解?<br>为什么推荐使用@Resource 代替 @Autowired 注解?<br>如何快速使用构造注入代替 @Autowired ?<br>@Autowired, @Qualifier, @Resource, 三者有何区别?<br>下面, 我们带着以上问题去梳理和学习, 体会知识之间的关联性</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>做开发的同学可能都会发现, idea 在我们经常使用的@Autowired 注解上添加了警告<br>警告内容是: Field injection is not recommended, 译为: 不推荐使用属性注入</p><p>我们点击右侧三个小点查看描述, 可以看到信息如下图</p><p>原因详情描述: Inspection info: Spring Team recommends: “Always use constructor based dependency injection in your beans. Always use assertions for mandatory dependencies”.<br>译为: Spring 团队建议: 始终在您的 bean 中使用基于构造函数的依赖注入。始终对强制依赖项使用断言</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>为什么 Spring 建议我们在Bean中使用构造注入呢?<br>想要回答这个问题, 我们需要了解 Spring的依赖注入(DI)方式<br>Spring常用的注入方式有: 简单类型注入, 集合类型注入, 域属性自动注入, 自动注入的类别, 空值注入, 构造注入<br>可以简化为: 属性注入, 构造方法注入, set 方法注入</p><p>下面, 来用代码展示下三种方式注入</p><h3 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h3><p>可以看到, 我们开发最常用的就是属性注入</p><pre><code>@RestControllerpublic class AppointmentNumberConfigurationController &#123;@Autowiredprivate AppointmentNumberConfigurationService numberConfigurationService;&#125;</code></pre><h3 id="set-方法注入"><a href="#set-方法注入" class="headerlink" title="set 方法注入"></a>set 方法注入</h3><p>set 方法注入也会用到@Autowired注解，但使用方式与属性注入有所不同，<br>属性注入是用在成员变量上，而set 方法的时候，是用在成员变量的Setter函数上。</p><pre><code>@RestControllerpublic class AppointmentNumberConfigurationController &#123;private AppointmentNumberConfigurationService numberConfigurationService;@Autowiredpublic void setNumberConfigurationService(AppointmentNumberConfigurationService numberConfigurationService) &#123;    this.numberConfigurationService = numberConfigurationService;    &#125;</code></pre><h3 id="构造方法注入"><a href="#构造方法注入" class="headerlink" title="构造方法注入"></a>构造方法注入</h3><p>Constructor Injection是构造器注入，是我们最为推荐的一种使用方式。<br>但是, 每次注入都按照这样的流程去构造注入的话, 会显得比较麻烦.<br>至于如何去简化这一步骤, 我们可以继续往下看.</p><pre><code>@RestControllerpublic class AppointmentNumberConfigurationController &#123;final AppointmentNumberConfigurationService numberConfigurationService;public AppointmentNumberConfigurationController(AppointmentNumberConfigurationService numberConfigurationService) &#123;    this.numberConfigurationService = numberConfigurationService;&#125;&#125;</code></pre><p>三种方式对比如下</p><p>使用属性注入可能会出现的问题</p><p><strong>基于属性注入的方式, 违背单一职责原则</strong><br>因为现在的业务一般都会使用很多依赖, 但拥有太多的依赖通常意味着承担更多的责任,而这显然违背了单一职责原则.<br>并且类和依赖容器强耦合，不能在容器外使用。</p><p><strong>基于属性注入的方式, 容易导致Spring 初始化失败</strong><br>因为现在在Spring特别是Spring Boot使用中, 经常会因为初始化的时候, 由于属性在被注入前就引用而导致npe(空指针错误),<br>进而导致容器初始化失败(类似下面代码块). Java 在初始化一个类时，<br>是按照 静态变量或静态语句块 –&gt; 实例变量或初始化语句块 –&gt; 构造方法 -&gt; @Autowired 的顺序。<br>所以在执行这个类的构造方法时，person 对象尚未被注入，它的值还是 null。</p><p><strong>通过@Autowired 注入, 又因为是 ByType 注入, 因此有可能会出现两个相同的类型bean</strong><br>如下代码快, 就会产生两个相同的Bean, 进而导致Spring 装配失败<br>&#x2F;&#x2F;2. 基于属性注入的方式, 容易导致Spring 初始化失败</p><pre><code>@Autowiredprivate Person person;private String company;public UserServiceImpl()&#123;    this.company = person.getCompany();&#125;//3. 通过@Autowired 注入, 又因为是 ByType 注入, 因此有可能会出现两个相同的类型beanpublic interface IUser &#123;    void say();&#125;@Servicepublic class User1 implements IUser&#123;    @Override    public void say() &#123;    &#125;&#125;@Servicepublic class User2 implements IUser&#123;    @Override    public void say() &#123;    &#125;&#125;@Servicepublic class UserService &#123;@Autowiredprivate IUser user;&#125; </code></pre><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>如果一定要使用属性注入, 可以使用 @Resource 代替 @Autowired 注解<br>@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。<br>如果我们想使用按照名称byName来装配，可以结合@Qualifier注解一起使用。</p><p>如果可能的话, 尽量使用构造注入<br>Lombok提供了一个注解@RequiredArgsConstructor, 可以方便我们快速进行构造注入, 例如:</p><pre><code>@RestController@RequiredArgsConstructorpublic class AppointmentNumberConfigurationController &#123;    final AppointmentNumberConfigurationService numberConfigurationService;&#125;</code></pre><p>同时需要注意：</p><p>使用@RequiredArgsConstructor注解需要导入Lombok 包 或者安装lombok 插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.18.16&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>必须声明的变量为final</p><p>根据构造器注入的，相当于当容器调用带有一组参数的类构造函数时，基于构造函数的 DI 就完成了，<br>其中每个参数代表一个对其他类的依赖。基于构造方法为属性赋值，容器通过调用类的构造方法将其进行依赖注入</p><p>思考<br>为什么推荐使用@Resource,不推荐使用@Autowired<br>通过对问题1 的梳理, 我们可以知道.<br>因为@Autowired 注解在Bean 注入的时候是基于ByType, 因此会由于注入两个相同类型的Bean导致装配失败</p><p>@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。<br>如果我们想使用按照名称byName来装配，可以结合@Qualifier注解一起使用。</p><p>@Resource装配顺序：<br>①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。<br>②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。<br>③如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。<br>④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</p><p>因此, 如果一定要使用属性注入, 可以使用 @Resource 代替 @Autowired 注解</p><p>@Autowired, @Qualifier, @Resource, 三者有何区别<br>@Autowired: 通过byType 方式进行装配, 找不到或是找到多个，都会抛出异常。<br>@Qualifier: 如果想让@Autowired 注入的Bean进行 byName装配, 可以使用 @Qualifier 进行指定<br>@Resource :作用相当于@Autowired，只不过 @Resource 默认按照byName方式装配, 如果没有匹配, 则退回到 byType 方式进行装配</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库ACID</title>
      <link href="/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93ACID/"/>
      <url>/2022/07/16/%E6%95%B0%E6%8D%AE%E5%BA%93ACID/</url>
      
        <content type="html"><![CDATA[<p>ACID，指数据库事务正确执行的四个基本要素的缩写。包含：<a href="https://so.csdn.net/so/search?q=%E5%8E%9F%E5%AD%90%E6%80%A7&spm=1001.2101.3001.7020">原子性</a>（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。一个支持事务（Transaction）的数据库，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易方的要求。</p><h2 id="⑴-原子性（Atomicity）"><a href="#⑴-原子性（Atomicity）" class="headerlink" title="⑴ 原子性（Atomicity）"></a>⑴ 原子性（Atomicity）</h2><p>第一个原子性，这个是最简单的。说的是一个事物内所有操作共同组成一个原子包，要么全部成功，要么全部失败。这是最基本的特性，保证了因为一些其他因素导致数据库异常，或者宕机。</p><h2 id="⑵-一致性（Consistency）"><a href="#⑵-一致性（Consistency）" class="headerlink" title="⑵ 一致性（Consistency）"></a>⑵ 一致性（Consistency）</h2><p>第二一致性，这个是大家误解最深的，很多博客都喜欢用银行转账的例子来讲一直性，所谓的一致性是基于原子性。</p><p>原子性只保证了一个事物内的所有操作同一性，大家同生死，不会出现你死了，我还活着。但是，原子性并没有保证大家同一时刻一起生，一起死。计算机指令是有先后顺序的，这样就决定了一个事物的提交，会经历一个时间过程，那么如果事物提交进行到了一半，我读取了数据库，会不会读到中间结果？</p><p>为了防止这样的情况，数据库事物的一致性就规定了事物提交前后，永远只可能存在事物提交前的状态和事物提交后的状态，从一个一致性的状态到另一个一致性状态，而不可能出现中间的过程态。也就是说事物的执行结果是量子化状态，而不是线性状态。</p><p>数据库提交事物会有一个过程，如果提交的时候，存在一个时间差，在提交的第一秒，一个删除过程还没完成到了第三秒才完成，会不会第一秒访问的人和第三秒访问的人得到不同的结果？出现不一致，状态的混沌？这就是一致性得保证的只会有前状态和后状态，绝不会出现中间态。</p><h2 id="⑶-隔离性（Isolation）"><a href="#⑶-隔离性（Isolation）" class="headerlink" title="⑶ 隔离性（Isolation）"></a>⑶ 隔离性（Isolation）</h2><p>事物的隔离性，基于原子性和一致性，因为事物是原子化，量子化的，所以，事物可以有多个原子包的形式并发执行，但是，每个事物互不干扰。</p><p>但是，由于多个事物可能操作同一个资源，不同的事物为了保证隔离性，会有很多锁方案，当然这是数据库的实现，他们怎么实现的，我们不必深究。</p><h2 id="⑷-持久性（Durability）"><a href="#⑷-持久性（Durability）" class="headerlink" title="⑷ 持久性（Durability）"></a>⑷ 持久性（Durability）</h2><p>持久性，当一个事物提交之后，数据库状态永远的发生了改变，这个事物只要提交了，哪怕提交后宕机，他也确确实实的提交了，不会出现因为</p><p>刚刚宕机了而让提交不生效，是要事物提交，他就像洗不掉的纹身，永远的固化了，除非你毁了硬盘。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayDeque</title>
      <link href="/2022/07/04/ArrayDeque/"/>
      <url>/2022/07/04/ArrayDeque/</url>
      
        <content type="html"><![CDATA[<p>Stack实现了Vector接⼝，LinkKist实现了Deque,List接⼝，ArrayDeque实现了Deque接⼝<br>ArrayDeque、stack、linkedlist特性及为什么要推荐arraydeque实现栈</p><h1 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h1><p>循环数组<br>不⽀持null元素<br>⽆法确定数据量时，扩容会影响其添加速率<br>线程不安全<br>这个数组没有固定的开头或结尾，在头部插⼊数据，不需要⼤⾯积地移动数据。说明其性能很优秀的</p><h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>线性数组结构<br>⽀持添加空元素<br>⽆法确定数据量时，扩容会影响其添加速率<br>线程安全 使⽤synchronized关键字<br>完全依赖vector ，实现⽐较粗糙，</p><h1 id="linkedlist"><a href="#linkedlist" class="headerlink" title="linkedlist"></a>linkedlist</h1><p>链表结构<br>⽀持添加空元素<br>不涉及扩容，原则上jvm堆内存没有满，就可以放多少元素<br>⾮连续的空间 ，随机访问效率低，访问时候不能充分利⽤cpu cache，每次插⼊节点 和删除节点 是很浪费内存的 ，内部节点都可<br>以LinkedList进⾏垃圾收集，这在幕后需要做更多⼯作。此外，由于链表节点被分配在这⾥和那⾥，CPU 缓存的使⽤不会提供太多好<br>处。</p><h1 id="为什么要推荐arraydeque实现栈"><a href="#为什么要推荐arraydeque实现栈" class="headerlink" title="为什么要推荐arraydeque实现栈"></a>为什么要推荐arraydeque实现栈</h1><p>从上⾯的特性可知⾸先排除linkedlist实现栈<br>链表结构的特性；⾮连续的空间 ，随机访问效率低，访问时候不能充分利⽤cpu cache，每次插⼊节点 和删除节点 很浪费内存<br>在从ArrayDeque 和stack 中选择，jdk推荐使⽤arraydeque<br>虽然ArrayDeque不是线程安全的（⽽stack实现的线程安全直接⽤synchronized关键字），但并不影响它被推荐 ⾸先arraydeque 是1.6<br>实现的，循环数组，相对于传统的线性数组来说有⾃⼰的优势，虽然栈感觉⽤不到，其次 jdk实现线程的⽅式推荐的也是使⽤<br>Collections.synchronizedList进⾏封装⼀次，频繁的随机访问操作数据⽐线性结构好；如果想⽤线性数组实现栈，我感觉直接⽤arraylist来实现也挺好的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack</title>
      <link href="/2022/07/02/Stack/"/>
      <url>/2022/07/02/Stack/</url>
      
        <content type="html"><![CDATA[<h1 id="一、栈的理解"><a href="#一、栈的理解" class="headerlink" title="一、栈的理解"></a>一、栈的理解</h1><p>栈（Stack）是一种受限的线性数据结构，所谓受限是指栈只暴露栈顶和栈底的操作，其底层是由数组实现的。栈的特性是先进后出，类似于手枪压弹，原理示意图如下：</p><p><img src="https://img-blog.csdnimg.cn/960d85001a3540a4a48d874cc908f75c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQXJjaGll5pWy6ZSu55uY,size_11,color_FFFFFF,t_70,g_se,x_16"></p><h1 id="二、Stack的继承关系"><a href="#二、Stack的继承关系" class="headerlink" title="二、Stack的继承关系"></a>二、Stack的继承关系</h1><p><img src="https://img-blog.csdnimg.cn/576038c5a3c94ee386f39a27d5e50b5c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQXJjaGll5pWy6ZSu55uY,size_18,color_FFFFFF,t_70,g_se,x_16"></p><h1 id="三、被弃用的Stack"><a href="#三、被弃用的Stack" class="headerlink" title="三、被弃用的Stack"></a>三、被弃用的Stack</h1><h2 id="3-1-被弃用的原因"><a href="#3-1-被弃用的原因" class="headerlink" title="3.1 被弃用的原因"></a>3.1 被弃用的原因</h2><p>从继承关系中，我们可以看到Stack的基本方法与底层实现，由于Vector是动态数组接口，其底层的实现是数组，因此，Stack的底层实现也是数组，且继承了Vector的公共方法。<br>从前文（简析Vector类）我们知道，Vector类具有动态扩容和随机访问的特性，因此，继承了Vector类的Stack也同样具有这些特性，这恰好违背了Stack数据结构的设计原理，正因为如此，Java中的Stack一直被认为是糟糕的实现，官方也将Stack标志为“弃用”（deprecated）。<br>综上所述，导致Stack糟糕实现的原因是Stack与Vector类的关系出现了错误，不应该是继承关系（is-a），而应是组合关系（has-a）。</p><h2 id="3-2-如何替代"><a href="#3-2-如何替代" class="headerlink" title="3.2 如何替代"></a>3.2 如何替代</h2><p>官方推荐使用Deque接口来实现Stack：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;E&gt; stack = new ArrayDeque&lt;&gt;();</span><br></pre></td></tr></table></figure><p>虽然官方做出了推荐，但是我们仍然可以发现，Deque实现的Stack实质是一个双端队列，可以在队列的两端实现插入和删除操作，仍然破坏力了封装性，并不安全，可以看出这并不是一个完美的方法。<br>因此，在实际中更推荐大家再做一层封装，通过逻辑限定为只能一端操作插入和删除，形成一个真正的栈。</p><h2 id="3-3-队列实现栈"><a href="#3-3-队列实现栈" class="headerlink" title="3.3 队列实现栈"></a>3.3 队列实现栈</h2><p>用队列实现栈，只需要⼀个队列作为底层数据结构。<br>要实现的栈的API如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">/** 添加元素到栈顶 */</span><br><span class="line">public void push(int x);</span><br><span class="line">/** 删除栈顶的元素并返回 */</span><br><span class="line">public int pop();</span><br><span class="line">/** 返回栈顶元素 */</span><br><span class="line">public int top();</span><br><span class="line">/** 判断栈是否为空 */</span><br><span class="line">public boolean empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先说 push API，直接将元素加⼊队列，同时记录队尾元素，因为队尾元素相当于栈顶元素，如果要 top 查<br>看栈顶元素的话可以直接返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();</span><br><span class="line">int top_elem = 0;</span><br><span class="line">/** 添加元素到栈顶 */</span><br><span class="line">public void push(int x) &#123;</span><br><span class="line">// x 是队列的队尾，是栈的栈顶</span><br><span class="line">q.offer(x);</span><br><span class="line">top_elem = x;</span><br><span class="line">&#125;</span><br><span class="line">/** 返回栈顶元素 */</span><br><span class="line">public int top() &#123;</span><br><span class="line">return top_elem;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的底层数据结构是先进先出的队列，每次 pop 只能从队头取元素；但是栈是后进先出，也就是说 pop<br>API 要从队尾取元素：</p><p>解决⽅法简单粗暴，把队列前⾯的都取出来再加⼊队尾，让之前的队尾元素排到队头，这样就可以取出了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/** 删除栈顶的元素并返回 */</span><br><span class="line">public int pop() &#123;</span><br><span class="line">int size = q.size();</span><br><span class="line">while (size &gt; 1) &#123;</span><br><span class="line">size--;</span><br><span class="line">&#125;</span><br><span class="line">// 之前的队尾元素已经到了队头</span><br><span class="line">return q.poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样实现还有⼀点⼩问题就是，原来的队尾元素被提到队头并删除了，但是 top_elem 变量没有更新，我们<br>还需要⼀点⼩修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/** 删除栈顶的元素并返回 */</span><br><span class="line">public int pop() &#123;</span><br><span class="line">int size = q.size();</span><br><span class="line">// 留下队尾 2 个元素</span><br><span class="line">while (size &gt; 2) &#123;</span><br><span class="line">q.offer(q.poll());</span><br><span class="line">size--;</span><br><span class="line">&#125;</span><br><span class="line">// 记录新的队尾元素</span><br><span class="line">top_elem = q.peek();</span><br><span class="line">q.offer(q.poll());</span><br><span class="line">// 删除之前的队尾元素</span><br><span class="line">return q.poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，API empty 就很容易实现了，只要看底层的队列是否为空即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/** 判断栈是否为空 */</span><br><span class="line">public boolean empty() &#123;</span><br><span class="line">return q.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，⽤队列实现栈的话，pop 操作时间复杂度是 O(N)，其他操作都是 O(1) 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deque和queue</title>
      <link href="/2022/07/02/deque%E5%92%8Cqueue/"/>
      <url>/2022/07/02/deque%E5%92%8Cqueue/</url>
      
        <content type="html"><![CDATA[<h3 id="队列-queue-简述"><a href="#队列-queue-简述" class="headerlink" title="队列(queue)简述"></a>队列(queue)简述</h3><p>队列(queue)是一种常用的<strong>数据结构</strong>，可以将队列看做是一种特殊的线性表，该结构遵循的先进先出原则。Java中，<strong>LinkedList实现了Queue接口</strong>,因为LinkedList进行插入、删除操作效率较高。</p><p>在处理元素前用于保存元素的 collection。除了基本的 <a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Collection.html"><code>Collection</code></a> 操作外，队列还提供其他的插入、提取和检查操作。每个方法都存在两种形式：一种抛出异常（操作失败时），另一种返回一个特殊值（<code>null</code> 或 <code>false</code>，具体取决于操作）。插入操作的后一种形式是用于专门为有容量限制的 <code>Queue</code> 实现设计的；在大多数实现中，插入操作不会失败。</p><table><thead><tr><th></th><th><em>抛出异常</em></th><th><em>返回特殊值</em></th></tr></thead><tbody><tr><td><strong>插入</strong></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Queue.html#add(E)"><code>add(e)</code></a></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Queue.html#offer(E)"><code>offer(e)</code></a></td></tr><tr><td><strong>移除</strong></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Queue.html#remove()"><code>remove()</code></a></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Queue.html#poll()"><code>poll()</code></a></td></tr><tr><td><strong>检查</strong></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Queue.html#element()"><code>element()</code></a></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Queue.html#peek()"><code>peek()</code></a></td></tr></tbody></table><p>队列通常（但并非一定）以 FIFO（先进先出）的方式排序各个元素。不过优先级队列和 LIFO 队列（或堆栈）例外，前者根据提供的比较器或元素的自然顺序对元素进行排序，后者按 LIFO（后进先出）的方式对元素进行排序。无论使用哪种排序方式，队列的<em>头</em> 都是调用 <a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Queue.html#remove()"><code>remove()</code></a> 或 <a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Queue.html#poll()"><code>poll()</code></a> 所移除的元素。在 FIFO 队列中，所有的新元素都插入队列的<em>末尾</em>。其他种类的队列可能使用不同的元素放置规则。每个 <code>Queue</code> 实现必须指定其顺序属性。</p><p><code>Queue</code> 接口并未定义<em>阻塞队列的方法</em>，而这在并发编程中是很常见的。<a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/concurrent/BlockingQueue.html"><code>BlockingQueue</code></a> 接口定义了那些等待元素出现或等待队列中有可用空间的方法，这些方法扩展了此接口。</p><p><code>Queue</code> 实现通常不允许插入 <code>null</code> 元素，尽管某些实现（如 <a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/LinkedList.html"><code>LinkedList</code></a>）并不禁止插入 <code>null</code>。即使在允许 null 的实现中，也不应该将 <code>null</code> 插入到 <code>Queue</code> 中，因为 <code>null</code> 也用作 <code>poll</code> 方法的一个特殊返回值，表明队列不包含元素。</p><p><code>Queue</code> 实现通常未定义 <code>equals</code> 和 <code>hashCode</code> 方法的基于元素的版本，而是从 <code>Object</code> 类继承了基于身份的版本，因为对于具有相同元素但有不同排序属性的队列而言，基于元素的相等性并非总是定义良好的。</p><p><img src="https://www.likecs.com/default/index/img?u=aHR0cHM6Ly9waWFuc2hlbi5jb20vaW1hZ2VzLzU0Lzg1MzM4Y2I2OTNmYWM4Yzk4ZDU5MWQ2MTEzODVkMmI2LnBuZw=="></p><h3 id="Queue常用方法："><a href="#Queue常用方法：" class="headerlink" title="Queue常用方法："></a>Queue常用方法：</h3><ol><li>boolean add(E e);将指定的元素插入此队列（如果立即可行且不会违反容量限制），在成功时返回 <code>true</code>，如果当前没有可用的空间，则抛出 <code>IllegalStateException</code>。</li><li>boolean offer(E e);将指定的元素插入此队列（如果立即可行且不会违反容量限制），当使用有容量限制的队列时，此方法通常要优于 <a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Queue.html#add(E)"><code>add(E)</code></a>，后者可能无法插入元素，而只是抛出一个异常。</li><li>E remove();获取并移除此队列的头。</li><li>E poll();获取并移除此队列的头，如果此队列为空，则返回 <code>null</code>。</li><li>E element();获取，但是不移除此队列的头。</li><li>E peek();获取但不移除此队列的头；如果此队列为空，则返回 <code>null</code>。</li></ol><h3 id="双端队列（Deque）简述"><a href="#双端队列（Deque）简述" class="headerlink" title="双端队列（Deque）简述"></a>双端队列（Deque）简述</h3><p>双向队列(Deque),是Queue的一个子接口，双向队列是指该队列两端的元素既能入队(offer)也能出队(poll),如果将Deque限制为只能从一端入队和出队，则可实现栈的数据结构。对于栈而言，有入栈(push)和出栈(pop)，遵循先进后出原则。</p><p>一个线性 collection，支持在两端插入和移除元素。名称 <em>deque</em> 是“double ended queue（双端队列）”的缩写，通常读为“deck”。大多数 <code>Deque</code> 实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。</p><p>此接口定义在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（<code>null</code> 或 <code>false</code>，具体取决于操作）。插入操作的后一种形式是专为使用有容量限制的 <code>Deque</code> 实现设计的；在大多数实现中，插入操作不能失败。</p><p>下表总结了上述 12 种方法：</p><table><thead><tr><th></th><th><strong>第一个元素（头部）</strong></th><th><strong>最后一个元素（尾部）</strong></th><th></th><th></th></tr></thead><tbody><tr><td></td><td><em>抛出异常</em></td><td><em>特殊值</em></td><td><em>抛出异常</em></td><td><em>特殊值</em></td></tr><tr><td><strong>插入</strong></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#addFirst(E)"><code>addFirst(e)</code></a></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#offerFirst(E)"><code>offerFirst(e)</code></a></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#addLast(E)"><code>addLast(e)</code></a></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#offerLast(E)"><code>offerLast(e)</code></a></td></tr><tr><td><strong>移除</strong></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#removeFirst()"><code>removeFirst()</code></a></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#pollFirst()"><code>pollFirst()</code></a></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#removeLast()"><code>removeLast()</code></a></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#pollLast()"><code>pollLast()</code></a></td></tr><tr><td><strong>检查</strong></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#getFirst()"><code>getFirst()</code></a></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#peekFirst()"><code>peekFirst()</code></a></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#getLast()"><code>getLast()</code></a></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#peekLast()"><code>peekLast()</code></a></td></tr></tbody></table><p>此接口扩展了 <a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Queue.html"><code>Queue</code></a> 接口。在将双端队列用作队列时，将得到 FIFO（先进先出）行为。将元素添加到双端队列的末尾，从双端队列的开头移除元素。从 <code>Queue</code> 接口继承的方法完全等效于 <code>Deque</code> 方法，如下表所示：</p><p>此接口扩展了 <a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Queue.html"><code>Queue</code></a> 接口。在将双端队列用作队列时，将得到 FIFO（先进先出）行为。将元素添加到双端队列的末尾，从双端队列的开头移除元素。从 <code>Queue</code> 接口继承的方法完全等效于 <code>Deque</code> 方法，如下表所示：</p><table><thead><tr><th><strong>Queue 方法</strong></th><th><strong>等效 Deque 方法</strong></th></tr></thead><tbody><tr><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Queue.html#add(E)"><code>add(e)</code></a></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#addLast(E)"><code>addLast(e)</code></a></td></tr><tr><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Queue.html#offer(E)"><code>offer(e)</code></a></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#offerLast(E)"><code>offerLast(e)</code></a></td></tr><tr><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Queue.html#remove()"><code>remove()</code></a></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#removeFirst()"><code>removeFirst()</code></a></td></tr><tr><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Queue.html#poll()"><code>poll()</code></a></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#pollFirst()"><code>pollFirst()</code></a></td></tr><tr><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Queue.html#element()"><code>element()</code></a></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#getFirst()"><code>getFirst()</code></a></td></tr><tr><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Queue.html#peek()"><code>peek()</code></a></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#peek()"><code>peekFirst()</code></a></td></tr></tbody></table><p>双端队列也可用作 LIFO（后进先出）堆栈。应优先使用此接口而不是遗留 <a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Stack.html"><code>Stack</code></a> 类。在将双端队列用作堆栈时，元素被推入双端队列的开头并从双端队列开头弹出。堆栈方法完全等效于 <code>Deque</code> 方法，如下表所示：</p><table><thead><tr><th><strong>堆栈方法</strong></th><th><strong>等效 Deque 方法</strong></th></tr></thead><tbody><tr><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#push(E)"><code>push(e)</code></a></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#addFirst(E)"><code>addFirst(e)</code></a></td></tr><tr><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#pop()"><code>pop()</code></a></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#removeFirst()"><code>removeFirst()</code></a></td></tr><tr><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#peek()"><code>peek()</code></a></td><td><a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#peekFirst()"><code>peekFirst()</code></a></td></tr></tbody></table><p>注意，在将双端队列用作队列或堆栈时，<a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#peek()"><code>peek</code></a> 方法同样正常工作；无论哪种情况下，都从双端队列的开头抽取元素。</p><p>此接口提供了两种移除内部元素的方法：<a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#removeFirstOccurrence(java.lang.Object)"><code>removeFirstOccurrence</code></a> 和 <a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html#removeLastOccurrence(java.lang.Object)"><code>removeLastOccurrence</code></a>。</p><p>与 <a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/List.html"><code>List</code></a> 接口不同，此接口不支持通过索引访问元素。</p><p>虽然 <code>Deque</code> 实现没有严格要求禁止插入 null 元素，但建议最好这样做。建议任何事实上允许 null 元素的 <code>Deque</code> 实现用户最好<em>不</em> 要利用插入 null 的功能。这是因为各种方法会将 <code>null</code> 用作特殊的返回值来指示双端队列为空。</p><p><code>Deque</code> 实现通常不定义基于元素的 <code>equals</code> 和 <code>hashCode</code> 方法，而是从 <code>Object</code> 类继承基于身份的 <code>equals</code> 和 <code>hashCode</code> 方法。</p><ul><li><p><strong>从以下版本开始：</strong></p><p>1.6</p></li></ul><hr><table><thead><tr><th>方法摘要</th><th></th></tr></thead><tbody><tr><td><code> boolean</code></td><td><code>add(E e)</code>            将指定元素插入此双端队列所表示的队列（换句话说，此双端队列的尾部），如果可以直接这样做而不违反容量限制的话；如果成功，则返回 <code>true</code>，如果当前没有可用空间，则抛出 <code>IllegalStateException</code>。</td></tr><tr><td><code> void</code></td><td><code>addFirst(E e)</code>            将指定元素插入此双端队列的开头（如果可以直接这样做而不违反容量限制）。</td></tr><tr><td><code> void</code></td><td><code>addLast(E e)</code>            将指定元素插入此双端队列的末尾（如果可以直接这样做而不违反容量限制）。</td></tr><tr><td><code> boolean</code></td><td><code>contains(Object o)</code>            如果此双端队列包含指定元素，则返回 <code>true</code>。</td></tr><tr><td><code> Iterator&lt;E&gt;</code></td><td><code>descendingIterator()</code>            返回以逆向顺序在此双端队列的元素上进行迭代的迭代器。</td></tr><tr><td><code> E</code></td><td><code>element()</code>            获取，但不移除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素）。</td></tr><tr><td><code> E</code></td><td><code>getFirst()</code>            获取，但不移除此双端队列的第一个元素。</td></tr><tr><td><code> E</code></td><td><code>getLast()</code>            获取，但不移除此双端队列的最后一个元素。</td></tr><tr><td><code> Iterator&lt;E&gt;</code></td><td><code>iterator()</code>            返回以恰当顺序在此双端队列的元素上进行迭代的迭代器。</td></tr><tr><td><code> boolean</code></td><td><code>offer(E e)</code>            将指定元素插入此双端队列所表示的队列（换句话说，此双端队列的尾部），如果可以直接这样做而不违反容量限制的话；如果成功，则返回 <code>true</code>，如果当前没有可用的空间，则返回 <code>false</code>。</td></tr><tr><td><code> boolean</code></td><td><code>offerFirst(E e)</code>            在不违反容量限制的情况下，将指定的元素插入此双端队列的开头。</td></tr><tr><td><code> boolean</code></td><td><code>offerLast(E e)</code>            在不违反容量限制的情况下，将指定的元素插入此双端队列的末尾。</td></tr><tr><td><code> E</code></td><td><code>peek()</code>            获取，但不移除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素）；如果此双端队列为空，则返回 <code>null</code>。</td></tr><tr><td><code> E</code></td><td><code>peekFirst()</code>            获取，但不移除此双端队列的第一个元素；如果此双端队列为空，则返回 <code>null</code>。</td></tr><tr><td><code> E</code></td><td><code>peekLast()</code>            获取，但不移除此双端队列的最后一个元素；如果此双端队列为空，则返回 <code>null</code>。</td></tr><tr><td><code> E</code></td><td><code>poll()</code>            获取并移除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素）；如果此双端队列为空，则返回 <code>null</code>。</td></tr><tr><td><code> E</code></td><td><code>pollFirst()</code>            获取并移除此双端队列的第一个元素；如果此双端队列为空，则返回 <code>null</code>。</td></tr><tr><td><code> E</code></td><td><code>pollLast()</code>            获取并移除此双端队列的最后一个元素；如果此双端队列为空，则返回 <code>null</code>。</td></tr><tr><td><code> E</code></td><td><code>pop()</code>            从此双端队列所表示的堆栈中弹出一个元素。</td></tr><tr><td><code> void</code></td><td><code>push(E e)</code>            将一个元素推入此双端队列所表示的堆栈（换句话说，此双端队列的头部），如果可以直接这样做而不违反容量限制的话；如果成功，则返回 <code>true</code>，如果当前没有可用空间，则抛出 <code>IllegalStateException</code>。</td></tr><tr><td><code> E</code></td><td><code>remove()</code>            获取并移除此双端队列所表示的队列的头部（换句话说，此双端队列的第一个元素）。</td></tr><tr><td><code> boolean</code></td><td><code>remove(Object o)</code>            从此双端队列中移除第一次出现的指定元素。</td></tr><tr><td><code> E</code></td><td><code>removeFirst()</code>            获取并移除此双端队列第一个元素。</td></tr><tr><td><code> boolean</code></td><td><code>removeFirstOccurrence(Object o)</code>            从此双端队列移除第一次出现的指定元素。</td></tr><tr><td><code> E</code></td><td><code>removeLast()</code>            获取并移除此双端队列的最后一个元素。</td></tr><tr><td><code> boolean</code></td><td><code>removeLastOccurrence(Object o)</code>            从此双端队列移除最后一次出现的指定元素。</td></tr><tr><td><code> int</code></td><td><code>size()</code>            返回此双端队列的元素数。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList和LinkedList比较</title>
      <link href="/2022/06/17/ArrayList%E5%92%8CLinkedList%E6%AF%94%E8%BE%83/"/>
      <url>/2022/06/17/ArrayList%E5%92%8CLinkedList%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<p>ArrayList </p><p>基于数组，需要连续内存</p><p>随机访问块（根据下标访问）</p><p>尾部插入，删除性能可以，其他部分插入、删除都会移动数据，因此性能低</p><p>可以利用cpu缓存，局部性原理</p><p>LinkedList</p><p>基于双向链表无需连续内存</p><p>随机访问慢，（要沿着</p>]]></content>
      
      
      
        <tags>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList扩容</title>
      <link href="/2022/06/17/ArrayList%E6%89%A9%E5%AE%B9/"/>
      <url>/2022/06/17/ArrayList%E6%89%A9%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<p>ArrayList 无参构造时初始化为空，长度为零</p><p>有参构造时，根据集合大小或者指定容量作为数组容量</p><p>add(Object o) </p><p>首次扩容 为10，再次扩容为上次容量的1.5倍（底层通过右移操作15&gt;&gt;1 &#x3D; 7        7+15 &#x3D; 22)</p><p>[0,10,15,22,33,49,73,109………]</p><p>addAll(……)</p><p>MAX（下次扩容的容量大小，数组元素的大小）</p><p>没有元素时</p><p>Max（10，实际元素的个数）</p><p>例如插入三个数，Max（10,3）扩容10</p><p>插入11个数，Max（10,11）扩容11</p><p>有元素时</p><p>Max（原容量的1.5倍，实际元素个数）</p>]]></content>
      
      
      
        <tags>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fail fast和fail safe</title>
      <link href="/2022/06/17/fail-fast%E5%92%8Cfail-safe/"/>
      <url>/2022/06/17/fail-fast%E5%92%8Cfail-safe/</url>
      
        <content type="html"><![CDATA[<p>fail fast 一旦发现遍历的同时其他人来修改，则立即抛出异常</p><p>fail safe 发现遍历的同时其他人来修改，应当能有应对策略，如牺牲一致性来让整个遍历运行完成</p><p>ArrayList :  fail fast</p><p>如果遍历时集合被修改，进入下一轮遍历时抛异常，ConcurrentModificationException</p><p>foreach循环，底层也是用的迭代器，创建迭代器对象（Iterator)时将集合的属性modCount赋值给迭代器的成员变量expectedModCount;</p><p>modCount是集合从创建开始就维护的一个成员变量，任何对集合的修改操作都会被modCount记录</p><p>然后执行hashNext()看是否存在下一个元素</p><p>然后next()获取下一个元素，在next()方法中首先要比较modCount和expectedModCount是否相等，如果相等，什么也不做，如果不相等，抛出ConcurrentModificationException异常，代表遍历时，别的线程修改了当前集合</p><p>CopyOnWriteArrayList：fail safe</p><p>foreach循环开始，创建迭代器对象，该迭代器初始化时，将当前要遍历的数组记录下来，保存在迭代器的成员变量里</p><p>别的线程修改集合时，迭代器中的数组和list集合中的数组，不是同一个数组</p><p>通过add函数实现，每次add时，将原数组拷贝一份，长度+1，然后将数据插入新数组后面，然后将新数组赋值给list，从而达到，读是一个数组，写是另一个数组</p><p>fail-fast机制<br>“快速失败”，是java集合的一种错误检测机制，某个线程对collection进行迭代时，不允许其他线程对该collection进行结构上的修改。java.util包中的所有集合类都是快速失败的，而java.util.concurrent包中的集合类都是安全失败的；快速失败的迭代器在出错时会抛出ConcurrentModificationException，而安全失败的迭代器从不抛出这个异常。<br>总结：             fast-fail事件产生的条件：当多个线程对Collection进行操作时，若其中某一个线程通过iterator去遍历集合时，该集合的内容被其他线程所改变；则会抛出ConcurrentModificationException异常。<br>         fast-fail解决办法：通过util.concurrent集合包下的相应类去处理，则不会产生fast-fail事件。如 CopyOnWriteArrayList<br>那么， ConcurrentModificationException是如何产生的呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123;</span><br><span class="line"> ...</span><br><span class="line"> // AbstractList中唯一的属性</span><br><span class="line"> // 用来记录List修改的次数：每修改一次(添加/删除等操作)，将modCount+1</span><br><span class="line"> protected transient int modCount = 0;</span><br><span class="line"></span><br><span class="line"> // 返回List对应迭代器。实际上，是返回Itr对象。</span><br><span class="line"> public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">  return new Itr();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // Itr是Iterator(迭代器)的实现类</span><br><span class="line"> private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">  int cursor = 0;</span><br><span class="line"></span><br><span class="line">  int lastRet = -1;</span><br><span class="line"></span><br><span class="line">  // 修改数的记录值。</span><br><span class="line">  // 每次新建Itr()对象时，都会保存新建该对象时对应的modCount；</span><br><span class="line">  // 以后每次遍历List中的元素的时候，都会比较expectedModCount和modCount是否相等；</span><br><span class="line">  // 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。</span><br><span class="line">  int expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">  public boolean hasNext() &#123;</span><br><span class="line">   return cursor != size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public E next() &#123;</span><br><span class="line">   // 获取下一个元素之前，都会判断“新建Itr对象时保存的modCount”和“当前的modCount”是否相等；</span><br><span class="line">   // 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> checkForComodification();</span><br><span class="line">   try &#123;</span><br><span class="line">    E next = get(cursor);</span><br><span class="line">    lastRet = cursor++;</span><br><span class="line">    return next;</span><br><span class="line">   &#125; catch (IndexOutOfBoundsException e) &#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    throw new NoSuchElementException();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void remove() &#123;</span><br><span class="line">   if (lastRet == -1)</span><br><span class="line">    throw new IllegalStateException();</span><br><span class="line">   checkForComodification();</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">    AbstractList.this.remove(lastRet);</span><br><span class="line">    if (lastRet &lt; cursor)</span><br><span class="line">     cursor--;</span><br><span class="line">    lastRet = -1;</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">   &#125; catch (IndexOutOfBoundsException e) &#123;</span><br><span class="line">    throw new ConcurrentModificationException();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  final void checkForComodification() &#123;</span><br><span class="line">   if (modCount != expectedModCount)</span><br><span class="line">    throw new ConcurrentModificationException();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行next()和remove()方法时，都会执行checkForComodication()方法，目的就是为了检测modCount和expectedModCount是否一致。在Itr类中，初始化对象时expectedModCount被赋值为modCount。而通过查看ArrayList源码可知，在add(),remove(),clear()等方法中（涉及到修改集合中元素个数），都会改变modCount值。</p><p>在执行next()和remove()方法时，都会执行checkForComodication()方法，目的就是为了检测modCount和expectedModCount是否一致。在Itr类中，初始化对象时expectedModCount被赋值为modCount。而通过查看ArrayList源码可知，在add(),remove(),clear()等方法中（涉及到修改集合中元素个数），都会改变modCount值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap七种遍历方式</title>
      <link href="/2022/06/12/HashMap%E4%B8%83%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/"/>
      <url>/2022/06/12/HashMap%E4%B8%83%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap-遍历"><a href="#HashMap-遍历" class="headerlink" title="HashMap 遍历"></a>HashMap 遍历</h1><p>HashMap 遍历从大的方向来说，可分为以下 4 类：</p><ul><li><p>迭代器（Iterator）方式遍历</p></li><li><p>For Each 方式遍历</p></li><li><p>Lambda 表达式遍历（JDK 1.8+）</p></li><li><p>Streams API 遍历（JDK 1.8+）</p></li></ul><p>但每种类型下又有不同的实现方式，因此具体的遍历方式又可以分为以下 7 种：</p><ul><li><p>使用迭代器（Iterator）EntrySet 的方式进行遍历；</p></li><li><p>使用迭代器（Iterator）KeySet 的方式进行遍历；</p></li><li><p>使用 For Each EntrySet 的方式进行遍历；</p></li><li><p>使用 For Each KeySet 的方式进行遍历；</p></li><li><p>使用 Lambda 表达式的方式进行遍历；</p></li><li><p>使用 Streams API 单线程的方式进行遍历；</p></li><li><p>使用 Streams API 多线程的方式进行遍历。</p></li></ul><h2 id="迭代器-EntrySet"><a href="#迭代器-EntrySet" class="headerlink" title="迭代器 EntrySet"></a>迭代器 EntrySet</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;k1&quot;, 1);</span><br><span class="line">        map.put(&quot;k2&quot;, 2);</span><br><span class="line">        map.put(&quot;k3&quot;, 3);</span><br><span class="line">        map.put(&quot;k4&quot;, 4);</span><br><span class="line">        map.put(&quot;k5&quot;, 5);</span><br><span class="line">//      第一种 迭代器 EntrySet</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;String,Integer&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(entry.getKey()+&quot;: &quot;+entry.getValue());</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k1: 1</span><br><span class="line">k2: 2</span><br><span class="line">k3: 3</span><br><span class="line">k4: 4</span><br><span class="line">k5: 5</span><br></pre></td></tr></table></figure><h2 id="迭代器-KeySet"><a href="#迭代器-KeySet" class="headerlink" title="迭代器 KeySet"></a>迭代器 KeySet</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;k1&quot;, 1);</span><br><span class="line">        map.put(&quot;k2&quot;, 2);</span><br><span class="line">        map.put(&quot;k3&quot;, 3);</span><br><span class="line">        map.put(&quot;k4&quot;, 4);</span><br><span class="line">        map.put(&quot;k5&quot;, 5);</span><br><span class="line">//      第二种 迭代器 KeySet</span><br><span class="line">        Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            String key = iterator.next();</span><br><span class="line">            System.out.println(key+&quot;: &quot;+map.get(key));</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ForEach-EntrySet"><a href="#ForEach-EntrySet" class="headerlink" title="ForEach EntrySet"></a>ForEach EntrySet</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;k1&quot;, 1);</span><br><span class="line">        map.put(&quot;k2&quot;, 2);</span><br><span class="line">        map.put(&quot;k3&quot;, 3);</span><br><span class="line">        map.put(&quot;k4&quot;, 4);</span><br><span class="line">        map.put(&quot;k5&quot;, 5);</span><br><span class="line">        //for each</span><br><span class="line">        for (Map.Entry&lt;String,Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey()+&quot;: &quot;+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ForEach-KeySet"><a href="#ForEach-KeySet" class="headerlink" title="ForEach KeySet"></a>ForEach KeySet</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;k1&quot;, 1);</span><br><span class="line">        map.put(&quot;k2&quot;, 2);</span><br><span class="line">        map.put(&quot;k3&quot;, 3);</span><br><span class="line">        map.put(&quot;k4&quot;, 4);</span><br><span class="line">        map.put(&quot;k5&quot;, 5);</span><br><span class="line">        //for each</span><br><span class="line">        for (String key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key+&quot;: &quot;+map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;k1&quot;, 1);</span><br><span class="line">        map.put(&quot;k2&quot;, 2);</span><br><span class="line">        map.put(&quot;k3&quot;, 3);</span><br><span class="line">        map.put(&quot;k4&quot;, 4);</span><br><span class="line">        map.put(&quot;k5&quot;, 5);</span><br><span class="line">        //for each</span><br><span class="line">        map.forEach((key,value) -&gt;&#123;</span><br><span class="line">            System.out.println(key+&quot;: &quot;+value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Streams-API-单线程"><a href="#Streams-API-单线程" class="headerlink" title="Streams API 单线程"></a>Streams API 单线程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;k1&quot;, 1);</span><br><span class="line">        map.put(&quot;k2&quot;, 2);</span><br><span class="line">        map.put(&quot;k3&quot;, 3);</span><br><span class="line">        map.put(&quot;k4&quot;, 4);</span><br><span class="line">        map.put(&quot;k5&quot;, 5);</span><br><span class="line">        map.entrySet().stream().forEach((entry) -&gt;&#123;</span><br><span class="line">            System.out.println(entry.getKey()+&quot;: &quot;+entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Streams-API-多线程"><a href="#Streams-API-多线程" class="headerlink" title="Streams API 多线程"></a>Streams API 多线程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;k1&quot;, 1);</span><br><span class="line">        map.put(&quot;k2&quot;, 2);</span><br><span class="line">        map.put(&quot;k3&quot;, 3);</span><br><span class="line">        map.put(&quot;k4&quot;, 4);</span><br><span class="line">        map.put(&quot;k5&quot;, 5);</span><br><span class="line">        //for each</span><br><span class="line">        map.entrySet().parallelStream().forEach((entry) -&gt;&#123;</span><br><span class="line">            System.out.println(entry.getKey()+&quot;: &quot;+entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k3: 3</span><br><span class="line">k4: 4</span><br><span class="line">k5: 5</span><br><span class="line">k1: 1</span><br><span class="line">k2: 2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java_map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java序列化与反序列化</title>
      <link href="/2022/06/05/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2022/06/05/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="序列化和反序列化概念"><a href="#序列化和反序列化概念" class="headerlink" title="序列化和反序列化概念"></a>序列化和反序列化概念</h1><p>Serialization（序列化）是一种将对象以一连串的字节描述的过程；反序列化deserialization是一种将这些字节重建成一个对象的过程。将程序中的对象，放入文件中保存就是序列化，将文件中的字节码重新转成对象就是反序列化。</p><h1 id="序列化和反序列化的必要性"><a href="#序列化和反序列化的必要性" class="headerlink" title="序列化和反序列化的必要性"></a>序列化和反序列化的必要性</h1><p>当两个进程进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等， 而这些数据都会以二进制序列的形式在网络上传送。<br>而java是面向对象的开发方式，一切都是java对象，想要实现java对象的网络传输，就可以使用序列化和反序列化来实现。发送方将需要发送的Java对象序列化转换为字节序列，然后在网络上传送；接收方接收到字符序列后，使用反序列化从字节序列中恢复出Java对象。</p><p>当我们了解了为什么需要Java序列化和反序列化后，我们很自然地会想Java序列化的好处。</p><p>一是实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里）；<br>二是利用序列化实现远程通信，即在网络上传送对象的字节序列。<br>总结，在网络中数据的传输必须是序列化形式来进行的。其他序列化的方式可以是json传输，xml形式传输。</p><h1 id="序列化和反序列化的实现"><a href="#序列化和反序列化的实现" class="headerlink" title="序列化和反序列化的实现"></a>序列化和反序列化的实现</h1><ol><li><p>JDK类库提供的序列化API<br>java.io.ObjectOutputStream：表示对象输出流<br>它的writeObject(Object obj)方法可以对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。<br>java.io.ObjectInputStream：表示对象输入流<br>它的readObject()方法从源输入流中读取字节序列，再把它们反序列化成为一个对象，并将其返回。</p></li><li><p>实现序列化的要求<br>只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常。</p></li><li><p>实现Java对象序列化与反序列化的方法<br>假定一个Student类，它的对象需要序列化，可以有如下三种方法：</p></li></ol><p>方法一：若Student类仅仅实现了Serializable接口，则可以按照以下方式进行序列化和反序列化。<br>ObjectOutputStream采用默认的序列化方式，对Student对象的非transient的实例变量进行序列化。<br>ObjcetInputStream采用默认的反序列化方式，对对Student对象的非transient的实例变量进行反序列化。<br>方法二：若Student类仅仅实现了Serializable接口，并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out)，则采用以下方式进行序列化与反序列化。<br>ObjectOutputStream调用Student对象的writeObject(ObjectOutputStream out)的方法进行序列化。<br>ObjectInputStream会调用Student对象的readObject(ObjectInputStream in)的方法进行反序列化。<br>方法三：若Student类实现了Externalnalizable接口，且Student类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法，则按照以下方式进行序列化与反序列化。<br>ObjectOutputStream调用Student对象的writeExternal(ObjectOutput out))的方法进行序列化。<br>ObjectInputStream会调用Student对象的readExternal(ObjectInput in)的方法进行反序列化。<br>4.  JDK类库中序列化的步骤<br>步骤一：创建一个对象输出流，它可以包装一个其它类型的目标输出流，如文件输出流：</p><p>ObjectOutputStream out &#x3D; new ObjectOutputStream(new fileOutputStream(“D:\objectfile.obj”));<br>步骤二：通过对象输出流的writeObject()方法写对象：</p><p>out.writeObject(“Hello”);<br>out.writeObject(new Date());<br>5.  JDK类库中反序列化的步骤<br>步骤一：创建一个对象输入流，它可以包装一个其它类型输入流，如文件输入流：</p><p>ObjectInputStream in &#x3D; new ObjectInputStream(new fileInputStream(“D:\objectfile.obj”));<br>步骤二：通过对象输出流的readObject()方法读取对象：</p><p>String obj1 &#x3D; (String)in.readObject();<br>Date obj2 &#x3D; (Date)in.readObject();<br>说明：为了正确读取数据，完成反序列化，必须保证向对象输出流写对象的顺序与从对象输入流中读对象的顺序一致。<br>为了更好地理解Java序列化与反序列化，选择方法一编码实现。<br>Student类定义如下：</p><p>&#x2F;**</p><ul><li>实现了序列化接口的学生类</li></ul><p> *&#x2F;<br>public class Student implements Serializable {<br>    private String name;<br>    private char sex;<br>    private int year;<br>    private double gpa;</p><pre><code>public Student() &#123;&#125;public Student(String name,char sex,int year,double gpa) &#123;    this.name = name;    this.sex = sex;    this.year = year;    this.gpa = gpa;&#125;public void setName(String name) &#123;    this.name = name;&#125;public void setSex(char sex) &#123;    this.sex = sex;&#125;public void setYear(int year) &#123;    this.year = year;&#125;public void setGpa(double gpa) &#123;    this.gpa = gpa;&#125;public String getName() &#123;    return this.name;&#125;public char getSex() &#123;    return this.sex;&#125;public int getYear() &#123;    return this.year;&#125;public double getGpa() &#123;    return this.gpa;&#125;</code></pre><p>}<br>把Student类的对象序列化到文件&#x2F;Users&#x2F;sschen&#x2F;Documents&#x2F;student.txt，并从该文件中反序列化，向console显示结果。代码如下：</p><p>public class UserStudent {<br>    public static void main(String[] args) {<br>        Student st &#x3D; new Student(“Tom”,’M’,20,3.6);<br>        File file &#x3D; new File(“&#x2F;Users&#x2F;sschen&#x2F;Documents&#x2F;student.txt”);<br>        try {<br>            file.createNewFile();<br>        }<br>        catch(IOException e) {<br>            e.printStackTrace();<br>        }<br>        try {<br>            &#x2F;&#x2F;Student对象序列化过程<br>            FileOutputStream fos &#x3D; new FileOutputStream(file);<br>            ObjectOutputStream oos &#x3D; new ObjectOutputStream(fos);<br>            oos.writeObject(st);<br>            oos.flush();<br>            oos.close();<br>            fos.close();</p><pre><code>        //Student对象反序列化过程        FileInputStream fis = new FileInputStream(file);        ObjectInputStream ois = new ObjectInputStream(fis);        Student st1 = (Student) ois.readObject();        System.out.println(&quot;name = &quot; + st1.getName());        System.out.println(&quot;sex = &quot; + st1.getSex());        System.out.println(&quot;year = &quot; + st1.getYear());        System.out.println(&quot;gpa = &quot; + st1.getGpa());        ois.close();        fis.close();    &#125;    catch(ClassNotFoundException e) &#123;        e.printStackTrace();    &#125;    catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>}<br>而查看文件&#x2F;Users&#x2F;sschen&#x2F;Documents&#x2F;student.txt，其内保存的内容并不是可以容易阅读的内容：</p><p>aced 0005 7372 001f 636f 6d2e 7373 6368<br>656e 2e53 6572 6961 6c69 7a61 626c 652e<br>5374 7564 656e 74f1 5dbd a4a0 3472 4d02<br>0004 4400 0367 7061 4300 0373 6578 4900<br>0479 6561 724c 0004 6e61 6d65 7400 124c<br>6a61 7661 2f6c 616e 672f 5374 7269 6e67<br>3b78 7040 0ccc cccc cccc cd00 4d00 0000<br>1474 0003 546f 6d</p><h1 id="序列化的必要条件"><a href="#序列化的必要条件" class="headerlink" title="序列化的必要条件"></a>序列化的必要条件</h1><p>1、必须是同包，同名。<br>2、serialVersionUID必须一致。有时候两个类的属性稍微不一致的时候，可以通过将此属性写死值，实现序列化和反序列化。</p><h1 id="序列化高级，使用情境分析"><a href="#序列化高级，使用情境分析" class="headerlink" title="序列化高级，使用情境分析"></a>序列化高级，使用情境分析</h1><ol><li>序列化ID问题<br>情境：两个客户端 A 和 B 试图通过网络传递对象数据，A 端将对象 C 序列化为二进制数据再传给 B，B 反序列化得到 C。<br>问题：C 对象的全类路径假设为 com.inout.Test，在 A 和 B 端都有这么一个类文件，功能代码完全一致。也都实现了 Serializable 接口，但是反序列化时总是提示不成功。<br>解决：虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID &#x3D; 1L）。下面的代码中，虽然两个类的功能代码完全一致，但是序列化 ID 不同，他们无法相互序列化和反序列化。</li></ol><p>简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。<br>当实现java.io.Serializable接口的实体（类）没有显式地定义一个名为serialVersionUID，类型为long的变量时，Java序列化机制会根据编译的class自动生成一个serialVersionUID作序列化版本比较用，这种情况下，只有同一次编译生成的class才会生成相同的serialVersionUID 。</p><p>如果我们不希望通过编译来强制划分软件版本，即实现序列化接口的实体能够兼容先前版本，未作更改的类，就需要显式地定义一个名为serialVersionUID，类型为long的变量，不修改这个变量值的序列化实体都可以相互进行串行化和反串行化。<br>相同功能代码不同序列化 ID 的类对比，代码如下：</p><p>public class SerialVersionIDA implements Serializable {<br>    private static final long serialVersionUID&#x3D;1L;</p><pre><code>private String name; public String getName() &#123;    return name;&#125; public void setName(String name) &#123;    this.name = name;&#125;public SerialVersionIDA() &#123;&#125;public SerialVersionIDA(String name) &#123;    this.name = name;&#125;</code></pre><p>}<br>public class SerialVersionIDA implements Serializable {<br>    private static final long serialVersionUID&#x3D;2L;</p><pre><code>private String name; public String getName() &#123;    return name;&#125; public void setName(String name) &#123;    this.name = name;&#125;public SerialVersionIDA() &#123;&#125;public SerialVersionIDA(String name) &#123;    this.name = name;&#125;</code></pre><p>}<br>使用serialVersionUID为1L的类进行序列化，而使用serialVersionUID为2L的类进行反序列化，会提示异常，异常内容为：</p><p>java.io.InvalidClassException: com.sschen.Serializable.SerialVersionIDA; local class incompatible: stream classdesc serialVersionUID &#x3D; 2, local class serialVersionUID &#x3D; 1<br>    at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:616)<br>    at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1630)<br>    at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1521)<br>    at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1781)<br>    at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1353)<br>    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:373)<br>    at com.sschen.Serializable.SerialVersionTest.main(SerialVersionTest.java:30)<br>    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br>    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>    at java.lang.reflect.Method.invoke(Method.java:498)<br>    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)<br>序列化 ID 在 Eclipse 下提供了两种生成策略，一个是固定的 1L，一个是随机生成一个不重复的 long 类型数据（实际上是使用 JDK 工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的 1L 就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化 ID 有什么作用呢，有些时候，通过改变序列化 ID 可以用来限制某些用户的使用。</p><p>特性使用案例<br>读者应该听过 Façade 模式，它是为应用程序提供统一的访问接口，案例程序中的 Client 客户端使用了该模式，案例程序结构图下图所示。</p><p>Client 端通过 Façade Object 才可以与业务逻辑对象进行交互。而客户端的 Façade Object 不能直接由 Client 生成，而是需要 Server 端生成，然后序列化后通过网络将二进制对象数据传给 Client，Client 负责反序列化得到 Façade 对象。该模式可以使得 Client 端程序的使用需要服务器端的许可，同时 Client 端和服务器端的 Façade Object 类需要保持一致。当服务器端想要进行版本更新时，只要将服务器端的 Façade Object 类的序列化 ID 再次生成，当 Client 端反序列化 Façade Object 就会失败，也就是强制 Client 端从服务器端获取最新程序。</p><ol start="2"><li><p>静态变量序列化<br>public class SerialStaticTest implements Serializable {</p><p> private static final long serialVersionUID &#x3D; 1L;</p><p> public static int staticVar &#x3D; 5;</p><p> public static void main(String[] args) {<br> try {<br>     File file &#x3D; new File(“&#x2F;Users&#x2F;sschen&#x2F;Documents&#x2F;student.txt”);<br>     try {<br>         file.createNewFile();<br>     }<br>     catch(IOException e) {<br>         e.printStackTrace();<br>     }<br>     &#x2F;&#x2F;初始时staticVar为5<br>     ObjectOutputStream out &#x3D; new ObjectOutputStream(<br>             new FileOutputStream(file));<br>     out.writeObject(new SerialStaticTest());<br>     out.close();<br><br>     &#x2F;&#x2F;序列化后修改为10<br>     SerialStaticTest.staticVar &#x3D; 10;<br><br>     ObjectInputStream oin &#x3D; new ObjectInputStream(new FileInputStream(file));<br>     SerialStaticTest t &#x3D; (SerialStaticTest) oin.readObject();<br>     oin.close();<br><br>     &#x2F;&#x2F;再读取，通过t.staticVar打印新的值<br>     System.out.println(t.staticVar);<br><br> } catch (FileNotFoundException e) {<br>     e.printStackTrace();<br> } catch (IOException e) {<br>     e.printStackTrace();<br> } catch (ClassNotFoundException e) {<br>     e.printStackTrace();<br> }<br> }</p></li></ol><p>}<br>上面代码中的 main 方法，将对象序列化保存到文件后，修改静态变量的数值，再将序列化对象读取出来，然后通过读取出来的对象获得静态变量的数值并打印出来。依照代码，这个 System.out.println(t.staticVar) 语句输出的是 10 还是 5 呢？<br>最后的输出是 10，对于无法理解的读者认为，打印的 staticVar 是从读取的对象里获得的，应该是保存时的状态才对。之所以打印 10 的原因在于序列化时，并不保存静态变量，这其实比较容易理解，序列化保存的是对象的状态，静态变量属于类的状态，因此 序列化并不保存静态变量。</p><ol start="3"><li>父类的序列化与 Transient 关键字<br>情境：一个子类实现了 Serializable 接口，它的父类都没有实现 Serializable 接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。<br>解决：要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就 需要有默认的无参的构造函数。在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。<br>Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。<br>特性使用案例<br>我们熟悉使用 Transient 关键字可以使得字段不被序列化，那么还有别的方法吗？根据父类对象序列化的规则，我们可以将不需要被序列化的字段抽取出来放到父类中，子类实现 Serializable 接口，父类不实现，根据父类序列化规则，父类的字段数据将不被序列化，形成类图如图 2 所示。</li></ol><p>上图中可以看出，attr1、attr2、attr3、attr5 都不会被序列化，放在父类中的好处在于当有另外一个 Child 类时，attr1、attr2、attr3 依然不会被序列化，不用重复抒写 transient，代码简洁。</p><ol start="4"><li>对敏感字段加密<br>情境：服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。<br>解决：在序列化过程中，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感字段的加密工作，下面的代码展示了这个过程。</li></ol><p>public class SerialPwdTest implements Serializable {<br>    private static final long serialVersionUID &#x3D; 1L;</p><pre><code>private String password = &quot;pass&quot;; public String getPassword() &#123;    return password;&#125; public void setPassword(String password) &#123;    this.password = password;&#125; private void writeObject(ObjectOutputStream out) &#123;    try &#123;        ObjectOutputStream.PutField putFields = out.putFields();        System.out.println(&quot;原密码:&quot; + password);        password = &quot;encryption&quot;;//模拟加密        putFields.put(&quot;password&quot;, password);        System.out.println(&quot;加密后的密码&quot; + password);        out.writeFields();    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125; private void readObject(ObjectInputStream in) &#123;    try &#123;        ObjectInputStream.GetField readFields = in.readFields();        Object object = readFields.get(&quot;password&quot;, &quot;&quot;);        System.out.println(&quot;要解密的字符串:&quot; + object.toString());        password = &quot;pass&quot;;//模拟解密,需要获得本地的密钥    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125; catch (ClassNotFoundException e) &#123;        e.printStackTrace();    &#125; &#125; public static void main(String[] args) &#123;    File file = new File(&quot;/Users/sschen/Documents/student.txt&quot;);    try &#123;        file.createNewFile();    &#125;    catch(IOException e) &#123;        e.printStackTrace();    &#125;    try &#123;        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file));        out.writeObject(new SerialPwdTest());        out.close();         ObjectInputStream oin = new ObjectInputStream(new FileInputStream(file));        SerialPwdTest t = (SerialPwdTest) oin.readObject();        System.out.println(&quot;解密后的字符串:&quot; + t.getPassword());        oin.close();    &#125; catch (FileNotFoundException e) &#123;        e.printStackTrace();    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125; catch (ClassNotFoundException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>}<br>SerialPwdTest的 writeObject 方法中，对密码进行了加密，在加密后进行序列化保存到文件中，在 readObject 中则在读取到密码后，对 password 进行解密，只有拥有密钥的客户端，才可以正确的解析出密码，确保了数据的安全。上面代码的执行结果为：</p><p>原密码:pass<br>加密后的密码encryption<br>要解密的字符串:encryption<br>解密后的字符串:pass<br>特性使用案例<br>RMI 技术是完全基于 Java 序列化技术的，服务器端接口调用所需要的参数对象来至于客户端，它们通过网络相互传输。这就涉及 RMI 的安全传输的问题。一些敏感的字段，如用户名密码（用户登录时需要对密码进行传输），我们希望对其进行加密，这时，就可以采用本节介绍的方法在客户端对密码进行加密，服务器端进行解密，确保数据传输的安全性。</p><ol start="5"><li>序列化存储规则<br>情境：问题代码如清单 4 所示。<br>清单 4. 存储规则问题代码</li></ol><p>public class SerialSaveTest implements Serializable {<br>    public static void main(String[] args) {<br>        File file &#x3D; new File(“&#x2F;Users&#x2F;sschen&#x2F;Documents&#x2F;student.txt”);<br>        try {<br>            file.createNewFile();<br>        }<br>        catch(IOException e) {<br>            e.printStackTrace();<br>        }<br>        try {<br>            ObjectOutputStream out &#x3D; new ObjectOutputStream(new FileOutputStream(file));<br>            SerialSaveTest test &#x3D; new SerialSaveTest();<br>            &#x2F;&#x2F;试图将对象两次写入文件<br>            out.writeObject(test);<br>            out.flush();<br>            System.out.println(file.length());<br>            out.writeObject(test);<br>            out.close();<br>            System.out.println(file.length());</p><pre><code>        ObjectInputStream oin = new ObjectInputStream(new FileInputStream(file));        //从文件依次读出两个文件        SerialSaveTest t1 = (SerialSaveTest) oin.readObject();        SerialSaveTest t2 = (SerialSaveTest) oin.readObject();        oin.close();         //判断两个引用是否指向同一个对象        System.out.println(t1 == t2);    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125; catch (ClassNotFoundException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>}<br>清单4中对同一对象两次写入文件，打印出写入一次对象后的存储大小和写入两次后的存储大小，然后从文件中反序列化出两个对象，比较这两个对象是否为同一对象。一般的思维是，两次写入对象，文件大小会变为两倍的大小，反序列化时，由于从文件读取，生成了两个对象，判断相等时应该是输入 false 才对，但是最后结果输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">59</span><br><span class="line">64</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>我们看到，第二次写入对象时文件只增加了 5 字节，并且两个对象是相等的，这是为什么呢？<br>解答：Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用，上面增加的 5 字节的存储空间就是新增引用和一些控制信息的空间。反序列化时，恢复引用关系，使得清单 3 中的 t1 和 t2 指向唯一的对象，二者相等，输出 true。该存储规则极大的节省了存储空间。<br>特性案例分析<br>查看清单 5 的代码。<br>清单 5. 案例代码</p><p>public class SerialSaveTest implements Serializable {<br>    private int id;</p><pre><code>public int getId() &#123;    return id;&#125; public void setId(int id) &#123;    this.id = id;&#125; public static void main(String[] args) &#123;    File file = new File(&quot;/Users/sschen/Documents/student.txt&quot;);    try &#123;        file.createNewFile();    &#125;    catch(IOException e) &#123;        e.printStackTrace();    &#125;    try &#123;        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file));        SerialSaveTest test = new SerialSaveTest();        test.setId(1);        //试图将对象两次写入文件        out.writeObject(test);        out.flush();        System.out.println(file.length());        test.setId(5);        out.writeObject(test);        out.close();        System.out.println(file.length());         ObjectInputStream oin = new ObjectInputStream(new FileInputStream(file));        //从文件依次读出两个文件        SerialSaveTest t1 = (SerialSaveTest) oin.readObject();        SerialSaveTest t2 = (SerialSaveTest) oin.readObject();        oin.close();         //判断两个引用是否指向同一个对象        System.out.println(t1 == t2);         System.out.println(t1.getId());        System.out.println(t2.getId());    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125; catch (ClassNotFoundException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>}<br>清单 4 的目的是希望将 test 对象两次保存到&#x2F;Users&#x2F;sschen&#x2F;Documents&#x2F;student.txt文件中，写入一次以后修改对象属性值再次保存第二次，然后从&#x2F;Users&#x2F;sschen&#x2F;Documents&#x2F;student.txt中再依次读出两个对象，输出这两个对象的 i 属性值。案例代码的目的原本是希望一次性传输对象修改前后的状态。<br>结果两个输出的都是 1， 原因就是第一次写入对象以后，第二次再试图写的时候，虚拟机根据引用关系知道已经有一个相同对象已经写入文件，因此只保存第二次写的引用，所以读取时，都是第一次保存的对象。读者在使用一个文件多次 writeObject 需要特别注意这个问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VPN技术原理</title>
      <link href="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/"/>
      <url>/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="分公司或个人与总部通信"><a href="#分公司或个人与总部通信" class="headerlink" title="分公司或个人与总部通信"></a>分公司或个人与总部通信</h1><h2 id="分支站点组网通信"><a href="#分支站点组网通信" class="headerlink" title="分支站点组网通信"></a>分支站点组网通信</h2><p>公网IP暴露，黑客可以尝试你的DNAT的端口号，不安全</p><p>分公司到总公司 site to site</p><p>1、物理专线（费用高，安全性好，服务质量好，维护费用）</p><p>2、IPsec VPN（经济）</p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654387244266.png"></p><p><strong>封装：</strong></p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654389768466.png"></p><p>1、封装数据包并发送到默认网关</p><table><thead><tr><th>SIP</th><th>DIP</th><th>Sport</th><th>Dport</th><th>Protocol</th><th>DATA</th></tr></thead><tbody><tr><td>172.172.10.10</td><td>172.172.3.100</td><td>50000</td><td>80</td><td>TCP</td><td>Http数据</td></tr></tbody></table><p>2、网关设置静态路由，凡是目的IP是XXX网段的数据包就发送到VPN设备（WOC-Branch）172.172.10.3</p><p><strong>加密</strong></p><p>进行加密，加密后的数据包</p><table><thead><tr><th>SIP</th><th>DIP</th><th>Sport</th><th>Dport</th><th>Protocol</th><th>DATA</th></tr></thead><tbody><tr><td>172.172.10.3</td><td>202.96.137.88</td><td>40000</td><td>4009（另一台VPN设备的端口号）</td><td>TCP</td><td>加密的原始数据</td></tr></tbody></table><p>3、VPN设备将重新封装的数据包发送给默认网关AC</p><p>网关进行SNAT，将私网SIP转换成公网IP</p><table><thead><tr><th>SIP</th><th>DIP</th><th>Sport</th><th>Dport</th><th>Protocol</th><th>DATA</th></tr></thead><tbody><tr><td>202.96.139.99</td><td>202.96.137.88</td><td>40000</td><td>4009</td><td>TCP</td><td>加密的原始数据</td></tr></tbody></table><p>4、通过互联网一跳一跳的转发到目的公网IP（AD设备）</p><p>进行DNAT，根据目的端口号</p><table><thead><tr><th>SIP</th><th>DIP</th><th>Sport</th><th>Dport</th><th>Protocol</th><th>DATA</th></tr></thead><tbody><tr><td>202.96.139.99</td><td>172.17.2.200</td><td>40000</td><td>4009</td><td>TCP</td><td>加密的原始数据</td></tr></tbody></table><p>5、根据局域网内不同网段设备通信原则，将该数据包发送到VPN设备上，解密</p><table><thead><tr><th>SIP</th><th>DIP</th><th>Sport</th><th>Dport</th><th>Protocol</th><th>DATA</th></tr></thead><tbody><tr><td>172.172.10.10</td><td>172.172.3.100</td><td>50000</td><td>80</td><td>TCP</td><td>Http数据</td></tr></tbody></table><p>根据DIP和局域网内不同网段通信规则，将数据包转发到目的服务器</p><p>MPLS VPN</p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654403363886.png"></p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654403725247.png"></p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654403966034.png"></p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654404427474.png"></p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654404855543.png"></p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654405167428.png"></p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654405338440.png"></p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654405458526.png"></p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654405535956.png"></p><p>可以先IPsec进行数据加密，再用MPLS VPN运输</p><h2 id="移动办公通信"><a href="#移动办公通信" class="headerlink" title="移动办公通信"></a>移动办公通信</h2><p>SSL VPN</p><ul><li>用户与站点之间的VPN技术</li><li>PC，手机等移动通信的应用程序（浏览器等）支持SSL协议，不支持IPsec协议</li><li>SSL（Secure Sockets Layer）安全套接层，只要任务是提供私密性，信息完整性，身份认证，为数据通信提高安全支持</li><li>明文加密成密文</li></ul><p><strong>对称加密算法</strong><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654407971867.png"></p><p>有安全隐患，用一把秘钥，传输过程中有泄露风险，一旦泄露就GG</p><p>常见的对称加密算法</p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654408117402.png"></p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654408213224.png"></p><p>和N个主机通信就要管理N个钥匙，秘钥管理困难</p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654408320900.png"></p><p>优点：只有一把钥匙，加解密速度快，适合加密数据量比较大的场景</p><p><strong>非对称加密算法（公钥加密算法）</strong></p><p>别的主机想和我通信时就要先用大家都知道的公钥加密，发给我，我再用只有我自己知道的私钥解密</p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654408595516.png"></p><p>常见的非对称加密算法</p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654408791884.png"></p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654408850751.png"></p><p>如何验证公钥的真实性和合法性</p><p>可能有黑客把公钥换成自己的，从而拦截数据包进行解密</p><p>解决办法：</p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654424488435.png"></p><p>为了证明公钥的合法性，真实性</p><p>CA用私钥加密了数字证书，浏览器集成了公钥，只有是CA公布的数字证书才能被浏览器解密</p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654424949486.png"></p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654425184020.png"></p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654425239871.png"></p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654428619826.png"></p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654425893618.png"></p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654425965151.png"></p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654428736059.png"></p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654426097956.png"></p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654426127394.png"></p><p><img src="/2022/06/05/VPN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1654428522800.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络技术基础原理-互联网通信</title>
      <link href="/2022/06/03/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86-%E4%BA%92%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1/"/>
      <url>/2022/06/03/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86-%E4%BA%92%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="互联网通信"><a href="#互联网通信" class="headerlink" title="互联网通信"></a>互联网通信</h1><p>域名解析：将域名解析为IP地址</p><p>DNS域名解析服务器（来自运营商，如电信，联通等）</p><p>浏览器输入<a href="http://www.sanfor.com,回车/">www.sanfor.com，回车</a></p><p>PC向DNS发送数据包询问sanfor的IP地址</p><p>DNS服务器本质是一个数据库，存储域名和IP地址的相互映射（一个域名可能对应多个IP地址）</p><p>两种记录</p><ul><li><p>A记录（Address）</p></li><li><p>NS记录（Name Server）指向另一个域名服务器（AD）</p><p>如果查到的是NS记录（NS记录优先级高于A记录）</p><p>首选DNS服务器就发数据包去访问AD这台服务器，AD根据首选DNS 的运行商类型，返回对应运营商的IP地址(绝大部分时候），从而避免跨运营商访问，提升用户体验</p><p>特殊情况时智能选路，返回效果较好的线路</p></li></ul><p>DNS一台不可能存储所有的数据</p><p>DNS是分布式的</p><ul><li>本地DNS服务器（顺序下询问）</li><li>根域名服务器</li><li>顶级域名服务器</li><li>权威域名服务器</li></ul><p>PC先询问LDNS（首选DNS服务器）查到了，返回，（递归查询）</p><p>没有查到，代理PC去询问其他DNS服务器（迭代查询）</p><h2 id="内部PC访问互联网"><a href="#内部PC访问互联网" class="headerlink" title="内部PC访问互联网"></a>内部PC访问互联网</h2><p><img src="/2022/06/03/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86-%E4%BA%92%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1/1654311167491.png"></p><p>私网IP没办法直接访问互联网</p><p>有去无回，收不到应答包，互联网中找不到私网IP</p><p>NAT（网络地址转换）</p><p>SNAT（源网络地址转换）</p><p>原理：修改数据包中的源IP地址</p><p>将私网IP转换成路由器出口的公网IP</p><p>作用：局域网访问互联网，实现局域网共享上网</p><p>公网IP代理PC去访问互联网</p><p>DNS解析后拿到目的IP地址，封装数据包</p><table><thead><tr><th>SIP</th><th>DIP</th><th>Spot</th><th>Dpot</th><th>Data</th></tr></thead><tbody><tr><td>192.168.1.10</td><td>200.200.91.33</td><td>8888</td><td>80</td><td>XX</td></tr></tbody></table><p>转发到网关，网关启用NAT</p><p>将源IP更改为网关的公网IP（NAT中的SNAT）源地址转换</p><table><thead><tr><th>SIP</th><th>DIP</th><th>Spot</th><th>Dpot</th><th>Data</th></tr></thead><tbody><tr><td>100.100.7.26</td><td>200.200.91.33</td><td>8888</td><td>80</td><td>XX</td></tr></tbody></table><p>并维护一张NAT映射缓存表</p><table><thead><tr><th>IP（原）</th><th>IP（后来的）</th><th>Port（原）</th><th>Port（后来的）</th></tr></thead><tbody><tr><td>192.168.1.10</td><td>100.100.7.26</td><td>8888</td><td></td></tr><tr><td>192.168.1.20</td><td>100.100.7.26</td><td>9999</td><td></td></tr></tbody></table><p>NAT映射表</p><ul><li><p>静态：1：1，一对一映射关系，不支持同时映射多台PC。</p><p>一个公网IP对应一个PC端私网IP</p></li><li><p>动态：m：n，多对多的关系，动态分配。</p><p>几个公网IP，当代理完一个私网IP，再代理下一个（本质上还是一个公网IP只能同时代理一个私网IP）</p></li><li><p>NAPT（网络端口地址转换）：增NAT映射表增加端口号字段，</p><p>通过端口号（源）和IP地址唯一识别映射关系</p><p>用来区分不同PC的IP地址</p></li></ul><p>如果端口号重复就增加一个端口号</p><p><img src="/2022/06/03/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86-%E4%BA%92%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1/1654343727904.png"></p><p>网关通过公网IP发送给目的IP，目的主机回复应答包</p><table><thead><tr><th>SIP</th><th>DIP</th><th>Spot</th><th>Dpot</th><th>Data</th></tr></thead><tbody><tr><td>200.200.91.33</td><td>100.100.7.26</td><td>80</td><td>8888</td><td>XX</td></tr></tbody></table><p>NAT查询映射缓存表，将PC的原IP再改回来，从而发送到目的PC</p><table><thead><tr><th>SIP</th><th>DIP</th><th>Spot</th><th>Dpot</th><th>Data</th></tr></thead><tbody><tr><td>200.200.91.33</td><td>192.168.1.10</td><td>80</td><td>8888</td><td>XX</td></tr></tbody></table><h2 id="外部PC访问内部服务器"><a href="#外部PC访问内部服务器" class="headerlink" title="外部PC访问内部服务器"></a>外部PC访问内部服务器</h2><p>DNAT：</p><p>原理：修改数据包中的目的IP地址</p><p>作用：将企业网中的服务器进行发布，用于互联网访问局域网</p><p>端口号与IP的映射关系，需要管理员手动配置</p><p>外来的数据包</p><table><thead><tr><th>SIP</th><th>DIP</th><th>Spot</th><th>Dpot</th><th>Data</th></tr></thead><tbody><tr><td>100.100.7.26</td><td><strong>200.200.91.33</strong></td><td>8888</td><td>443</td><td>XX</td></tr></tbody></table><p>到目的服务器接口（200.200.91.33）进入内网</p><p>根据目的端口号（Dpot）更改目的IP地址，目的端口号都是固定的，HTTPS 443等</p><table><thead><tr><th>SIP</th><th>DIP</th><th>Spot</th><th>Dpot</th><th>Data</th></tr></thead><tbody><tr><td>100.100.7.26</td><td><strong>192.168.2.10</strong></td><td>8888</td><td>443</td><td>XX</td></tr></tbody></table><p>HTTPS回复应答包</p><table><thead><tr><th>SIP</th><th>DIP</th><th>Spot</th><th>Dpot</th><th>Data</th></tr></thead><tbody><tr><td>192.168.2.10</td><td>100.100.7.26</td><td>443</td><td>8888</td><td>XX</td></tr></tbody></table><p>到网关处将私网IP更改为公网IP（必须更改，要不一来一回的数据包对不上，不会接收）</p><table><thead><tr><th>SIP</th><th>DIP</th><th>Spot</th><th>Dpot</th><th>Data</th></tr></thead><tbody><tr><td>200.200.91.33</td><td>100.100.7.26</td><td>443</td><td>8888</td><td>XX</td></tr></tbody></table><p>IPV6</p><p>公网地址不够用</p><p>IPV4（32位）</p><p>Internet Protocol version 4，IPV4，互联网通信协议第四版</p><p>地址枯竭</p><p>互联网用户急剧增长</p><p>移动设备，终端的快速增长</p><p>2019年11月宣布所有IPV4地址分配完毕</p><p>地域分配不均，美国5%的人口占据60%地址资源，亚洲15%</p><p>应对枯竭的技术：</p><p>DHCP（没用了）</p><p>NAT</p><p>IPV6（128位）</p><p>目的：替代现行版本的IPV4</p><p>优势：</p><p>地址空间更大，地址长度128位，地址空间增大2的96次方倍</p><p>简化报文头部格式：字段只有8个，加快报文转发，传输速度更快</p><p>集成IPsec安全协议，为所有应用程序提供报文的身份验证和加密功能，安全性更高</p><p><img src="/2022/06/03/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86-%E4%BA%92%E8%81%94%E7%BD%91%E9%80%9A%E4%BF%A1/1654352645029.png"></p><p>天窗问题可以采用AD翻译网关，将IPV4和IPV6互译</p><p>常见的网络设备部署模式</p><p>路由模式部署</p><p>路由器不同接口连接不同广播域（网段）</p><p>优势：支持的网络能最多最全</p><p>缺陷：对客户网络环境改变较大，出现新的网段等，网络更换会断网</p><p>网桥模式部署：</p><p>不需要进行IP、路由等改造，对客户网络环境影响较小</p><p>设备损坏影响较小</p><p>功能不全</p><p>单臂模式部署</p><p>VPN设备，网络代理等</p><p>优点：影响较小</p><p>旁路模式部署</p><p>放置于网络主干道的旁边</p><p>监听上网流量，上网行为等</p><p>将上网的接口，镜像一份发到监听设备中</p><p>不在网络主干道，对网络没有影响。但是功能</p><p>最小，只能监听。支持功能最少</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络技术基础原理-三层通信</title>
      <link href="/2022/06/02/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86-%E4%B8%89%E5%B1%82%E9%80%9A%E4%BF%A1/"/>
      <url>/2022/06/02/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86-%E4%B8%89%E5%B1%82%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="局域网不同网段通信"><a href="#局域网不同网段通信" class="headerlink" title="局域网不同网段通信"></a>局域网不同网段通信</h1><h3 id="不划分网段引起的问题："><a href="#不划分网段引起的问题：" class="headerlink" title="不划分网段引起的问题："></a>不划分网段引起的问题：</h3><ul><li>广播流量太多，占用网络带宽和设备资源（主要是交换机）</li><li>管理复杂，不利于发现问题，排除故障</li><li>不利于安全风险的隔离，安全问题影响范围大，如ARP欺骗等</li></ul><h3 id="如何划分网段"><a href="#如何划分网段" class="headerlink" title="如何划分网段"></a>如何划分网段</h3><p><strong>IP地址</strong>如：192.168.1.10&#x2F;255.255.255.0</p><p><strong>网络号（网络地址）</strong></p><ul><li>​    <em>网络号相同即在同一个网段</em></li><li>​    网络号：192.168.1</li><li>​    子网掩码：255.255.255.0(简写为：&#x2F;24)即前24位都为1 ，其他位0</li><li>​    如何判断网络号：IP地址与子网掩码进行二进制与运算</li></ul><p><strong>主机号（主机地址）</strong></p><p>.10</p><p><img src="/2022/06/02/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86-%E4%B8%89%E5%B1%82%E9%80%9A%E4%BF%A1/1654159947017.png" alt="1654159947017"></p><p>第一步：</p><p>判断在不在同一个网段，（通过IP地址和子网掩码与运算）看网络号是否相同</p><p>第二步：</p><p>不在同一网段，PC1则查找自身的默认网关</p><p>第三步：</p><p>查找网关MAC：同网段通讯</p><p>​    1、查找自己的ARP表</p><p>​    2、查不到，发送ARP广播包</p><p>​    3、收到网关的应答包，更新MAC地址</p><p>第四步：</p><p>PC1发送封装数据包到网关（路由器）</p><table><thead><tr><th>SMAC</th><th>DMAC</th><th>SIP</th><th>DIP</th><th>Data</th></tr></thead><tbody><tr><td>AA</td><td>BB默认网关</td><td>192.168.1.10</td><td>192.168.4.10</td><td>XXX</td></tr></tbody></table><p>第五步：</p><p>路由器网关收到数据包后拆掉二层封装MAC，（因为交换机根据MAC转发，三层的路由器根据IP地址转发）</p><p>路由：根据目的IP查找路由表</p><ul><li><p>直连路由</p><p>​     路由器接口所连接子网的路由（如R1的1.1和2.1）</p><p>​    特点：路由根据路由器接口IP配置，自动生成</p></li><li><p>静态路由</p><p>​    手工配置的路由</p><p>​    适用于网络规模不大，拓扑结构固定</p><p>​    优点配置简单，不占用网络、系统资源</p><p>​    缺陷需要网络管理员手工逐条配置，不能自动对网络状态变化做出调整</p></li><li><p>动态路由</p><p>​    适用于网络规模大，网络拓扑复杂</p><p>​    常见路由协议：RIP、OSPF</p><p>​    优点：通过路由信息交换生成并维护路由表，简化管理员维护工作，当网络结构发生变化时，可以自动做出调整，优化路由表</p><p>​    缺陷：需要占用路由器资源（CPU，内存）和网络带宽资源</p></li><li><p>默认路由</p><p>​    原理：IP报文中的目的地址找不到存在的其他路由时，路由器会默认的选择的路由</p><p>​    一种特殊的静态路由，配置，IP地址和子网掩码改成特殊的0.0.0.0和0.0.0.0.</p><p>​    如果没有默认路由，且报文目的IP不在路由表中，则数据包丢弃，返回源ICMP报文指出目的不可达</p></li><li><p>路由优先级</p><p>​    直连路由优先级最高</p><p>​    人工设置的路由优先级高于自动学习的</p></li></ul><p>进行路由选择，选择下一跳地址</p><p>路由器之间也可能有交换机，</p><p>路由器重新封装数据包</p><table><thead><tr><th>SMAC</th><th>DMAC</th><th>SIP</th><th>DIP</th><th>Data</th></tr></thead><tbody><tr><td>CC出接口的MAC</td><td>DD下一跳的MAC</td><td>192.168.1.10</td><td>192.168.4.10</td><td>XXX</td></tr></tbody></table><p>同理即可到达PC2</p><table><thead><tr><th>SMAC</th><th>DMAC</th><th>SIP</th><th>DIP</th><th>Data</th></tr></thead><tbody><tr><td>EE</td><td>FF</td><td>192.168.1.10</td><td>192.168.4.10</td><td>XXX</td></tr></tbody></table><table><thead><tr><th>SMAC</th><th>DMAC</th><th>SIP</th><th>DIP</th><th>Data</th></tr></thead><tbody><tr><td>GG</td><td>HH</td><td>192.168.1.10</td><td>192.168.4.10</td><td>XXX</td></tr></tbody></table><p>第六步：</p><p>目的主机PC2收到数据包后应答</p><table><thead><tr><th>SMAC</th><th>DMAC</th><th>SIP</th><th>DIP</th><th>Data</th></tr></thead><tbody><tr><td>HH</td><td>GG</td><td>192.168.4.10</td><td>192.168.1.10</td><td>XXX</td></tr></tbody></table><p>总结</p><p>源、目的IP地址不变</p><p>源、目的MAC地址每一跳都会改变</p><p>同网段和不同网段通信关系</p><p>任意的三层通信都是由一段一段的二层通信拼起来的</p><p>三层通信&#x3D;二层通信+路由选择</p><h3 id="三层单点故障"><a href="#三层单点故障" class="headerlink" title="三层单点故障"></a>三层单点故障</h3><p>网关设备单点故障影响，无法与外部网络通信</p><p>解决措施:</p><p>多网关：网关间IP地址冲突，主机频繁切换网路出口</p><p>VRRP：虚拟路由冗余协议</p><p><img src="/2022/06/02/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86-%E4%B8%89%E5%B1%82%E9%80%9A%E4%BF%A1/1654171199528.png"></p><p>原理：将多台路由器虚拟成一个虚拟路由器，配置虚拟路由器的IP地址为默认网关</p><p>虚拟路由器：</p><p>Master路由器（主）承担转发报文任务的物理路由</p><p>Backup路由器（备份）没有承担转发任务的物理路由</p><p>虚拟IP地址：虚拟路由器的IP地址</p><p>主备设备切换：</p><p>Master每秒发送Advertisement报文，通知备份设备他的状态</p><p>Backup设备超过三秒（Master Down定时器）没有收到通知报文，主动成为Master接管</p><p>​                        </p><p>广播域：</p><p>一个设备发送广播包，能收到这个广播包的所有的设备的集合就同属于一个广播域</p><p>网络中所有能收到同样广播消息的设备的集合</p><p>网段：</p><p>主机网络号相同的在同一网段，通过IP地址和子网掩码设定的</p><p>在同一广播域，但不在同一网段的两台设备不可以通信，必须需要三层设备（路由器）</p><p>为什么隔离广播域</p><ul><li>限制广播风暴，减少资源浪费</li><li>增强局域网安全性</li><li>方便简化网络管理</li></ul><p>如何隔离广播域</p><ul><li>广播包没有办法穿越三层设备（路由器）三层设备可以隔离广播域</li><li>VLAN虚拟局域网</li></ul><p>在同一网段，但不在同一广播域，不可以通信（除非更改IP地址）</p><p>配置时，一般一个广播域一个网段</p><p><img src="/2022/06/02/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86-%E4%B8%89%E5%B1%82%E9%80%9A%E4%BF%A1/1654177134908.png"></p><p>VLAN：虚拟局域网（交换机）实现广播域的隔离（路由器隔离性价比低）</p><p>Access口：打&#x2F;撕标签Tag</p><p>MAC地址表：</p><p>交换机的MAC地址表里有“VLAN tag标签”字段，交换机转发数据包的时候会自动匹配目的MAC和VLAN tag标签，确认转发接口</p><p>将几个接口设置为Access口，进交换机时打上同一标签（打在数据包上）</p><table><thead><tr><th>SMAC</th><th>DMAC</th><th>Tag</th><th>SIP</th><th>DIP</th><th>Data</th></tr></thead><tbody><tr><td>AA</td><td>BB</td><td>10</td><td>1.10</td><td>1.20</td><td>XXX</td></tr></tbody></table><p>出交换机时，撕去标签</p><p>标签不同，不会转发广播包，多个广播域，可在交换机之间架设多根线路，设置为不同的Access口，因为，一个数据包，只可能从一根线路上转发（匹配上Tag标签的）所以不会形成环路</p><p>但是交换机直接连接的线路太多，占用接口资源</p><p>TRUNK口，架设在两台交换机之间，不打标签也不撕标签，不对标签做任何操作</p><p>可以设置允许那些VLAN通过</p><p>不同网段通信时：</p><p><img src="/2022/06/02/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86-%E4%B8%89%E5%B1%82%E9%80%9A%E4%BF%A1/1654215018003.png"></p><p>缺陷：网段过多时，路由器接口资源将大量被占用，</p><p>采用 单臂路由：（虚拟化）</p><p><img src="/2022/06/02/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86-%E4%B8%89%E5%B1%82%E9%80%9A%E4%BF%A1/1654215563617.png"></p><p>路由器只需要一个物理接口</p><p>把一个物理口虚拟成多个虚拟子接口（根据厂家，一般几十个），每个子接口封装到不同的VLAN，配置IP地址，做为每个网段的网关</p><p>对端交换机配置为TRUNK口</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络技术基础原理-二层通信</title>
      <link href="/2022/05/28/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86-%E4%BA%8C%E5%B1%82%E9%80%9A%E4%BF%A1/"/>
      <url>/2022/05/28/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86-%E4%BA%8C%E5%B1%82%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="局域网同网段通信"><a href="#局域网同网段通信" class="headerlink" title="局域网同网段通信"></a>局域网同网段通信</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>OSI七层模型，保证网络中各种五花八门的设备，如何保证他们步调一致</p><p>定义标准，使得不同的设备能够互联通信，后期开发运维更加简便，</p><p><strong>应用层：</strong></p><p>​    为用户提供网络服务的接口，也直接提供网络服务，同时定义应用软件如何通讯的标准</p><p>​        不同应用程序通信标准不同</p><p>​        应用层协议：定义不同的应用通信标准（QQ和浏览器协议不同）</p><p>​            网站：HTTP&#x2F;HTTPS</p><p>​            远程登录：Telnet</p><p>​            邮件：SMTP、POP3</p><p>​            文件传输：FTP</p><p>​            域名解析：DNS</p><p>​            动态地址配置：DHCP</p><p>​    应用程序输出数据，快递发件人输出货物</p><p><strong>表示层</strong></p><p>​    提供数据格式转换服务</p><p>​        数据的加解密，如访问淘宝账号密码加密</p><p>​        数据编码压缩，如：IP摄像机（编码压缩协议：H.254）视频会议（H.523）降低对带宽的需求，以及存储要求</p><p>​    快速打包、装袋、装箱，保证货物隐私，安全</p><p><strong>会话层</strong></p><p>​    建立和维护应用程序访问验证和会话</p><p>​        服务（应用）验证登录</p><p>​        断点续传：使会话在通信失效后在断点回复通信</p><p>​    填写收件人信息，并和收件人确认</p><p><strong>运输层</strong></p><p>​    提供、保证报文在端到端的传输</p><p>​        传输协议：</p><p>​            TCP：可靠传输控制协议</p><p>​                关键词：三次握手建立连接，可靠，数据丢了重新发</p><p>​                应用场景：传输效率要求相对低，但对准确性要求相对较高的场景</p><p>​                    电子邮件</p><p>​                    文件传输</p><p>​                    登录验证</p><p>​                    网页访问</p><p>​            UDP：用户数据报协议</p><p>​                关键词：没有建立连接，不可靠，尽力了，数据丢了就丢了</p><p>​                应用场景：效率要求相对高，对准确性要求较低的场景</p><p>​                    视频会议、直播</p><p>​                    语音电话</p><p>​                    多人动作类游戏 </p><p>端口号</p><p>​    端口号的作用是：区分同一台设备上的不同应用程序（服务）</p><p>​    端口号的范围：0-65535</p><p>​    目的端口：</p><p>​            区分服务端不同应用程序（服务）</p><p>​            常见的端口号是规定好的</p><p>​                范围0-1024</p><p>​                FTP 21</p><p>​                SMTP 25</p><p>​                HTTPS 443</p><p>​                HTTP 80</p><p>​                DNS 53</p><p>​    源端口：</p><p>​            区分客户端的应用程序、会话</p><p>​            动态随机的，范围是1025-65535</p><p>​            用户可以自定义用途            </p><p>​    快递公司提供不同特点的快递服务，保证收寄件人之间的物流传输</p><p><strong>网络层</strong></p><p>​    进行路由选择，分组转发数据</p><p>​        根据IP地址进行路由</p><p>​        动态选路，每个路由结点选择下一跳结点</p><p>​        源ip和目的ip不会发生改变</p><p>​    选择快递运输路线</p><p><strong>数据链路层</strong></p><p>​    建立实体链路连接，通过MAC地址提供可靠的数据传输服务</p><p>​    快递员需要知道物流线路上每一个站点的门牌号：xx市XX区XX路XX号</p><p><strong>物理层</strong></p><p>​    提供原始比特流的传输的通路</p><p>​        电话线</p><p>​        网线</p><p>​        专线</p><p>选择合适的物流运输工具，物理媒介</p><h2 id="同网段通信"><a href="#同网段通信" class="headerlink" title="同网段通信"></a>同网段通信</h2><p><img src="/2022/05/28/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86-%E4%BA%8C%E5%B1%82%E9%80%9A%E4%BF%A1/I(O~YGHW@1IFR5LR%60)KK@WP.png"></p><p>源ip：192.168.1.10&#x2F;24        MAC：AAAAAAAAAAAA(12个简写为两个)</p><p>目的IP ：192.168.1.20&#x2F;24    MAC：BBBBBBBBBBBB</p><p><strong>PC1中：</strong></p><p>1、判断在不在同一个网段（根据IP地址）</p><ul><li>IP地址包括网络号主机号，网络号相同就在同一个网段</li><li>IP地址与子网掩码运算可以得到网络号（二进制与运算）</li><li>子网掩码与IP成对出现，就是用来指明IP地址哪些是网络号</li></ul><p>​    </p><p>2、PC1查自己的ARP表，根据目的IP查MAC地址</p><p>ARP：（地址解析协议）</p><ul><li>实现IP和MAC的映射，即询问目标自拍对应的MAC地址</li><li>ARP缓存表：动态缓存表可动态更新（存在内存里）（关机重启就没了）</li><li>寻址，寻找目的主机的MAC地址（2.5层协议）</li><li>查看ARP表：arp -a           删除ARP表：arp  -d</li></ul><table><thead><tr><th>IP地址</th><th>MAC地址</th><th>类型</th></tr></thead><tbody><tr><td>192.168.1.10&#x2F;24</td><td>##########</td><td>动态获取</td></tr></tbody></table><p><img src="/2022/05/28/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86-%E4%BA%8C%E5%B1%82%E9%80%9A%E4%BF%A1/arp.png"></p><p>3、（如果ARP表中未查询到）发送ARP广播包</p><p>广播包：目的MAC全是F（FFFF.FFFF.FFFF)，没有聊天内容，仅用来寻址</p><table><thead><tr><th>SMAC</th><th>DMAC</th><th>SIP</th><th>DIP</th><th>Data</th></tr></thead><tbody><tr><td>AA</td><td>FF</td><td>192.168.1.10&#x2F;24</td><td>192.168.1.20&#x2F;24</td><td>XXX（询问地址数据，非实际数据）</td></tr></tbody></table><p>4、跳交换机</p><p>5、PC2 收到ARP广播包</p><ul><li><p>是目的主机：</p><p>​    更新本地ARP缓存表</p><p>​    单播ARP应答包</p></li><li><p>不是目的主机：</p><p>​    丢弃ARP广播包</p></li></ul><p>6、PC2应答包（单播应答）</p><table><thead><tr><th>SMAC</th><th>DMAC</th><th>SIP</th><th>DIP</th><th>Data</th></tr></thead><tbody><tr><td>BB</td><td>AA</td><td>192.168.1.20&#x2F;24</td><td>192.168.1.10&#x2F;24</td><td>XXX（我的MAC地址是。。。）</td></tr></tbody></table><p>7、PC1更新ARP表</p><p>新增目的主机IP、MAC地址条目</p><p>条目类型：动态</p><p>8、PC1封装数据包发送（单播）</p><table><thead><tr><th>SMAC</th><th>DMAC</th><th>SIP</th><th>DIP</th><th>Data</th></tr></thead><tbody><tr><td>AA</td><td>BB</td><td>192.168.1.10&#x2F;24</td><td>192.168.1.20&#x2F;24</td><td>XXX（实际数据）</td></tr></tbody></table><p>ICMP ：ping 包</p><p><strong>ARP缺陷</strong></p><p>1、请求和应答不需要配对，可以主动向任何主机发送虚假的ARP应答（主动欺骗）</p><p>2、没有校验机制（收到ARP应答包后，不检验IP、ICMP就动态更新ARP缓存表）</p><p>3、ARP应答包可以做成广播包，同一个广播域的所有主机的ARP表都会被更改</p><p>风险：</p><p><strong>ARP欺骗（伪装）</strong></p><table><thead><tr><th>SMAC</th><th>DMAC</th><th>SIP</th><th>DIP</th><th>Data</th></tr></thead><tbody><tr><td>CC</td><td>AA</td><td>1.20</td><td>1.10</td><td>伪装者</td></tr><tr><td>BB</td><td>AA</td><td>1.20</td><td>1.10</td><td>实际目的者</td></tr></tbody></table><p>进阶版：广播欺骗或者直接伪装成网关，接收所有访问互联网的主机的数据包</p><p>ARP欺骗的影响：</p><p>网络监听，信息拦截，信息的篡改</p><p><strong>防范措施</strong></p><p>1、将网关等重要MAC地址存到本局域网所有的主机中的ARP表中，设置为静态类型，（静态类型优先级比动态高）</p><p>2、在交换机上做IP和MAC地址的绑定（交换机接口检查，源IP和源MAC地址是不是 对应的，避免伪装）</p><p>3、VLAN虚拟局域网（减小ARP欺骗的范围）不能从本质上解决ARP欺骗，划分更小局域网，使得ARP欺骗只能局限于一个网段内</p><h3 id="2SW（二级交换机）"><a href="#2SW（二级交换机）" class="headerlink" title="2SW（二级交换机）"></a>2SW（二级交换机）</h3><p>1、学习：</p><p>地址表记录广播源MAC地址和交换机接口的映射关系</p><p>MAC地址表</p><ul><li>记录MAC地址和交换机接口的映射关系</li><li>一个接口可以对应多个MAC地址</li><li>动态缓存表（存在内存里）（关机重启就没了）</li></ul><table><thead><tr><th>接口号（端口号）</th><th>MAC地址</th></tr></thead><tbody><tr><td>F0&#x2F;1</td><td>AA</td></tr><tr><td>F0&#x2F;2</td><td>BB</td></tr></tbody></table><p>2、转发</p><p>广播转发（除了入接口外，向所有接口转发数据包）</p><p>查看数据包中的目的MAC地址</p><ul><li><p>如果是FFFF（广播转发）</p></li><li><p>如果有明确的MAC地址，查找MAC地址表找到对应接口，单播转发</p></li><li><p>没有找到对应接口，泛洪</p></li></ul><p>PC1中的ARP表有源MAC目的MAC，转换机中没有</p><p>1、重启，缓存表被清空</p><p>2、MAC地址表条目老化，老化时间（0~100万秒）</p><p>3、MAC地址表有数量上限（一般8000~10000条）被黑客攻击，地址表被填满无效条目</p><p><strong>泛洪</strong>：（除了入接口外，向所有接口转发数据包）数据包中包含实际数据</p><p>​    缺陷：1、所有人都收到 了包含实际数据的数据包，造成数据安全性有风险</p><p>​                2、流量风暴，包含实际数据，导致数据包变大，大量泛洪（复制转发）下，占用网络中带宽和交换机资源            </p><p>黑客可能根据交换机泛洪机制进行攻击，（泛洪攻击）</p><p>针对缺陷一，进行数据监听</p><p>针对缺陷二，让交换机一直处于大量泛洪的状态，导致正常业务无法执行甚至网络瘫痪    </p><p>​            伪造大量数据包，其中源MAC地址随机生成（局域网中不存在的MAC），大量的数据包丢给交换机，交换机不断学习，导致MAC地址表被不存在无效的MAC地址瞬间占满，局域网中所有的正常的数据包丢给交换机时，查不到对应的接口，都只能泛洪，黑客趁机监听，如果业务量很大，导致网络瘫痪</p><p><strong>防范措施：</strong></p><p>交换机的端口安全性（Port-Security)：人为设置每个端口最多可以学习MAC地址的数量</p><h3 id="二层单点故障："><a href="#二层单点故障：" class="headerlink" title="二层单点故障："></a>二层单点故障：</h3><p>连接两个交换机的接口或者网线发生故障（接口级故障）</p><p>1、在两个转换器直接增加网线形成冗余</p><p>​        <strong>问题</strong>：PC1发送一个广播包时，因为广播包的特点（除了入接口外，向所有接口转发数据包）就会在在两个交换机之间形成一条顺时针，一条逆时针的两条环路</p><p><img src="/2022/05/28/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86-%E4%BA%8C%E5%B1%82%E9%80%9A%E4%BF%A1/rwe.png"></p><p>1、会产生广播风暴，占用带宽与交换机资源，影响正常业务，随着时间发展，广播越来越多，导致交换机宕机，网络瘫痪</p><p>2、交换机MAC地址表震荡，由于环路，MAC地址表中多个接口学习到的是同一个MAC地址，查表转发时造成不知道从哪一个接口转发</p><p><strong>解决措施</strong></p><p>STP生成树协议：将接口逻辑隔断，当现任接口发生故障，再开启此接口</p><p>交换机开启时，自动开启STP，不断发送STP数据包，检测此网络中是否存在环路</p><p>延伸：</p><p>交换机设备故障：交换机级别的冗余备份：堆叠</p><h3 id="链路聚合："><a href="#链路聚合：" class="headerlink" title="链路聚合："></a>链路聚合：</h3><p>增加交换机之间的带宽</p><p>1、更换高端交换机</p><p>2、企业网流量汇聚到核心层，核心层设备高速运转容易发生堵塞，在两台交换机之间增加网线，</p><p>​        将多个物理接口，捆绑成一个逻辑接口去使用，虚拟化，</p><p>​        达到带宽累加的效果，链路冗余，提高链路的可靠性，也可以解决二层单点故障，优于STP，提升带宽的同时，避免了STP复杂的计算</p><p>​        聚合后的链路可以实现负载分担</p><h3 id="如何给主机配置IP地址"><a href="#如何给主机配置IP地址" class="headerlink" title="如何给主机配置IP地址"></a>如何给主机配置IP地址</h3><p>1、手动配置<img src="/2022/05/28/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86-%E4%BA%8C%E5%B1%82%E9%80%9A%E4%BF%A1/123.png"></p><p>2、DHCP （Dynamic Host Configuration Protocol）</p><p>动态主机配置协议</p><p>功能：为客户端分配IP地址，使得用户机能够利用这个ip上网</p><p><em>是应用层协议</em></p><p>3、DHCP必要性</p><p>早期是为了解决IPv4 公网不够用的问题（动态分配，动态回收）</p><p>现在在企业网中的应用</p><ul><li>降低配置难度，减少配置错误，IP冲突</li><li>简化运维，降低运维成本投入</li><li>方便对所有终端ip的集中监控，管理</li></ul><p>4、DHCP原理</p><p>DHCP DISCOVER：广播包，寻找能为他提供IP的DHCP Server</p><p>DHCP OFFER</p><p>​        DHCP应答包，告诉客户端他可以提供的ip地址</p><p>​                IP地址</p><p>​                默认网关</p><p>​                DNS服务器地址</p><p>​                租期</p><p>​        DHCP Server为此客户端保留它提供的IP地址</p><p>DHCP RESQUEST    确认接收使用的IP</p><p>DHCP ACK    确认信息</p><p>5、DHCP风险</p><p>客户端通过先收到OFFER包获取IP</p><p>黑客也在网络中部署了DHCP服务</p><ul><li><p>DHCP欺骗    </p><p>伪造真正的DHCP服务器为客户端主机分配一个错误信息</p></li><li><p>DHCP欺骗的影响</p><p>分配相同的IP地址，造成地址冲突，无法上网</p><p>分配错误的网关信息，信息篡改，拦截，，泄漏</p><p>分配错误的DNS信息，钓鱼网站（登录，就控制你的电脑，给你的文件加密，支付比特币才会解密）</p></li><li><p>DHCP欺骗如何防御</p></li></ul><p>DHCP SNOPPING：</p><p>信任接口（主机与合法DHCP服务器的中继设备）：能转发OFFER和ACK包，连接正常的DHCP Server</p><p>非信任接口（所有中继设备）：不能够转发OFFER和ACK包，防止黑客伪装的DHCP发送OFFER包</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础</title>
      <link href="/2022/05/27/java%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/05/27/java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>java 中表示各种进制，前面要加上：</p><p>二进制：0B</p><p>八进制：0</p><p>十六进制0X</p><p>Byte,一个字节                                    float     4个字节</p><p>short，两个字节                                double   8个字节</p><p>int 4个字节                                        char 2个字节</p><p>Long，8个字节                                Boolean    一个字节</p><p>定义Long时报错<img src="/2022/05/27/java%E5%9F%BA%E7%A1%80/1653646714436.png"></p><p>默认是int类型的需要在末尾加上L<img src="/2022/05/27/java%E5%9F%BA%E7%A1%80/QQ%E5%9B%BE%E7%89%8720220527182115.png"></p><p>定义float时报错<img src="/2022/05/27/java%E5%9F%BA%E7%A1%80/QQ%E5%9B%BE%E7%89%8720220527182310.png"></p><p>默认是double类型的，需要在末尾加上F&#x2F;f<img src="/2022/05/27/java%E5%9F%BA%E7%A1%80/QQ%E5%9B%BE%E7%89%8720220527182456.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网基础（企业级）</title>
      <link href="/2022/05/26/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BC%81%E4%B8%9A%E7%BA%A7%EF%BC%89/"/>
      <url>/2022/05/26/%E8%AE%A1%E7%BD%91%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BC%81%E4%B8%9A%E7%BA%A7%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>光猫：将光纤中的光信号转化为网线中的电信号</p><p>ipv4地址稀缺</p><p>NET网络地址转换</p><p>路由器两类接口</p><p>蓝：WAN</p><p>黄：LAN</p><p>LAN局域网，WAN广域网，WLAN无线局域网</p><p>从运营商买的服务是：带宽服务，公网IP的使用权（一片区域中一个ip）</p><p>公网IP代理局域网，</p><p>家用二层交换机：交换机的转化速率更快，价格更低，千兆接口</p><p>比路由器好的原因：仅用作二层的转换，主要有硬件支持，路由器做三层的，主要由软件支持，路由器还支持其他软件功能，如VPN，NET等</p><p>路由器参数选择：</p><p>带宽：</p><p>1、与运营商匹配</p><p>2、考虑未来是否会拓展更大的数据量</p><p>端口规格：</p><p>1、多WAN口可以做备份以防某一运营商网络坏了</p><p>2、增加带宽</p><p>3、MTBF：两次故障间隔(越大越好)</p><p>防火墙参数选择：要看用户的应用场景</p><p>1、网络层吞吐量：类似于地铁，安检较快，较粗略，只检查五件套，目的IP地址，源IP地址，目的端口，源端口，协议</p><p>2、应用层吞吐量：类似于机场，安检较慢，较详细，检查数据包内的内容，杀毒(匹配病毒特征码)等</p><p>3、VPN等</p><p>企业组网：互联网-路由器-中心交换机-二层交换机（不同部门用不一样的，包括wifi）</p><p>企业组网，衡量网络性能指标</p><p>带宽(bps)：单位时间传输数据量</p><p>时延(ms)：数据从一端到另一端，毫秒</p><p>总时延&#x3D;<strong>发送时延</strong>+<strong>传播时延</strong>+处理时延+排队时延</p><p>抖动：最大时延-最小时延——网络稳定性</p><p>丢包：一个或多个数据包无法到达目的地—-稳定性</p><p>byte（一个数字或字母1b，汉字2b）</p><p>一个字节Byte &#x3D; 8个bit     所以100M宽带理论最大下载速度为12.5MB（运营商都是用bit）</p><p>并发连接数和内存有关（有上限）</p><p>新建连接数和CPU有关（达到最高就只能等待，等待别的用户释放）</p><p>并发用户数：交互（存在操作），在线，已注册用户</p><p>注册用户数50，其中在线用户数30，其中10个人在浏览，20个人在点击，他们20人就是并发用户数，因为他们交互了。</p><p>防范病毒和广告等</p><p>基础边界(防火墙，拦截来自互联网的)</p><p>端点防护(PC端，服务器端的杀毒软件EDR等，拦截来自U盘等外设的)</p><p>用户认证</p><p>用户权限</p><p>行为审计，泄密追踪，溯源（设备AC）</p><p>数据安全性，数据安全等级不同，服务器不能放在一起</p><p>措施：区域隔离，分级防护（对内业务区，DMZ区（对外业务发布区））</p><p>移动办公怎么接入内网</p><p>措施：VPN</p><p>多接入几家运营商，冗余，避免出现设备故障，新增设备AD，避免</p><p>跨运营商访问（进出站都可以），实现服务器的负载均衡</p><p><strong>业务初创阶段</strong></p><p><strong>业务增长阶段</strong></p><p><strong>业务扩张阶段</strong></p><p>提高服务器资源利用率（如选课系统，一个学期只用一次，但是一直部署在服务器上）</p><p>每个业务系统所支持的底层操作系统可能不同，例如Linux，WindowsServer，Unix</p><p>所以不能部署到同一台服务器上</p><p>或者如果多个业务系统部署在同一台服务器上时，如果其中一个系统崩溃，可能导致整个服务器崩溃，</p><p>解决措施：</p><p>虚拟化，在一台服务器上安装多个虚拟机，每个虚拟机单独安装操作系统</p><p>路由器，防火墙，AC，交换机，双链路，做冗余备份</p><p>两台交换机之间可以架设多跟线路，</p><p>1、做链路聚合，提升主干链路的带宽</p><p>2、避免单点故障，如某一根线坏了</p><p>研发部门采用桌面云（本质上利用了服务器的虚拟化）客户端只有一个显示器，和接收发送图像和指令的小盒子，主机相当于放在服务器上的虚拟机</p><p>目的：</p><p>1、保证数据的安全性，核心数据代码放在本地主机容易造成泄漏，如U盘拷贝等，以及</p><p>如果本地电脑硬盘损坏将导致核心数据丢失</p><p>本地的小盒子进行管控，只允许，数据考进去，不允许将数据考出来</p><p>2、简化运维，只需要远程维护虚拟机即可，如果发生故障，重新拉起一个虚拟机，数据已经备份好了</p><p>内联接入区：两个园区之间向运营商购买一根专线，将两个园区连接起来</p><p>外联接入区：不同省份的总子公司之间通过VPN相连</p><p>运维区：</p><p>堡垒机：收集所有的运维管理权限，进行统一管理，登录堡垒机后，每个人可以对哪几台服务器进行什么操作的权限，同时，每个运维操作都会被记录</p><p>日志审计：对于已对接的设备，将各种日志统一收集过来，进行统一的分类管理（运行，故障，告警日志）</p><p>防病毒服务器：从互联网更新病毒库（外网下载一份）。所有终端和服务器都通过防病毒服务器进行更新（通过内网从防病毒服务器下载）</p><p>数据库审计：记录任何人对数据库进行的各种操作</p><p>基线核查：必须安装某些软件，设置合法密码等基线操作，才允许</p><p>安全态势感知：收集整个网络的日志（安全日志）例如哪台设备受到攻击，什么攻击，攻击了几次</p><p><strong>稳态与敏态业务阶段</strong></p><p>稳态业务：用户数量基本稳定，数据量稳定，业务系统很少更新版本（采用私有云部署</p><p>敏态业务：用户数量，数据量，请求资源量均不可预知（很多互联网公司）采用公有云部署</p><p>背景：私有云安全性高，投资高，建设周期长，扩容流程复杂，</p><p>公有云按需收费，扩容灵活，用户投资低，但是信息安全和隔离很难得到有效保障</p><p>敏态业务随时间发展逐渐趋于稳定，可以回迁回来，到本地的私有云</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式详解（附代码）</title>
      <link href="/2022/05/18/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%99%84%E4%BB%A3%E7%A0%81%EF%BC%89/"/>
      <url>/2022/05/18/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%99%84%E4%BB%A3%E7%A0%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h1><p><img src="/2022/05/18/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%99%84%E4%BB%A3%E7%A0%81%EF%BC%89/f181c7251a5fc76b6480a3536a66e762.png"></p><h2 id="一、设计模式的分类"><a href="#一、设计模式的分类" class="headerlink" title="一、设计模式的分类"></a>一、设计模式的分类</h2><p>总体来说设计模式分为三大类：</p><p>创建型模式，共五种：</p><p>​    工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p>结构型模式，共七种：</p><p>​    适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p>行为型模式，共十一种：</p><p>​    策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><p>其实还有两类：并发型模式和线程池模式。</p><h2 id="二、设计模式的六大原则"><a href="#二、设计模式的六大原则" class="headerlink" title="二、设计模式的六大原则"></a>二、设计模式的六大原则</h2><h3 id="总原则：开闭原则（Open-Close-Principle）"><a href="#总原则：开闭原则（Open-Close-Principle）" class="headerlink" title="总原则：开闭原则（Open Close Principle）"></a>总原则：开闭原则（Open Close Principle）</h3><p>​    开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。</p><p>​    任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。</p><p>​    为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。 </p><h3 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a>1、单一职责原则</h3><p>​    不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。</p><h3 id="2、里氏替换原则（Liskov-Substitution-Principle）"><a href="#2、里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏替换原则（Liskov Substitution Principle）"></a>2、里氏替换原则（Liskov Substitution Principle）</h3><p>​    里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><p>​    里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。</p><pre><code> 所有引用基类对象的地方能够透明地使用其子类的对象</code></pre><p>​    里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类。但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。</p><p>​    例如有两个类，一个类为<code>BaseClass</code>，另一个是<code>SubClass</code>类，并且<code>SubClass</code>类是<code>BaseClass</code>类的子类，那么一个方法如果可以接受一个<code>BaseClass</code>类型的基类对象<code>base</code>的话，如：<code>method1(base)</code>，那么它必然可以接受一个<code>BaseClass</code>类型的子类对象<code>sub</code>，<code>method1(sub)</code>能够正常运行。反过来的代换不成立，如一个方法<code>method2</code>接受<code>BaseClass</code>类型的子类对象<code>sub</code>为参数：<code>method2(sub)</code>，那么一般而言不可以有<code>method2(base)</code>，除非是重载方法。</p><p>​    里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p><p>​    优点：可以检验继承使用的正确性，约束继承在使用上的泛滥。</p><h3 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a>3、依赖倒转原则（Dependence Inversion Principle）</h3><p>​    这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</p><pre><code> 依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。</code></pre><p>​    在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。</p><p>​    优点：通过抽象来搭建框架，建立类和类的关联，以减少类间的耦合性。而且以抽象搭建的系统要比以具体实现搭建的系统更加稳定，扩展性更高，同时也便于维护。</p><h3 id="4、接口隔离原则（Interface-Segregation-Principle）"><a href="#4、接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="4、接口隔离原则（Interface Segregation Principle）"></a>4、接口隔离原则（Interface Segregation Principle）</h3><p>​    这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</p><pre><code> 根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。</code></pre><p>​    在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护。接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。</p><p>​    优点：避免同一个接口里面包含不同类职责的方法，接口责任划分更加明确，符合高内聚低耦合的思想。</p><h3 id="5、迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#5、迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="5、迪米特法则（最少知道原则）（Demeter Principle）"></a>5、迪米特法则（最少知道原则）（Demeter Principle）</h3><p>​    就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</p><p>​    最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。</p><pre><code> 如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。</code></pre><p>​    迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。</p><p>​    在将迪米特法则运用到系统设计中时，要注意下面的几点：在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及。在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限。在类的设计上，只要有可能，一个类型应当设计成不变类。在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</p><p>​    优点：实践迪米特法则可以良好地降低类与类之间的耦合，减少类与类之间的关联程度，让类与类之间的协作更加直接。</p><h3 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a>6、合成复用原则（Composite Reuse Principle）</h3><p>​    原则是尽量首先使用合成&#x2F;聚合的方式，而不是使用继承。</p><p>​     合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用功能的目的。简而言之，复用时要尽量使用组合&#x2F;聚合关系（关联关系），少用继承。</p><p>​    在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合&#x2F;聚合关系或通过继承，但首先应该考虑使用组合&#x2F;聚合，组合&#x2F;聚合可以使系统更加灵活，降低类与类之间的耦合度。一个类的变化对其他类造成的影响相对较少，其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</p><p>优点：避免复用时滥用继承，合理使用组合关系，增加灵活性。</p><h3 id="8、-六大原则-学习心得"><a href="#8、-六大原则-学习心得" class="headerlink" title="8、 六大原则 - 学习心得"></a>8、 六大原则 - 学习心得</h3><p>​    六大原则中，开闭原则、里氏替换原则、依赖倒置原则联系比较紧密，后两者是实现开闭原则重要前提，使用中通过抽象化设计具有很好的可拓展性和可维护性。</p><p>​    知道最少原则 可以降低耦合，减少不必要的交互，主张设计接口和类要简单易使用，将复杂的逻辑封装并提供简单易用的接口。</p><p>​    单一职责原则 使项目中的类和方法根据职责细分，避免单个类负担过重。职责越多，被复用的可能性就越小或使用起来越麻烦。</p><p>​    接口分离原则 将功能复杂的接口细分成多个特定功能的接口，只做该做的事情，降低耦合，但是细化粒度不能太细，容易导致接口过多。单一职责原则强调单个类内部根据职责细分的设计，接口分离原则强调类之间的耦合，尽量建立最小的依赖关系。</p><h2 id="创建模式"><a href="#创建模式" class="headerlink" title="创建模式"></a>创建模式</h2><p>首先，简单工厂模式不属于23中涉及模式，</p><p>简单工厂一般分为：普通简单工厂、多方法简单工厂、静态方法简单工厂。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式模式分为三种：</p><h4 id="1、普通"><a href="#1、普通" class="headerlink" title="1、普通"></a>1、普通</h4><p>就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。</p><p>举例如下：（我们举一个发送邮件和短信的例子）</p><p>首先，创建二者的共同接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Sender &#123;  </span><br><span class="line">   public void Send();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，创建实现类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MailSender implements Sender &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void Send() &#123;   </span><br><span class="line">        System.out.println(&quot;this is mailsender!&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class SmsSender implements Sender &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">   public void Send() &#123; </span><br><span class="line">        System.out.println(&quot;this is sms sender!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，建工厂类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SendFactory &#123;  </span><br><span class="line">    public Sender produce(String type) &#123;  </span><br><span class="line">        if (&quot;mail&quot;.equals(type)) &#123;  </span><br><span class="line">            return new MailSender();  </span><br><span class="line">       &#125; else if (&quot;sms&quot;.equals(type)) &#123;  </span><br><span class="line">            return new SmsSender();  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            System.out.println(&quot;请输入正确的类型!&quot;);  </span><br><span class="line">            return null;</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class FactoryTest &#123;  </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        SendFactory factory = new SendFactory();  </span><br><span class="line">        Sender sender = factory.produce(&quot;sms&quot;);  </span><br><span class="line">        sender.Send();  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：this is sms sender!</p><h4 id="多个方法"><a href="#多个方法" class="headerlink" title="多个方法"></a>多个方法</h4><p>是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。关系图：</p><p>将上面的代码做下修改，改动下SendFactory类就行，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class SendFactory &#123;  </span><br><span class="line"></span><br><span class="line">   public Sender produceMail()&#123;  </span><br><span class="line">        return new MailSender(); </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public Sender produceSms()&#123;  </span><br><span class="line">        return new SmsSender(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class FactoryTest &#123;  </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">       SendFactory factory = new SendFactory();  </span><br><span class="line">       Sender sender = factory.produceMail();  </span><br><span class="line">       sender.Send(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：this is mailsender!</p><h4 id="多个静态方法"><a href="#多个静态方法" class="headerlink" title="多个静态方法"></a>多个静态方法</h4><p>将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class SendFactory &#123;  </span><br><span class="line"></span><br><span class="line">    public static Sender produceMail()&#123;  </span><br><span class="line">        return new MailSender();  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static Sender produceSms()&#123;  </span><br><span class="line">        return new SmsSender();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class FactoryTest &#123;  </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;      </span><br><span class="line">        Sender sender = SendFactory.produceMail();      </span><br><span class="line">        sender.Send(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：this is mailsender!</p><p>​    总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。</p><p> <strong>优点：</strong></p><ul><li>使用者只需要给工厂类传入一个正确的约定好的参数，就可以获取你所需要的对象，而不需要知道其创建细节，一定程度上减少系统的耦合。</li><li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，减少开发者的记忆成本。</li></ul><p><strong>缺点：</strong></p><ul><li>如果业务上添加新产品的话，就需要修改工厂类原有的判断逻辑，这其实是违背了开闭原则的。</li><li>在产品类型较多时，有可能造成工厂逻辑过于复杂。所以简单工厂模式比较适合产品种类比较少而且增多的概率很低的情况。</li></ul><h3 id="工厂方法模式（Factory-Method）"><a href="#工厂方法模式（Factory-Method）" class="headerlink" title="工厂方法模式（Factory Method）"></a>工厂方法模式（Factory Method）</h3><p>​    简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到工厂方法模式，创建一个工厂接口和创建多个工厂实现类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。</p><p>请看例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Sender &#123;  </span><br><span class="line">   public void Send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个实现类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MailSender implements Sender &#123;  </span><br><span class="line"></span><br><span class="line">    @Override  </span><br><span class="line">    public void Send() &#123;  </span><br><span class="line">       System.out.println(&quot;this is mailsender!&quot;);  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class SmsSender implements Sender &#123;  </span><br><span class="line"></span><br><span class="line">    @Override </span><br><span class="line">    public void Send() &#123;   </span><br><span class="line">        System.out.println(&quot;this is sms sender!&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供一个接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Provider &#123; </span><br><span class="line"></span><br><span class="line">    public Sender produce();  </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>两个工厂类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class SendMailFactory implements Provider &#123;  </span><br><span class="line"></span><br><span class="line">    @Override  </span><br><span class="line">    public Sender produce()&#123;  </span><br><span class="line">        return new MailSender();  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class SendSmsFactory implements Provider&#123;  </span><br><span class="line"></span><br><span class="line">    @Override  </span><br><span class="line">    public Sender produce() &#123;  </span><br><span class="line">        return new SmsSender();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Provider provider = new SendMailFactory();  </span><br><span class="line">        Sender sender =   </span><br><span class="line">        sender.Send(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>工厂方法模式和抽象工厂模式不好分清楚，他们的区别如下：</p><p>工厂方法模式：</p><p>一个抽象产品类，可以派生出多个具体产品类。   </p><p>一个抽象工厂类，可以派生出多个具体工厂类。   </p><p>每个具体工厂类只能创建一个具体产品类的实例。</p><p>抽象工厂模式：</p><p>多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。   </p><p>一个抽象工厂类，可以派生出多个具体工厂类。   </p><p>每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品。   </p><p>​    </p><p>区别：</p><p>工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。   </p><p>工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。</p><p>工厂方法创建 “一种” 产品，他的着重点在于”怎么创建”，也就是说如果你开发，你的大量代码很可能围绕着这种产品的构造，初始化这些细节上面。也因为如此，类似的产品之间有很多可以复用的特征，所以会和模版方法相随。 </p><p>抽象工厂需要创建一些列产品，着重点在于”创建哪些”产品上，也就是说，如果你开发，你的主要任务是划分不同差异的产品线，并且尽量保持每条产品线接口一致，从而可以从同一个抽象工厂继承。</p><p>对于java来说，你能见到的大部分抽象工厂模式都是这样的：</p><p>—它的里面是一堆工厂方法，每个工厂方法返回某种类型的对象。</p><p>​    比如说工厂可以生产鼠标和键盘。那么抽象工厂的实现类（它的某个具体子类）的对象都可以生产鼠标和键盘，但可能工厂A生产的是罗技的键盘和鼠标，工厂B是微软的。</p><p>​    这样A和B就是工厂，对应于抽象工厂；每个工厂生产的鼠标和键盘就是产品，对应于工厂方法；</p><pre><code> 再比如抽象工厂和工厂方法不同的地方在于，生产产品的工厂是抽象的。举例，可口可乐公司生产可乐的同时，也需要生产装可乐的瓶子和箱子，瓶子和箱子也是可口可乐专属定制的，同样百事可乐公司也会有这个需求。这个时候我们的工厂不仅仅是生产可乐饮料的工厂，还必须同时生产同一主题的瓶子和箱子，所以它是一个抽象的主题工厂，专门生产同一主题的不同商品。</code></pre><p>​    用了工厂方法模式，你替换生成键盘的工厂方法，就可以把键盘从罗技换到微软。但是用了抽象工厂模式，你只要换家工厂，就可以同时替换鼠标和键盘一套。如果你要的产品有几十个，当然用抽象工厂模式一次替换全部最方便（这个工厂会替你用相应的工厂方法）</p><p>​    所以说抽象工厂就像工厂，而工厂方法则像是工厂的一种产品生产线</p><h3 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（Singleton）</h3><p>单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处：</p><p>1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。</p><p>2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。</p><p>3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。</p><p>首先我们写一个简单的单例类：</p><p> 饿汉模式最简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    // 首先，将 new Singleton() 堵死</span><br><span class="line">    private Singleton() &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    // 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建</span><br><span class="line">    private static Singleton instance = new Singleton();</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">  return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饱汉模式最容易出错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line"></span><br><span class="line">    /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */  </span><br><span class="line"></span><br><span class="line">    private static Singleton instance = null;  </span><br><span class="line"></span><br><span class="line">    /* 私有构造方法，防止被实例化 */  </span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;  </span><br><span class="line"></span><br><span class="line">    /* 静态工程方法，创建实例 */  </span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line"></span><br><span class="line">        if (instance == null) &#123;  </span><br><span class="line"></span><br><span class="line">            instance = new Singleton();  </span><br><span class="line">&#125;</span><br><span class="line">        return instance;  </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */  </span><br><span class="line"></span><br><span class="line">    public Object readResolve() &#123;  </span><br><span class="line"></span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个类可以满足基本要求，但是，像这样毫无线程安全保护的类，如果我们把它放入多线程的环境下，肯定就会出现问题了，如何解决？我们首先会想到对getInstance方法加synchronized关键字，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static synchronized Singleton getInstance() &#123;  </span><br><span class="line"></span><br><span class="line">        if (instance == null) &#123;  </span><br><span class="line">            instance = new Singleton();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        return instance; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，synchronized关键字锁住的是这个对象，这样的用法，在性能上会有所下降，因为每次调用getInstance()，都要对对象上锁，事实上，只有在第一次创建对象的时候需要加锁，之后就不需要了，所以，这个地方需要改进。我们改成下面这个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static Singleton getInstance() &#123;  </span><br><span class="line"></span><br><span class="line">        if (instance == null) &#123;  </span><br><span class="line">        //加锁</span><br><span class="line">            synchronized (instance) &#123;  </span><br><span class="line">//防治并发问题</span><br><span class="line">               if (instance == null) &#123;  </span><br><span class="line"></span><br><span class="line">                   instance = new Singleton();  </span><br><span class="line">               &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    似乎解决了之前提到的问题，将synchronized关键字加在了内部，也就是说当调用的时候是不需要加锁的，只有在instance为null，并创建对象的时候才需要加锁，性能有一定的提升。但是，这样的情况，还是有可能有问题的，看下面的情况：在Java指令中创建对象和赋值操作是分开进行的，也就是说instance &#x3D; new Singleton();语句是分两步执行的。但是JVM并不保证这两个操作的先后顺序，也就是说有可能JVM会为新的Singleton实例分配空间，然后直接赋值给instance成员，然后再去初始化这个Singleton实例。这样就可能出错了，我们以A、B两个线程为例：</p><p>1、A、B线程同时进入了第一个if判断</p><p>2、A首先进入synchronized块，由于instance为null，所以它执行instance &#x3D; new Singleton();</p><p>3、由于JVM内部的优化机制，JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块。</p><p>4、B进入synchronized块，由于instance此时不是null，因此它马上离开了synchronized块并将结果返回给调用该方法的程序。</p><p>5、此时B线程打算使用Singleton实例，却发现它没有被初始化，于是错误发生了。</p><p>所以程序还是有可能发生错误，其实程序在运行过程是很复杂的，从这点我们就可以看出，尤其是在写多线程环境下的程序更有难度，有挑战性。我们对该程序做进一步优化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static class SingletonFactory&#123;           </span><br><span class="line"></span><br><span class="line">    private static Singleton instance = new Singleton();           </span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;           </span><br><span class="line"></span><br><span class="line">        return SingletonFactory.instance; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​          </p><p>实际情况是，单例模式使用内部类来维护单例的实现，JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕，这样我们就不用担心上面的问题。同时该方法也只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题。这样我们暂时总结一个完美的单例模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line"></span><br><span class="line">    /* 私有构造方法，防止被实例化 */  </span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 此处使用一个内部类来维护单例 */  </span><br><span class="line"></span><br><span class="line">    private static class SingletonFactory &#123;  </span><br><span class="line">        private static Singleton instance = new Singleton();  </span><br><span class="line">&#125;</span><br><span class="line">    /* 获取实例 */  </span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">        return SingletonFactory.instance;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */  </span><br><span class="line"></span><br><span class="line">    public Object readResolve() &#123;  </span><br><span class="line">        return getInstance();        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    其实说它完美，也不一定，如果在构造函数中抛出异常，实例将永远得不到创建，也会出错。所以说，十分完美的东西是没有的，我们只能根据实际情况，选择最适合自己应用场景的实现方法。也有人这样实现：因为我们只需要在创建类的时候进行同步，所以只要将创建和getInstance()分开，单独为创建加synchronized关键字，也是可以的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTest &#123;  </span><br><span class="line"></span><br><span class="line">    private static SingletonTest instance = null;  </span><br><span class="line"></span><br><span class="line">    private SingletonTest() &#123;  </span><br><span class="line"></span><br><span class="line">    private static synchronized void syncInit() &#123;  </span><br><span class="line"></span><br><span class="line">        if (instance == null) &#123; </span><br><span class="line">            instance = new SingletonTest();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonTest getInstance() &#123;  </span><br><span class="line">        if (instance == null) &#123;  </span><br><span class="line">            syncInit(); </span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑性能的话，整个程序只需创建一次实例，所以性能也不会有什么影响。</p><p>补充：采用”影子实例”的办法为单例对象的属性同步更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTest &#123;  </span><br><span class="line"></span><br><span class="line">    private static SingletonTest instance = null;  </span><br><span class="line"></span><br><span class="line">    private Vector properties = null;  </span><br><span class="line"></span><br><span class="line">    public Vector getProperties() &#123;  </span><br><span class="line"></span><br><span class="line">        return properties;  </span><br><span class="line"></span><br><span class="line">    private SingletonTest() &#123;  </span><br><span class="line"></span><br><span class="line">    private static synchronized void syncInit() &#123;  </span><br><span class="line"></span><br><span class="line">        if (instance == null) &#123;  </span><br><span class="line"></span><br><span class="line">            instance = new SingletonTest();  </span><br><span class="line"></span><br><span class="line">    public static SingletonTest getInstance() &#123;  </span><br><span class="line"></span><br><span class="line">        if (instance == null) &#123;  </span><br><span class="line"></span><br><span class="line">            syncInit();  </span><br><span class="line"></span><br><span class="line">        return instance;  </span><br><span class="line"></span><br><span class="line">    public void updateProperties() &#123;  </span><br><span class="line"></span><br><span class="line">        SingletonTest shadow = new SingletonTest();  </span><br><span class="line"></span><br><span class="line">        properties = shadow.getProperties();</span><br></pre></td></tr></table></figure><p>通过单例模式的学习告诉我们：</p><p>1、单例模式理解起来简单，但是具体实现起来还是有一定的难度。</p><p>2、synchronized关键字锁定的是对象，在用的时候，一定要在恰当的地方使用（注意需要使用锁的对象和过程，可能有的时候并不是整个对象及整个过程都需要锁）。</p><p>到这儿，单例模式基本已经讲完了，结尾处，笔者突然想到另一个问题，就是采用类的静态方法，实现单例模式的效果，也是可行的，此处二者有什么不同？</p><p>首先，静态类不能实现接口。（从类的角度说是可以的，但是那样就破坏了静态了。因为接口中不允许有static修饰的方法，所以即使实现了也是非静态的）</p><p>其次，单例可以被延迟初始化，静态类一般在第一次加载是初始化。之所以延迟加载，是因为有些类比较庞大，所以延迟加载有助于提升性能。</p><p>再次，单例类可以被继承，他的方法可以被覆写。但是静态类内部方法都是static，无法被覆写。</p><p>最后一点，单例类比较灵活，毕竟从实现上只是一个普通的Java类，只要满足单例的基本需求，你可以在里面随心所欲的实现一些其它功能，但是静态类不行。从上面这些概括中，基本可以看出二者的区别，但是，从另一方面讲，我们上面最后实现的那个单例模式，内部就是用一个静态类来实现的，所以，二者有很大的关联，只是我们考虑问题的层面不同罢了。两种思想的结合，才能造就出完美的解决方案，就像HashMap采用数组+链表来实现一样，其实生活中很多事情都是这样，单用不同的方法来处理问题，总是有优点也有缺点，最完美的方法是，结合各个方法的优点，才能最好的解决问题！</p><h3 id="建造者模式（Builder）"><a href="#建造者模式（Builder）" class="headerlink" title="建造者模式（Builder）"></a>建造者模式（Builder）</h3><h3 id="原型模式（Prototype）"><a href="#原型模式（Prototype）" class="headerlink" title="原型模式（Prototype）"></a>原型模式（Prototype）</h3><p>原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。本小结会通过对象的复制，进行讲解。在Java中，复制对象是通过clone()实现的，先创建一个原型类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Prototype implements Cloneable &#123;  </span><br><span class="line"></span><br><span class="line">    public Object clone() throws CloneNotSupportedException &#123;  </span><br><span class="line"></span><br><span class="line">        Prototype proto = (Prototype) super.clone();  </span><br><span class="line"></span><br><span class="line">        return proto;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    很简单，一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的，具体怎么实现，我会在另一篇文章中，关于解读Java中本地方法的调用，此处不再深究。在这儿，我将结合对象的浅复制和深复制来说一下，首先需要了解对象深、浅复制的概念：</p><p>浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。</p><p>深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。</p><p>此处，写一个深浅复制的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class Prototype implements Cloneable, Serializable &#123;  </span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;  </span><br><span class="line"></span><br><span class="line">    private String string;  </span><br><span class="line"></span><br><span class="line">    private SerializableObject obj;  </span><br><span class="line"></span><br><span class="line">    /* 浅复制 */  </span><br><span class="line"></span><br><span class="line">    public Object clone() throws CloneNotSupportedException &#123;  </span><br><span class="line"></span><br><span class="line">        Prototype proto = (Prototype) super.clone();  </span><br><span class="line"></span><br><span class="line">        return proto;  </span><br><span class="line"></span><br><span class="line">    /* 深复制 */  </span><br><span class="line"></span><br><span class="line">    public Object deepClone() throws IOException, ClassNotFoundException &#123;  </span><br><span class="line"></span><br><span class="line">        /* 写入当前对象的二进制流 */  </span><br><span class="line"></span><br><span class="line">        ByteArrayOutputStream bos = new ByteArrayOutputStream();  </span><br><span class="line"></span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(bos);  </span><br><span class="line"></span><br><span class="line">        oos.writeObject(this);  </span><br><span class="line"></span><br><span class="line">        /* 读出二进制流产生的新对象 */  </span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());  </span><br><span class="line"></span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(bis);  </span><br><span class="line"></span><br><span class="line">        return ois.readObject();  </span><br><span class="line"></span><br><span class="line">    public String getString() &#123;  </span><br><span class="line"></span><br><span class="line">        return string;  </span><br><span class="line"></span><br><span class="line">    public void setString(String string) &#123;  </span><br><span class="line"></span><br><span class="line">        this.string = string;  </span><br><span class="line"></span><br><span class="line">    public SerializableObject getObj() &#123;  </span><br><span class="line"></span><br><span class="line">        return obj;  </span><br><span class="line"></span><br><span class="line">    public void setObj(SerializableObject obj) &#123;  </span><br><span class="line"></span><br><span class="line">        this.obj = obj;  </span><br><span class="line"></span><br><span class="line">class SerializableObject implements Serializable &#123;  </span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;  </span><br></pre></td></tr></table></figure><p>要实现深复制，需要采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象。</p><h2 id="结构模式（7种）"><a href="#结构模式（7种）" class="headerlink" title="结构模式（7种）"></a>结构模式（7种）</h2><p>我们接着讨论设计模式，上篇文章我讲完了5种创建型模式，这章开始，我将讲下7种结构型模式：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。其中对象的适配器模式是各种模式的起源</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p> 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。</p><h4 id="类的适配器模式"><a href="#类的适配器模式" class="headerlink" title="类的适配器模式"></a>类的适配器模式</h4><p>核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口是Targetable，通过Adapter类，将Source的功能扩展到Targetable里，看代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Source &#123;  </span><br><span class="line"></span><br><span class="line">    public void method1() &#123; </span><br><span class="line">        System.out.println(&quot;this is original method!&quot;);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Targetable &#123;  </span><br><span class="line">   /* 与原类中的方法相同 */  </span><br><span class="line">    public void method1();  </span><br><span class="line">    /* 新类的方法 */  </span><br><span class="line">    public void method2();  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Adapter extends Source implements Targetable &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void method2() &#123;  </span><br><span class="line">       System.out.println(&quot;this is the targetable method!&quot;);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Adapter类继承Source类，实现Targetable接口，下面是测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class AdapterTest &#123;  </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line"></span><br><span class="line">       Targetable target = new Adapter();  </span><br><span class="line"></span><br><span class="line">        target.method1();  </span><br><span class="line"></span><br><span class="line">        target.method2();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this is original method!</p><p>this is the targetable method!</p><p>这样Targetable接口的实现类就具有了Source类的功能。</p><h4 id="对象的适配器模式"><a href="#对象的适配器模式" class="headerlink" title="对象的适配器模式"></a>对象的适配器模式</h4><p>基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。</p><p>只需要修改Adapter类的源码即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Wrapper implements Targetable &#123;  </span><br><span class="line"></span><br><span class="line">    private Source source;  </span><br><span class="line"></span><br><span class="line">    public Wrapper(Source source)&#123;</span><br><span class="line">        super();  </span><br><span class="line">        this.source = source;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    @Override  </span><br><span class="line">    public void method2() &#123;  </span><br><span class="line">        System.out.println(&quot;this is the targetable method!&quot;);  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override  </span><br><span class="line">    public void method1() &#123;  </span><br><span class="line">        source.method1();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class AdapterTest &#123;  </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Source source = new Source();  </span><br><span class="line">        Targetable target = new Wrapper(source);  </span><br><span class="line"></span><br><span class="line">        target.method1();  </span><br><span class="line">        target.method2();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出与第一种一样，只是适配的方法不同而已。</p><h4 id="接口的适配器模式"><a href="#接口的适配器模式" class="headerlink" title="接口的适配器模式"></a>接口的适配器模式</h4><p>​    第三种适配器模式是接口的适配器模式，接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。</p><p>这个很好理解，在实际开发中，我们也常会遇到这种接口中定义了太多的方法，以致于有时我们在一些实现类中并不是都需要。看代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Sourceable &#123;  </span><br><span class="line"></span><br><span class="line">    public void method1();  </span><br><span class="line">    public void method2(); </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类Wrapper2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Wrapper2 implements Sourceable&#123;  </span><br><span class="line"></span><br><span class="line">    public void method1()&#123;&#125;  </span><br><span class="line">    public void method2()&#123;&#125;  </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class SourceSub1 extends Wrapper2 &#123;  </span><br><span class="line"></span><br><span class="line">    public void method1()&#123;  </span><br><span class="line">        System.out.println(&quot;the sourceable interface&#x27;s first Sub1!&quot;);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class SourceSub2 extends Wrapper2 &#123;  </span><br><span class="line"></span><br><span class="line">    public void method2()&#123;  </span><br><span class="line">        System.out.println(&quot;the sourceable interface&#x27;s second Sub2!&quot;);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class WrapperTest &#123;  </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line"></span><br><span class="line">        Sourceable source1 = new SourceSub1();  </span><br><span class="line">        Sourceable source2 = new SourceSub2();  </span><br><span class="line"></span><br><span class="line">        source1.method1();  </span><br><span class="line">        source1.method2();  </span><br><span class="line">        source2.method1();  </span><br><span class="line">        source2.method2();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试输出：</p><p>the sourceable interface’s first Sub1!</p><p>the sourceable interface’s second Sub2!</p><p>达到了我们的效果！</p><p> 讲了这么多，总结一下三种适配器模式的应用场景：</p><p>​    类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。</p><p>对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。</p><p>接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。</p><h3 id="装饰模式（Decorator）"><a href="#装饰模式（Decorator）" class="headerlink" title="装饰模式（Decorator）"></a>装饰模式（Decorator）</h3><p>顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例，关系图如下：</p><p>Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public interface Sourceable &#123;  </span><br><span class="line"></span><br><span class="line">​    public void method();  </span><br><span class="line"></span><br><span class="line">public class Source implements Sourceable &#123;  </span><br><span class="line"></span><br><span class="line">​    @Override  </span><br><span class="line"> </span><br><span class="line">​    public void method() &#123;  </span><br><span class="line"></span><br><span class="line">​        System.out.println(&quot;the original method!&quot;);  </span><br><span class="line"></span><br><span class="line">public class Decorator implements Sourceable &#123;  </span><br><span class="line"></span><br><span class="line">​    private Sourceable source;  </span><br><span class="line">​    public Decorator(Sourceable source)&#123;  </span><br><span class="line">​        super();  </span><br><span class="line"> </span><br><span class="line">​        this.source = source;  </span><br><span class="line"></span><br><span class="line">​    @Override  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    public void method() &#123;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​        System.out.println(&quot;before decorator!&quot;);  </span><br><span class="line"></span><br><span class="line">​        source.method();  </span><br><span class="line"></span><br><span class="line">​        System.out.println(&quot;after decorator!&quot;);  </span><br><span class="line"></span><br><span class="line">public class DecoratorTest &#123;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    public static void main(String[] args) &#123; </span><br><span class="line"></span><br><span class="line">​        Sourceable source = new Source();  </span><br><span class="line"></span><br><span class="line">​        Sourceable obj = new Decorator(source);  </span><br><span class="line"></span><br><span class="line">​        obj.method();  </span><br><span class="line"></span><br><span class="line">before decorator!</span><br><span class="line"></span><br><span class="line">the original method!</span><br><span class="line"></span><br><span class="line">after decorator!</span><br></pre></td></tr></table></figure><p>装饰器模式的应用场景：</p><p>1、需要扩展一个类的功能。</p><p>2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）</p><p>缺点：产生过多相似的对象，不易排错！</p><h3 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h3><p>其实每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法。先来看看关系图：</p><p>根据上文的阐述，代理模式就比较容易的理解了，我们看下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public interface Sourceable &#123;  </span><br><span class="line"></span><br><span class="line">​    public void method();  </span><br><span class="line">public class Source implements Sourceable &#123;  </span><br><span class="line"></span><br><span class="line">​    @Override  </span><br><span class="line"></span><br><span class="line">​    public void method() &#123;  </span><br><span class="line"></span><br><span class="line">​        System.out.println(&quot;the original method!&quot;);  </span><br><span class="line"></span><br><span class="line">public class Proxy implements Sourceable &#123;  </span><br><span class="line"></span><br><span class="line">​    private Source source;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    public Proxy()&#123;  </span><br><span class="line"></span><br><span class="line">​        super();  </span><br><span class="line"></span><br><span class="line">​        this.source = new Source(); </span><br><span class="line"></span><br><span class="line">​    @Override </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​    public void method() &#123; </span><br><span class="line"></span><br><span class="line">​        before();  </span><br><span class="line"></span><br><span class="line">​        source.method(); </span><br><span class="line"></span><br><span class="line">​        atfer();  </span><br><span class="line">​    private void atfer() &#123;  </span><br><span class="line"></span><br><span class="line">​        System.out.println(&quot;after proxy!&quot;);  </span><br><span class="line"></span><br><span class="line">​    private void before() &#123;  </span><br><span class="line"></span><br><span class="line">​        System.out.println(&quot;before proxy!&quot;); </span><br><span class="line"></span><br><span class="line">public class ProxyTest &#123;  </span><br><span class="line"></span><br><span class="line">​    public static void main(String[] args) &#123;  </span><br><span class="line"></span><br><span class="line">​        Sourceable source = new Proxy();  </span><br><span class="line"></span><br><span class="line">​        source.method(); </span><br><span class="line"></span><br><span class="line">before proxy!</span><br><span class="line"></span><br><span class="line">the original method!</span><br><span class="line"></span><br><span class="line">after proxy!</span><br></pre></td></tr></table></figure><p>代理模式的应用场景：</p><p>如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：</p><p>1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。</p><p>2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。</p><p>使用代理模式，可以将功能划分的更加清晰，有助于后期维护！</p><h3 id="外观模式（Facade）"><a href="#外观模式（Facade）" class="headerlink" title="外观模式（Facade）"></a>外观模式（Facade）</h3><p>外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口，看下类图：（我们以一个计算机的启动过程为例）</p><p>我们先看下实现类：</p><p>public class CPU {  </p><p>​    public void startup(){  </p><p>​        System.out.println(“cpu startup!”);  </p><p>​    public void shutdown(){  </p><p>​        System.out.println(“cpu shutdown!”);  </p><p>public class Memory {  </p><p>​    public void startup(){  </p><p>​        System.out.println(“memory startup!”);  </p><p>​    public void shutdown(){  </p><p>​        System.out.println(“memory shutdown!”);  </p><p>public class Disk {  </p><p>​    public void startup(){  </p><p>​        System.out.println(“disk startup!”);  </p><p>​    public void shutdown(){  </p><p>​        System.out.println(“disk shutdown!”);  </p><p>public class Computer {  </p><p>​    private CPU cpu;  </p><p>​    private Memory memory;  </p><p>​    private Disk disk;  </p><p>​    public Computer(){  </p><p>​        cpu &#x3D; new CPU();  </p><p>​        memory &#x3D; new Memory();  </p><p>​        disk &#x3D; new Disk();  </p><p>​    public void startup(){  </p><p>​        System.out.println(“start the computer!”);  </p><p>​        cpu.startup();  </p><p>​        memory.startup();  </p><p>​        disk.startup();  </p><p>​        System.out.println(“start computer finished!”);  </p><p>​    public void shutdown(){  </p><p>​        System.out.println(“begin to close the computer!”);  </p><p>​        cpu.shutdown();  </p><p>​        memory.shutdown();  </p><p>​        disk.shutdown();  </p><p>​        System.out.println(“computer closed!”);  </p><p>User类如下：</p><p>public class User {  </p><p>​    public static void main(String[] args) {  </p><p>​        Computer computer &#x3D; new Computer();  </p><p>​        computer.startup();  </p><p>​        computer.shutdown();  </p><p>start the computer!</p><p>cpu startup!</p><p>memory startup!</p><p>disk startup!</p><p>start computer finished!</p><p>begin to close the computer!</p><p>cpu shutdown!</p><p>memory shutdown!</p><p>disk shutdown!</p><p>computer closed!</p><p>如果我们没有Computer类，那么，CPU、Memory、Disk他们之间将会相互持有实例，产生关系，这样会造成严重的依赖，修改一个类，可能会带来其他类的修改，这不是我们想要看到的，有了Computer类，他们之间的关系被放在了Computer类里，这样就起到了解耦的作用，这，就是外观模式！</p><p>10、桥接模式（Bridge）</p><p>桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。我们来看看关系图：</p><p>实现代码：</p><p>先定义接口：</p><p>public interface Sourceable {  </p><p>​    public void method();  </p><p>分别定义两个实现类：</p><p>public class SourceSub1 implements Sourceable {  </p><p>​    @Override  </p><p>​    public void method() {  </p><p>​        System.out.println(“this is the first sub!”);  </p><p>public class SourceSub2 implements Sourceable {  </p><p>​    @Override  </p><p>​    public void method() {  </p><p>​        System.out.println(“this is the second sub!”);  </p><p>定义一个桥，持有Sourceable的一个实例：</p><p>public abstract class Bridge {  </p><p>​    private Sourceable source;  </p><p>​    public void method(){  </p><p>​        source.method();  </p><p>​    public Sourceable getSource() {  </p><p>​        return source;  </p><p>​    public void setSource(Sourceable source) {  </p><p>​        this.source &#x3D; source;  </p><p>public class MyBridge extends Bridge {  </p><p>​    public void method(){  </p><p>​        getSource().method();  </p><p>public class BridgeTest {  </p><p>​    public static void main(String[] args) {  </p><p>​        Bridge bridge &#x3D; new MyBridge();  </p><p>​        &#x2F;<em>调用第一个对象</em>&#x2F;  </p><p>​        Sourceable source1 &#x3D; new SourceSub1();  </p><p>​        bridge.setSource(source1);  </p><p>​        bridge.method();  </p><p>​        &#x2F;<em>调用第二个对象</em>&#x2F;  </p><p>​        Sourceable source2 &#x3D; new SourceSub2();  </p><p>​        bridge.setSource(source2);  </p><p>​        bridge.method();  </p><p>output：</p><p>this is the first sub!</p><p>this is the second sub!</p><p>这样，就通过对Bridge类的调用，实现了对接口Sourceable的实现类SourceSub1和SourceSub2的调用。接下来我再画个图，大家就应该明白了，因为这个图是我们JDBC连接的原理，有数据库学习基础的，一结合就都懂了。</p><p>11、组合模式（Composite）</p><p>组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便，看看关系图：</p><p>直接来看代码：</p><p>public class TreeNode {  </p><p>​    private String name;  </p><p>​    private TreeNode parent;  </p><p>​    private Vector children &#x3D; new Vector();  </p><p>​    public TreeNode(String name){  </p><p>​        this.name &#x3D; name;  </p><p>​    public String getName() {  </p><p>​        return name;  </p><p>​    public void setName(String name) {  </p><p>​        this.name &#x3D; name;  </p><p>​    public TreeNode getParent() {  </p><p>​        return parent;  </p><p>​    public void setParent(TreeNode parent) {  </p><p>​        this.parent &#x3D; parent;  </p><p>​    &#x2F;&#x2F;添加孩子节点  </p><p>​    public void add(TreeNode node){  </p><p>​        children.add(node);  </p><p>​    &#x2F;&#x2F;删除孩子节点  </p><p>​    public void remove(TreeNode node){  </p><p>​        children.remove(node);  </p><p>​    &#x2F;&#x2F;取得孩子节点  </p><p>​    public Enumeration getChildren(){  </p><p>​        return children.elements();  </p><p>public class Tree {  </p><p>​    TreeNode root &#x3D; null;  </p><p>​    public Tree(String name) {  </p><p>​        root &#x3D; new TreeNode(name);  </p><p>​    public static void main(String[] args) {  </p><p>​        Tree tree &#x3D; new Tree(“A”);  </p><p>​        TreeNode nodeB &#x3D; new TreeNode(“B”);  </p><p>​        TreeNode nodeC &#x3D; new TreeNode(“C”);  </p><p>​        nodeB.add(nodeC);  </p><p>​        tree.root.add(nodeB);  </p><p>​        System.out.println(“build the tree finished!”);  </p><p>使用场景：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等。</p><p>12、享元模式（Flyweight）</p><p>享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。</p><p>FlyWeightFactory负责创建和管理享元单元，当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建一个新对象，FlyWeight是超类。一提到共享池，我们很容易联想到Java里面的JDBC连接池，想想每个连接的特点，我们不难总结出：适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClassName、username、password及dbname，这些属性对于每个连接来说都是一样的，所以就适合用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。</p><p>看个例子：</p><p>看下数据库连接池的代码：</p><p>public class ConnectionPool {  </p><p>​    private Vector pool;  </p><p>​    &#x2F;<em>公有属性</em>&#x2F;  </p><p>​    private String url &#x3D; “jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test”;  </p><p>​    private String username &#x3D; “root”;  </p><p>​    private String password &#x3D; “root”;  </p><p>​    private String driverClassName &#x3D; “com.mysql.jdbc.Driver”;  </p><p>​    private int poolSize &#x3D; 100;  </p><p>​    private static ConnectionPool instance &#x3D; null;  </p><p>​    Connection conn &#x3D; null;  </p><p>​    &#x2F;<em>构造方法，做一些初始化工作</em>&#x2F;  </p><p>​    private ConnectionPool() {  </p><p>​        pool &#x3D; new Vector(poolSize);  </p><p>​        for (int i &#x3D; 0; i &lt; poolSize; i++) {  </p><p>​            try {  </p><p>​                Class.forName(driverClassName);  </p><p>​                conn &#x3D; DriverManager.getConnection(url, username, password);  </p><p>​                pool.add(conn);  </p><p>​            } catch (ClassNotFoundException e) {  </p><p>​                e.printStackTrace();  </p><p>​            } catch (SQLException e) {  </p><p>​                e.printStackTrace();  </p><p>​    &#x2F;* 返回连接到连接池 *&#x2F;  </p><p>​    public synchronized void release() {  </p><p>​        pool.add(conn);  </p><p>​    &#x2F;* 返回连接池中的一个数据库连接 *&#x2F;  </p><p>​    public synchronized Connection getConnection() {  </p><p>​        if (pool.size() &gt; 0) {  </p><p>​            Connection conn &#x3D; pool.get(0);  </p><p>​            pool.remove(conn);  </p><p>​            return conn;  </p><p>​        } else {  </p><p>​            return null;  </p><p>通过连接池的管理，实现了数据库连接的共享，不需要每一次都重新创建连接，节省了数据库重新创建的开销，提升了系统的性能！</p><p>C、关系模式（11种）</p><p>先来张图，看看这11中模式的关系：</p><p>第一类：通过父类与子类的关系进行实现。</p><p>第二类：两个类之间。</p><p>第三类：类的状态。</p><p>第四类：通过中间类</p><p>父类与子类关系</p><p>13、策略模式（strategy）</p><p>策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数，关系图如下：</p><p>图中ICalculator提供同意的方法，</p><p>AbstractCalculator是辅助类，提供辅助方法，接下来，依次实现下每个类：</p><p>首先统一接口：</p><p>public interface ICalculator {  </p><p>​    public int calculate(String exp);  </p><p>public abstract class AbstractCalculator {  </p><p>​    public int[] split(String exp,String opt){  </p><p>​        String array[] &#x3D; exp.split(opt);  </p><p>​        int arrayInt[] &#x3D; new int[2];  </p><p>​        arrayInt[0] &#x3D; Integer.parseInt(array[0]);  </p><p>​        arrayInt[1] &#x3D; Integer.parseInt(array[1]);  </p><p>​        return arrayInt;  </p><p>三个实现类：</p><p>public class Plus extends AbstractCalculator implements ICalculator {  </p><p>​    @Override  </p><p>​    public int calculate(String exp) {  </p><p>​        int arrayInt[] &#x3D; split(exp,”\+”);  </p><p>​        return arrayInt[0]+arrayInt[1];  </p><p>public class Minus extends AbstractCalculator implements ICalculator {  </p><p>​    @Override  </p><p>​    public int calculate(String exp) {  </p><p>​        int arrayInt[] &#x3D; split(exp,”-“);  </p><p>​        return arrayInt[0]-arrayInt[1];  </p><p>public class Multiply extends AbstractCalculator implements ICalculator {  </p><p>​    @Override  </p><p>​    public int calculate(String exp) {  </p><p>​        int arrayInt[] &#x3D; split(exp,”\*”);  </p><p>​        return arrayInt[0]*arrayInt[1];  </p><p>简单的测试类：</p><p>public class StrategyTest {  </p><p>​    public static void main(String[] args) {  </p><p>​        String exp &#x3D; “2+8”;  </p><p>​        ICalculator cal &#x3D; new Plus();  </p><p>​        int result &#x3D; cal.calculate(exp);  </p><p>​        System.out.println(result);  </p><p>输出：10</p><p>策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。</p><p>14、模板方法模式（Template Method）</p><p>解释一下模板方法模式，就是指：一个抽象类中，有一个主方法，再定义1…n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用，先看个关系图：</p><p>就是在AbstractCalculator类中定义一个主方法calculate，calculate()调用spilt()等，Plus和Minus分别继承AbstractCalculator类，通过对AbstractCalculator的调用实现对子类的调用，看下面的例子：</p><p>public abstract class AbstractCalculator {  </p><p>​    &#x2F;<em>主方法，实现对本类其它方法的调用</em>&#x2F;  </p><p>​    public final int calculate(String exp,String opt){  </p><p>​        int array[] &#x3D; split(exp,opt);  </p><p>​        return calculate(array[0],array[1]);  </p><p>​    &#x2F;<em>被子类重写的方法</em>&#x2F;  </p><p>​    abstract public int calculate(int num1,int num2);  </p><p>​    public int[] split(String exp,String opt){  </p><p>​        String array[] &#x3D; exp.split(opt);  </p><p>​        int arrayInt[] &#x3D; new int[2];  </p><p>​        arrayInt[0] &#x3D; Integer.parseInt(array[0]);  </p><p>​        arrayInt[1] &#x3D; Integer.parseInt(array[1]);  </p><p>​        return arrayInt;  </p><p>public class Plus extends AbstractCalculator {  </p><p>​    @Override  </p><p>​    public int calculate(int num1,int num2) {  </p><p>​        return num1 + num2;  </p><p>public class StrategyTest {  </p><p>​    public static void main(String[] args) {  </p><p>​        String exp &#x3D; “8+8”;  </p><p>​        AbstractCalculator cal &#x3D; new Plus();  </p><p>​        int result &#x3D; cal.calculate(exp, “\+”);  </p><p>​        System.out.println(result);  </p><p>我跟踪下这个小程序的执行过程：首先将exp和”\+”做参数，调用AbstractCalculator类里的calculate(String,String)方法，在calculate(String,String)里调用同类的split()，之后再调用calculate(int ,int)方法，从这个方法进入到子类中，执行完return num1 + num2后，将值返回到AbstractCalculator类，赋给result，打印出来。正好验证了我们开头的思路。</p><p>类之间的关系</p><p>15、观察者模式（Observer）</p><p>包括这个模式在内的接下来的四个模式，都是类和类之间的关系，不涉及到继承，学的时候应该 记得归纳，记得本文最开始的那个图。观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。先来看看关系图：</p><p>我解释下这些类的作用：MySubject类就是我们的主对象，Observer1和Observer2是依赖于MySubject的对象，当MySubject变化时，Observer1和Observer2必然变化。AbstractSubject类中定义着需要监控的对象列表，可以对其进行修改：增加或删除被监控对象，且当MySubject变化时，负责通知在列表内存在的对象。我们看实现代码：</p><p>一个Observer接口：</p><p>public interface Observer {  </p><p>​    public void update();  </p><p>两个实现类：</p><p>public class Observer1 implements Observer {  </p><p>​    @Override  </p><p>​    public void update() {  </p><p>​        System.out.println(“observer1 has received!”);  </p><p>public class Observer2 implements Observer {  </p><p>​    @Override  </p><p>​    public void update() {  </p><p>​        System.out.println(“observer2 has received!”);  </p><p>Subject接口及实现类：</p><p>public interface Subject {  </p><p>​    &#x2F;<em>增加观察者</em>&#x2F;  </p><p>​    public void add(Observer observer);  </p><p>​    &#x2F;<em>删除观察者</em>&#x2F;  </p><p>​    public void del(Observer observer);  </p><p>​    &#x2F;<em>通知所有的观察者</em>&#x2F;  </p><p>​    public void notifyObservers();  </p><p>​    &#x2F;<em>自身的操作</em>&#x2F;  </p><p>​    public void operation();  </p><p>public abstract class AbstractSubject implements Subject {  </p><p>​    private Vector vector &#x3D; new Vector();  </p><p>​    @Override  </p><p>​    public void add(Observer observer) {  </p><p>​        vector.add(observer);  </p><p>​    @Override  </p><p>​    public void del(Observer observer) {  </p><p>​        vector.remove(observer);  </p><p>​    @Override  </p><p>​    public void notifyObservers() {  </p><p>​        Enumeration enumo &#x3D; vector.elements();  </p><p>​        while(enumo.hasMoreElements()){  </p><p>​            enumo.nextElement().update();  </p><p>public class MySubject extends AbstractSubject {  </p><p>​    @Override  </p><p>​    public void operation() {  </p><p>​        System.out.println(“update self!”);  </p><p>​        notifyObservers();  </p><p>public class ObserverTest {  </p><p>​    public static void main(String[] args) {  </p><p>​        Subject sub &#x3D; new MySubject();  </p><p>​        sub.add(new Observer1());  </p><p>​        sub.add(new Observer2());  </p><p>​        sub.operation();  </p><p>update self!</p><p>observer1 has received!</p><p>observer2 has received!</p><p> 这些东西，其实不难，只是有些抽象，不太容易整体理解，建议读者：根据关系图，新建项目，自己写代码（或者参考我的代码）,按照总体思路走一遍，这样才能体会它的思想，理解起来容易！</p><p>16、迭代子模式（Iterator）</p><p>顾名思义，迭代器模式就是顺序访问聚集中的对象，一般来说，集合中非常常见，如果对集合类比较熟悉的话，理解本模式会十分轻松。这句话包含两层意思：一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。我们看下关系图：</p><p>这个思路和我们常用的一模一样，MyCollection中定义了集合的一些操作，MyIterator中定义了一系列迭代操作，且持有Collection实例，我们来看看实现代码：</p><p>两个接口：</p><p>public interface Collection {  </p><p>​    public Iterator iterator();  </p><p>​    &#x2F;<em>取得集合元素</em>&#x2F;  </p><p>​    public Object get(int i);  </p><p>​    &#x2F;<em>取得集合大小</em>&#x2F;  </p><p>​    public int size();  </p><p>public interface Iterator {  </p><p>​    public Object previous();  </p><p>​    public Object next();  </p><p>​    public boolean hasNext();  </p><p>​    &#x2F;&#x2F;取得第一个元素  </p><p>​    public Object first();  </p><p>两个实现：</p><p>public class MyCollection implements Collection {  </p><p>​    public String string[] &#x3D; {“A”,”B”,”C”,”D”,”E”};  </p><p>​    @Override  </p><p>​    public Iterator iterator() {  </p><p>​        return new MyIterator(this);  </p><p>​    @Override  </p><p>​    public Object get(int i) {  </p><p>​        return string[i];  </p><p>​    @Override  </p><p>​    public int size() {  </p><p>​        return string.length;  </p><p>public class MyIterator implements Iterator {  </p><p>​    private Collection collection;  </p><p>​    private int pos &#x3D; -1;  </p><p>​    public MyIterator(Collection collection){  </p><p>​        this.collection &#x3D; collection;  </p><p>​    @Override  </p><p>​    public Object previous() {  </p><p>​        if(pos &gt; 0){  </p><p>​            pos–;  </p><p>​        return collection.get(pos);  </p><p>​    @Override  </p><p>​    public Object next() {  </p><p>​        if(pos&lt;collection.size()-1){  </p><p>​            pos++;  </p><p>​        return collection.get(pos);  </p><p>​    @Override  </p><p>​    public boolean hasNext() {  </p><p>​        if(pos&lt;collection.size()-1){  </p><p>​            return true;  </p><p>​        }else{  </p><p>​            return false;  </p><p>​    @Override  </p><p>​    public Object first() {  </p><p>​        pos &#x3D; 0;  </p><p>​        return collection.get(pos);  </p><p>public class Test {  </p><p>​    public static void main(String[] args) {  </p><p>​        Collection collection &#x3D; new MyCollection();  </p><p>​        Iterator it &#x3D; collection.iterator();  </p><p>​        while(it.hasNext()){  </p><p>​            System.out.println(it.next());  </p><p>输出：A B C D E</p><p>此处我们貌似模拟了一个集合类的过程，感觉是不是很爽？其实JDK中各个类也都是这些基本的东西，加一些设计模式，再加一些优化放到一起的，只要我们把这些东西学会了，掌握好了，我们也可以写出自己的集合类，甚至框架！</p><p>17、责任链模式（Chain of Responsibility）</p><p>接下来我们将要谈谈责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。先看看关系图：</p><p>Abstracthandler类提供了get和set方法，方便MyHandle类设置和修改引用对象，MyHandle类是核心，实例化后生成一系列相互持有的对象，构成一条链。</p><p>public interface Handler {  </p><p>​    public void operator();  </p><p>public abstract class AbstractHandler {  </p><p>​    private Handler handler;  </p><p>​    public Handler getHandler() {  </p><p>​        return handler;  </p><p>​    public void setHandler(Handler handler) {  </p><p>​        this.handler &#x3D; handler;  </p><p>public class MyHandler extends AbstractHandler implements Handler {  </p><p>​    private String name;  </p><p>​    public MyHandler(String name) {  </p><p>​        this.name &#x3D; name;  </p><p>​    @Override  </p><p>​    public void operator() {  </p><p>​        System.out.println(name+”deal!”);  </p><p>​        if(getHandler()!&#x3D;null){  </p><p>​            getHandler().operator();  </p><p>public class Test {  </p><p>​    public static void main(String[] args) {  </p><p>​        MyHandler h1 &#x3D; new MyHandler(“h1”);  </p><p>​        MyHandler h2 &#x3D; new MyHandler(“h2”);  </p><p>​        MyHandler h3 &#x3D; new MyHandler(“h3”);  </p><p>​        h1.setHandler(h2);  </p><p>​        h2.setHandler(h3);  </p><p>​        h1.operator();  </p><p>h1deal!</p><p>h2deal!</p><p>h3deal!</p><p>此处强调一点就是，链接上的请求可以是一条链，可以是一个树，还可以是一个环，模式本身不约束这个，需要我们自己去实现，同时，在一个时刻，命令只允许由一个对象传给另一个对象，而不允许传给多个对象。</p><p> 18、命令模式（Command）</p><p>命令模式很好理解，举个例子，司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。这个过程好在，三者相互解耦，任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，不会去关注到底士兵是怎么实现的。我们看看关系图：</p><p>Invoker是调用者（司令员），Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接收对象，看实现代码：</p><p>public interface Command {  </p><p>​    public void exe();  </p><p>public class MyCommand implements Command {  </p><p>​    private Receiver receiver;  </p><p>​    public MyCommand(Receiver receiver) {  </p><p>​        this.receiver &#x3D; receiver;  </p><p>​    @Override  </p><p>​    public void exe() {  </p><p>​        receiver.action();  </p><p>public class Receiver {  </p><p>​    public void action(){  </p><p>​        System.out.println(“command received!”);  </p><p>public class Invoker {  </p><p>​    private Command command;  </p><p>​    public Invoker(Command command) {  </p><p>​        this.command &#x3D; command;  </p><p>​    public void action(){  </p><p>​        command.exe();  </p><p>public class Test {  </p><p>​    public static void main(String[] args) {  </p><p>​        Receiver receiver &#x3D; new Receiver();  </p><p>​        Command cmd &#x3D; new MyCommand(receiver);  </p><p>​        Invoker invoker &#x3D; new Invoker(cmd);  </p><p>​        invoker.action();  </p><p>输出：command received!</p><p>这个很哈理解，命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开，熟悉Struts的同学应该知道，Struts其实就是一种将请求和呈现分离的技术，其中必然涉及命令模式的思想！</p><p>其实每个设计模式都是很重要的一种思想，看上去很熟，其实是因为我们在学到的东西中都有涉及，尽管有时我们并不知道，其实在Java本身的设计之中处处都有体现，像AWT、JDBC、集合类、IO管道或者是Web框架，里面设计模式无处不在。因为我们篇幅有限，很难讲每一个设计模式都讲的很详细，不过我会尽我所能，尽量在有限的空间和篇幅内，把意思写清楚了，更好让大家明白。本章不出意外的话，应该是设计模式最后一讲了，首先还是上一下上篇开头的那个图：</p><p>本章讲讲第三类和第四类。</p><p>19、备忘录模式（Memento）</p><p>主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象，个人觉得叫备份模式更形象些，通俗的讲下：假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作。做个图来分析一下：</p><p>Original类是原始类，里面有需要保存的属性value及创建一个备忘录类，用来保存value值。Memento类是备忘录类，Storage类是存储备忘录的类，持有Memento类的实例，该模式很好理解。直接看源码：</p><p>public class Original {  </p><p>​    private String value;  </p><p>​    public String getValue() {  </p><p>​        return value;  </p><p>​    public void setValue(String value) {  </p><p>​        this.value &#x3D; value;  </p><p>​    public Original(String value) {  </p><p>​        this.value &#x3D; value;  </p><p>​    public Memento createMemento(){  </p><p>​        return new Memento(value);  </p><p>​    public void restoreMemento(Memento memento){  </p><p>​        this.value &#x3D; memento.getValue();  </p><p>public class Memento {  </p><p>​    private String value;  </p><p>​    public Memento(String value) {  </p><p>​        this.value &#x3D; value;  </p><p>​    public String getValue() {  </p><p>​        return value;  </p><p>​    public void setValue(String value) {  </p><p>​        this.value &#x3D; value;  </p><p>public class Storage {  </p><p>​    private Memento memento;  </p><p>​    public Storage(Memento memento) {  </p><p>​        this.memento &#x3D; memento;  </p><p>​    public Memento getMemento() {  </p><p>​        return memento;  </p><p>​    public void setMemento(Memento memento) {  </p><p>​        this.memento &#x3D; memento;  </p><p>public class Test {  </p><p>​    public static void main(String[] args) {  </p><p>​        &#x2F;&#x2F; 创建原始类  </p><p>​        Original origi &#x3D; new Original(“egg”);  </p><p>​        &#x2F;&#x2F; 创建备忘录  </p><p>​        Storage storage &#x3D; new Storage(origi.createMemento());  </p><p>​        &#x2F;&#x2F; 修改原始类的状态  </p><p>​        System.out.println(“初始化状态为：” + origi.getValue());  </p><p>​        origi.setValue(“niu”);  </p><p>​        System.out.println(“修改后的状态为：” + origi.getValue());  </p><p>​        &#x2F;&#x2F; 回复原始类的状态  </p><p>​        origi.restoreMemento(storage.getMemento());  </p><p>​        System.out.println(“恢复后的状态为：” + origi.getValue());  </p><p>初始化状态为：egg</p><p>修改后的状态为：niu</p><p>恢复后的状态为：egg</p><p>简单描述下：新建原始类时，value被初始化为egg，后经过修改，将value的值置为niu，最后倒数第二行进行恢复状态，结果成功恢复了。其实我觉得这个模式叫“备份-恢复”模式最形象。</p><p>20、状态模式（State）</p><p>核心思想就是：当对象的状态改变时，同时改变其行为，很好理解！就拿QQ来说，有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态，所以，状态模式就两点：1、可以通过改变状态来获得不同的行为。2、你的好友能同时看到你的变化。看图：</p><p>State类是个状态类，Context类可以实现切换，我们来看看代码：</p><p>package com.xtfggef.dp.state;  </p><p> * 状态类的核心类 </p><p> * 2012-12-1 </p><p> * @author erqing </p><p>public class State {  </p><p>​    private String value;  </p><p>​    public String getValue() {  </p><p>​        return value;  </p><p>​    public void setValue(String value) {  </p><p>​        this.value &#x3D; value;  </p><p>​    public void method1(){  </p><p>​        System.out.println(“execute the first opt!”);  </p><p>​    public void method2(){  </p><p>​        System.out.println(“execute the second opt!”);  </p><p>package com.xtfggef.dp.state;  </p><p> * 状态模式的切换类   2012-12-1 </p><p> * @author erqing </p><p>public class Context {  </p><p>​    private State state;  </p><p>​    public Context(State state) {  </p><p>​        this.state &#x3D; state;  </p><p>​    public State getState() {  </p><p>​        return state;  </p><p>​    public void setState(State state) {  </p><p>​        this.state &#x3D; state;  </p><p>​    public void method() {  </p><p>​        if (state.getValue().equals(“state1”)) {  </p><p>​            state.method1();  </p><p>​        } else if (state.getValue().equals(“state2”)) {  </p><p>​            state.method2();  </p><p>测试类：</p><p>public class Test {  </p><p>​    public static void main(String[] args) {  </p><p>​        State state &#x3D; new State();  </p><p>​        Context context &#x3D; new Context(state);  </p><p>​        &#x2F;&#x2F;设置第一种状态  </p><p>​        state.setValue(“state1”);  </p><p>​        context.method();  </p><p>​        &#x2F;&#x2F;设置第二种状态  </p><p>​        state.setValue(“state2”);  </p><p>​        context.method();  </p><p>输出：</p><p>execute the first opt!</p><p>execute the second opt!</p><p>根据这个特性，状态模式在日常开发中用的挺多的，尤其是做网站的时候，我们有时希望根据对象的某一属性，区别开他们的一些功能，比如说简单的权限控制等。</p><p>通过中间类</p><p>21、访问者模式（Visitor）</p><p>访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。访问者模式适用于数据结构相对稳定算法又易变化的系统。因为访问者模式使得算法操作增加变得容易。若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。其缺点就是增加新的数据结构很困难。—— From 百科</p><p>简单来说，访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。简单关系图：</p><p>来看看原码：一个Visitor类，存放要访问的对象，</p><p>public interface Visitor {  </p><p>​    public void visit(Subject sub);  </p><p>public class MyVisitor implements Visitor {  </p><p>​    @Override  </p><p>​    public void visit(Subject sub) {  </p><p>​        System.out.println(“visit the subject：”+sub.getSubject());  </p><p>Subject类，accept方法，接受将要访问它的对象，getSubject()获取将要被访问的属性，</p><p>public interface Subject {  </p><p>​    public void accept(Visitor visitor);  </p><p>​    public String getSubject();  </p><p>public class MySubject implements Subject {  </p><p>​    @Override  </p><p>​    public void accept(Visitor visitor) {  </p><p>​        visitor.visit(this);  </p><p>​    @Override  </p><p>​    public String getSubject() {  </p><p>​        return “love”;  </p><p>测试：</p><p>public class Test {  </p><p>​    public static void main(String[] args) {  </p><p>​        Visitor visitor &#x3D; new MyVisitor();  </p><p>​        Subject sub &#x3D; new MySubject();  </p><p>​        sub.accept(visitor);      </p><p>输出：visit the subject：love</p><p>该模式适用场景：如果我们想为一个现有的类增加新功能，不得不考虑几个事情：1、新功能会不会与现有功能出现兼容性问题？2、以后会不会再需要添加？3、如果类不允许修改代码怎么办？面对这些问题，最好的解决方法就是使用访问者模式，访问者模式适用于数据结构相对稳定的系统，把数据结构和算法解耦，</p><p>22、中介者模式（Mediator）</p><p>中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。如果使用中介者模式，只需关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行，这有点像spring容器的作用。先看看图：</p><p>User类统一接口，User1和User2分别是不同的对象，二者之间有关联，如果不采用中介者模式，则需要二者相互持有引用，这样二者的耦合度很高，为了解耦，引入了Mediator类，提供统一接口，MyMediator为其实现类，里面持有User1和User2的实例，用来实现对User1和User2的控制。这样User1和User2两个对象相互独立，他们只需要保持好和Mediator之间的关系就行，剩下的全由MyMediator类来维护！基本实现：</p><p>public interface Mediator {  </p><p>​    public void createMediator();  </p><p>​    public void workAll();  </p><p>public class MyMediator implements Mediator {  </p><p>​    private User user1;  </p><p>​    private User user2;  </p><p>​    public User getUser1() {  </p><p>​        return user1;  </p><p>​    public User getUser2() {  </p><p>​        return user2;  </p><p>​    @Override  </p><p>​    public void createMediator() {  </p><p>​        user1 &#x3D; new User1(this);  </p><p>​        user2 &#x3D; new User2(this);  </p><p>​    @Override  </p><p>​    public void workAll() {  </p><p>​        user1.work();  </p><p>​        user2.work();  </p><p>public abstract class User {  </p><p>​    private Mediator mediator;  </p><p>​    public Mediator getMediator(){  </p><p>​        return mediator;  </p><p>​    public User(Mediator mediator) {  </p><p>​        this.mediator &#x3D; mediator;  </p><p>​    public abstract void work();  </p><p>public class User1 extends User {  </p><p>​    public User1(Mediator mediator){  </p><p>​        super(mediator);  </p><p>​    @Override  </p><p>​    public void work() {  </p><p>​        System.out.println(“user1 exe!”);  </p><p>public class User2 extends User {  </p><p>​    public User2(Mediator mediator){  </p><p>​        super(mediator);  </p><p>​    @Override  </p><p>​    public void work() {  </p><p>​        System.out.println(“user2 exe!”);  </p><p>测试类：</p><p>public class Test {  </p><p>​    public static void main(String[] args) {  </p><p>​        Mediator mediator &#x3D; new MyMediator();  </p><p>​        mediator.createMediator();  </p><p>​        mediator.workAll();  </p><p>输出：</p><p>user1 exe!</p><p>user2 exe!</p><p>23、解释器模式（Interpreter）</p><p>解释器模式是我们暂时的最后一讲，一般主要应用在OOP开发中的编译器的开发中，所以适用面比较窄。</p><p>Context类是一个上下文环境类，Plus和Minus分别是用来计算的实现，代码如下：</p><p>public interface Expression {  </p><p>​    public int interpret(Context context);  </p><p>public class Plus implements Expression {  </p><p>​    @Override  </p><p>​    public int interpret(Context context) {  </p><p>​        return context.getNum1()+context.getNum2();  </p><p>public class Minus implements Expression {  </p><p>​    @Override  </p><p>​    public int interpret(Context context) {  </p><p>​        return context.getNum1()-context.getNum2();  </p><p>public class Context {  </p><p>​    private int num1;  </p><p>​    private int num2;  </p><p>​    public Context(int num1, int num2) {  </p><p>​        this.num1 &#x3D; num1;  </p><p>​        this.num2 &#x3D; num2;  </p><p>​    public int getNum1() {  </p><p>​        return num1;  </p><p>​    public void setNum1(int num1) {  </p><p>​        this.num1 &#x3D; num1;  </p><p>​    public int getNum2() {  </p><p>​        return num2;  </p><p>​    public void setNum2(int num2) {  </p><p>​        this.num2 &#x3D; num2;  </p><p>public class Test {  </p><p>​    public static void main(String[] args) {  </p><p>​        &#x2F;&#x2F; 计算9+2-8的值  </p><p>​        int result &#x3D; new Minus().interpret((new Context(new Plus()  </p><p>​                .interpret(new Context(9, 2)), 8)));  </p><p>​        System.out.println(result);  </p><p>最后输出正确的结果：3。</p><p>基本就这样，解释器模式用来做各种各样的解释器，如正则表达式等的解释器等等！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2022/05/11/RabbitMQ/"/>
      <url>/2022/05/11/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h1 id="1-初识MQ"><a href="#1-初识MQ" class="headerlink" title="1.初识MQ"></a>1.初识MQ</h1><h2 id="1-1-同步和异步通讯"><a href="#1-1-同步和异步通讯" class="headerlink" title="1.1.同步和异步通讯"></a>1.1.同步和异步通讯</h2><p>微服务间通讯有同步和异步两种方式：</p><p>同步通讯：就像打电话，需要实时响应。</p><p>异步通讯：就像发邮件，不需要马上回复。</p><p><img src="/2022/05/11/RabbitMQ/image-20210717161939695.png"></p><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。</p><h3 id="1-1-1-同步通讯"><a href="#1-1-1-同步通讯" class="headerlink" title="1.1.1.同步通讯"></a>1.1.1.同步通讯</h3><p>我们之前学习的Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：</p><p><img src="/2022/05/11/RabbitMQ/image-20210717162004285.png"></p><p>总结：</p><p>同步调用的优点：</p><ul><li>时效性较强，可以立即得到结果</li></ul><p>同步调用的问题：</p><ul><li>耦合度高</li><li>性能和吞吐能力下降</li><li>有额外的资源消耗</li><li>有级联失败问题</li></ul><h3 id="1-1-2-异步通讯"><a href="#1-1-2-异步通讯" class="headerlink" title="1.1.2.异步通讯"></a>1.1.2.异步通讯</h3><p>异步调用则可以避免上述问题：</p><p>我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。</p><p>在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。</p><p>订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</p><p>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。</p><p><img src="/2022/05/11/RabbitMQ/image-20210422095356088.png"></p><p>Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p><p>好处：</p><ul><li>吞吐量提升：无需等待订阅者处理完成，响应更快速</li><li>故障隔离：服务没有直接调用，不存在级联失败问题</li><li>调用间没有阻塞，不会造成无效的资源占用</li><li>耦合度极低，每个服务都可以灵活插拔，可替换</li><li>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</li></ul><p>缺点：</p><ul><li>架构复杂了，业务没有明显的流程线，不好管理</li><li>需要依赖于Broker的可靠、安全、性能</li></ul><p>好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。</p><h2 id="1-2-技术对比："><a href="#1-2-技术对比：" class="headerlink" title="1.2.技术对比："></a>1.2.技术对比：</h2><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。</p><p>比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司&#x2F;社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p><h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h1><h2 id="2-1-安装RabbitMQ"><a href="#2-1-安装RabbitMQ" class="headerlink" title="2.1.安装RabbitMQ"></a>2.1.安装RabbitMQ</h2><p>安装RabbitMQ，参考博客：</p><p>MQ的基本结构：</p><p><img src="/2022/05/11/RabbitMQ/image-20210717162752376.png"></p><p>RabbitMQ中的一些角色：</p><ul><li>publisher：生产者</li><li>consumer：消费者</li><li>exchange个：交换机，负责消息路由</li><li>queue：队列，存储消息</li><li>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</li></ul><h2 id="2-2-RabbitMQ消息模型"><a href="#2-2-RabbitMQ消息模型" class="headerlink" title="2.2.RabbitMQ消息模型"></a>2.2.RabbitMQ消息模型</h2><p>RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型：</p><p><img src="/2022/05/11/RabbitMQ/image-20210717163332646.png"></p><h2 id="2-3-导入Demo工程"><a href="#2-3-导入Demo工程" class="headerlink" title="2.3.导入Demo工程"></a>2.3.导入Demo工程</h2><p>提供了一个Demo工程，mq-demo:</p><p>导入后可以看到结构如下：</p><p><img src="/2022/05/11/RabbitMQ/image-20210717163604330.png"></p><p>包括三部分：</p><ul><li>mq-demo：父工程，管理项目依赖</li><li>publisher：消息的发送者</li><li>consumer：消息的消费者</li></ul><h2 id="2-4-入门案例"><a href="#2-4-入门案例" class="headerlink" title="2.4.入门案例"></a>2.4.入门案例</h2><p>简单队列模式的模型图：</p><p> <img src="/2022/05/11/RabbitMQ/image-20210717163434647.png"></p><p>官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p><ul><li>publisher：消息发布者，将消息发送到队列queue</li><li>queue：消息队列，负责接受并缓存消息</li><li>consumer：订阅队列，处理队列中的消息</li></ul><h3 id="2-4-1-publisher实现"><a href="#2-4-1-publisher实现" class="headerlink" title="2.4.1.publisher实现"></a>2.4.1.publisher实现</h3><p>思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>发送消息</li><li>关闭连接和channel</li></ul><p>代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line">import com.rabbitmq.client.ConnectionFactory;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">public class PublisherTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void testSendMessage() throws IOException, TimeoutException &#123;</span><br><span class="line">        // 1.建立连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span><br><span class="line">        factory.setHost(&quot;192.168.150.101&quot;);</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        factory.setVirtualHost(&quot;/&quot;);</span><br><span class="line">        factory.setUsername(&quot;itcast&quot;);</span><br><span class="line">        factory.setPassword(&quot;123321&quot;);</span><br><span class="line">        // 1.2.建立连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        // 2.创建通道Channel</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 3.创建队列</span><br><span class="line">        String queueName = &quot;simple.queue&quot;;</span><br><span class="line">        channel.queueDeclare(queueName, false, false, false, null);</span><br><span class="line"></span><br><span class="line">        // 4.发送消息</span><br><span class="line">        String message = &quot;hello, rabbitmq!&quot;;</span><br><span class="line">        channel.basicPublish(&quot;&quot;, queueName, null, message.getBytes());</span><br><span class="line">        System.out.println(&quot;发送消息成功：【&quot; + message + &quot;】&quot;);</span><br><span class="line"></span><br><span class="line">        // 5.关闭通道和连接</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-2-consumer实现"><a href="#2-4-2-consumer实现" class="headerlink" title="2.4.2.consumer实现"></a>2.4.2.consumer实现</h3><p>代码思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>订阅消息</li></ul><p>代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">public class ConsumerTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        // 1.建立连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span><br><span class="line">        factory.setHost(&quot;192.168.150.101&quot;);</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        factory.setVirtualHost(&quot;/&quot;);</span><br><span class="line">        factory.setUsername(&quot;itcast&quot;);</span><br><span class="line">        factory.setPassword(&quot;123321&quot;);</span><br><span class="line">        // 1.2.建立连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        // 2.创建通道Channel</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 3.创建队列</span><br><span class="line">        String queueName = &quot;simple.queue&quot;;</span><br><span class="line">        channel.queueDeclare(queueName, false, false, false, null);</span><br><span class="line"></span><br><span class="line">        // 4.订阅消息</span><br><span class="line">        channel.basicConsume(queueName, true, new DefaultConsumer(channel)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope,</span><br><span class="line">                                       AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                // 5.处理消息</span><br><span class="line">                String message = new String(body);</span><br><span class="line">                System.out.println(&quot;接收到消息：【&quot; + message + &quot;】&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(&quot;等待接收消息。。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5.总结"></a>2.5.总结</h2><p>基本消息队列的消息发送流程：</p><ol><li>建立connection</li><li>创建channel</li><li>利用channel声明队列</li><li>利用channel向队列发送消息</li></ol><p>基本消息队列的消息接收流程：</p><ol><li>建立connection</li><li>创建channel</li><li>利用channel声明队列</li><li>定义consumer的消费行为handleDelivery()</li><li>利用channel将消费者与队列绑定</li></ol><h1 id="3-SpringAMQP"><a href="#3-SpringAMQP" class="headerlink" title="3.SpringAMQP"></a>3.SpringAMQP</h1><p>SpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。</p><p>SpringAmqp的官方地址：<a href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a></p><p><img src="/2022/05/11/RabbitMQ/image-20210717164024967.png"></p><p><img src="/2022/05/11/RabbitMQ/image-20210717164038678.png"></p><p>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息</li></ul><h2 id="3-1-Basic-Queue-简单队列模型"><a href="#3-1-Basic-Queue-简单队列模型" class="headerlink" title="3.1.Basic Queue 简单队列模型"></a>3.1.Basic Queue 简单队列模型</h2><p>在父工程mq-demo中引入依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="3-1-1-消息发送"><a href="#3-1-1-消息发送" class="headerlink" title="3.1.1.消息发送"></a>3.1.1.消息发送</h3><p>首先配置MQ地址，在publisher服务的application.yml中添加配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 192.168.150.101 # 主机名</span><br><span class="line">    port: 5672 # 端口</span><br><span class="line">    virtual-host: / # 虚拟主机</span><br><span class="line">    username: itcast # 用户名</span><br><span class="line">    password: 123321 # 密码</span><br></pre></td></tr></table></figure><p>然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class SpringAmqpTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testSimpleQueue() &#123;</span><br><span class="line">        // 队列名称</span><br><span class="line">        String queueName = &quot;simple.queue&quot;;</span><br><span class="line">        // 消息</span><br><span class="line">        String message = &quot;hello, spring amqp!&quot;;</span><br><span class="line">        // 发送消息</span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-消息接收"><a href="#3-1-2-消息接收" class="headerlink" title="3.1.2.消息接收"></a>3.1.2.消息接收</h3><p>首先配置MQ地址，在consumer服务的application.yml中添加配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 192.168.150.101 # 主机名</span><br><span class="line">    port: 5672 # 端口</span><br><span class="line">    virtual-host: / # 虚拟主机</span><br><span class="line">    username: itcast # 用户名</span><br><span class="line">    password: 123321 # 密码</span><br></pre></td></tr></table></figure><p>然后在consumer服务的<code>cn.itcast.mq.listener</code>包中新建一个类SpringRabbitListener，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class SpringRabbitListener &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = &quot;simple.queue&quot;)</span><br><span class="line">    public void listenSimpleQueueMessage(String msg) throws InterruptedException &#123;</span><br><span class="line">        System.out.println(&quot;spring 消费者接收到消息：【&quot; + msg + &quot;】&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-3-测试"><a href="#3-1-3-测试" class="headerlink" title="3.1.3.测试"></a>3.1.3.测试</h3><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息</p><h2 id="3-2-WorkQueue"><a href="#3-2-WorkQueue" class="headerlink" title="3.2.WorkQueue"></a>3.2.WorkQueue</h2><p>Work queues，也被称为（Task queues），任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。</p><p><img src="/2022/05/11/RabbitMQ/image-20210717164238910.png"></p><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p><p>此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。</p><h3 id="3-2-1-消息发送"><a href="#3-2-1-消息发送" class="headerlink" title="3.2.1.消息发送"></a>3.2.1.消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。</p><p>在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * workQueue</span><br><span class="line">     * 向队列中不停发送消息，模拟消息堆积。</span><br><span class="line">     */</span><br><span class="line">@Test</span><br><span class="line">public void testWorkQueue() throws InterruptedException &#123;</span><br><span class="line">    // 队列名称</span><br><span class="line">    String queueName = &quot;simple.queue&quot;;</span><br><span class="line">    // 消息</span><br><span class="line">    String message = &quot;hello, message_&quot;;</span><br><span class="line">    for (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">        // 发送消息</span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">        Thread.sleep(20);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-消息接收"><a href="#3-2-2-消息接收" class="headerlink" title="3.2.2.消息接收"></a>3.2.2.消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;simple.queue&quot;)</span><br><span class="line">public void listenWorkQueue1(String msg) throws InterruptedException &#123;</span><br><span class="line">    System.out.println(&quot;消费者1接收到消息：【&quot; + msg + &quot;】&quot; + LocalTime.now());</span><br><span class="line">    Thread.sleep(20);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener(queues = &quot;simple.queue&quot;)</span><br><span class="line">public void listenWorkQueue2(String msg) throws InterruptedException &#123;</span><br><span class="line">    System.err.println(&quot;消费者2........接收到消息：【&quot; + msg + &quot;】&quot; + LocalTime.now());</span><br><span class="line">    Thread.sleep(200);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这个消费者sleep了1000秒，模拟任务耗时。</p><h3 id="3-2-3-测试"><a href="#3-2-3-测试" class="headerlink" title="3.2.3.测试"></a>3.2.3.测试</h3><p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。</p><p>可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。</p><p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。</p><h3 id="3-2-4-能者多劳"><a href="#3-2-4-能者多劳" class="headerlink" title="3.2.4.能者多劳"></a>3.2.4.能者多劳</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    listener:</span><br><span class="line">      simple:</span><br><span class="line">        prefetch: 1 # 每次只能获取一条消息，处理完成才能获取下一个消息</span><br></pre></td></tr></table></figure><h3 id="3-2-5-总结"><a href="#3-2-5-总结" class="headerlink" title="3.2.5.总结"></a>3.2.5.总结</h3><p>Work模型的使用：</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h2 id="3-3-发布-x2F-订阅"><a href="#3-3-发布-x2F-订阅" class="headerlink" title="3.3.发布&#x2F;订阅"></a>3.3.发布&#x2F;订阅</h2><p>发布订阅的模型如图：  </p><p><img src="/2022/05/11/RabbitMQ/image-20210717165309625.png"></p><p>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p><ul><li>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li><li>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：<ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li></ul></li><li>Consumer：消费者，与以前一样，订阅队列，没有变化</li><li>Queue：消息队列也与以前一样，接收消息、缓存消息。</li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><h2 id="3-4-Fanout"><a href="#3-4-Fanout" class="headerlink" title="3.4.Fanout"></a>3.4.Fanout</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。</p><p><img src="/2022/05/11/RabbitMQ/image-20210717165438225.png"></p><p>在广播模式下，消息发送流程是这样的：</p><ul><li>1）  可以有多个队列</li><li>2）  每个队列都要绑定到Exchange（交换机）</li><li>3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li><li>4）  交换机把消息发送给绑定过的所有队列</li><li>5）  订阅队列的消费者都能拿到消息</li></ul><p>我们的计划是这样的：</p><ul><li>创建一个交换机 itcast.fanout，类型是Fanout</li><li>创建两个队列fanout.queue1和fanout.queue2，绑定到交换机itcast.fanout</li></ul><p><img src="/2022/05/11/RabbitMQ/image-20210717165509466.png"></p><h3 id="3-4-1-声明队列和交换机"><a href="#3-4-1-声明队列和交换机" class="headerlink" title="3.4.1.声明队列和交换机"></a>3.4.1.声明队列和交换机</h3><p>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：</p><p><img src="/2022/05/11/RabbitMQ/image-20210717165552676.png"></p><p>在consumer中创建一个类，声明队列和交换机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import org.springframework.amqp.core.Binding;</span><br><span class="line">import org.springframework.amqp.core.BindingBuilder;</span><br><span class="line">import org.springframework.amqp.core.FanoutExchange;</span><br><span class="line">import org.springframework.amqp.core.Queue;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class FanoutConfig &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 声明交换机</span><br><span class="line">     * @return Fanout类型交换机</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public FanoutExchange fanoutExchange()&#123;</span><br><span class="line">        return new FanoutExchange(&quot;itcast.fanout&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 第1个队列</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue fanoutQueue1()&#123;</span><br><span class="line">        return new Queue(&quot;fanout.queue1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 绑定队列和交换机</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding bindingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange)&#123;</span><br><span class="line">        return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 第2个队列</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue fanoutQueue2()&#123;</span><br><span class="line">        return new Queue(&quot;fanout.queue2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 绑定队列和交换机</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding bindingQueue2(Queue fanoutQueue2, FanoutExchange fanoutExchange)&#123;</span><br><span class="line">        return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-2-消息发送"><a href="#3-4-2-消息发送" class="headerlink" title="3.4.2.消息发送"></a>3.4.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testFanoutExchange() &#123;</span><br><span class="line">    // 队列名称</span><br><span class="line">    String exchangeName = &quot;itcast.fanout&quot;;</span><br><span class="line">    // 消息</span><br><span class="line">    String message = &quot;hello, everyone!&quot;;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, &quot;&quot;, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-4-3-消息接收"><a href="#3-4-3-消息接收" class="headerlink" title="3.4.3.消息接收"></a>3.4.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span><br><span class="line">public void listenFanoutQueue1(String msg) &#123;</span><br><span class="line">    System.out.println(&quot;消费者1接收到Fanout消息：【&quot; + msg + &quot;】&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span><br><span class="line">public void listenFanoutQueue2(String msg) &#123;</span><br><span class="line">    System.out.println(&quot;消费者2接收到Fanout消息：【&quot; + msg + &quot;】&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>交换机的作用是什么？</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><p>声明队列、交换机、绑定关系的Bean是什么？</p><ul><li>Queue</li><li>FanoutExchange</li><li>Binding</li></ul><h2 id="3-5-Direct"><a href="#3-5-Direct" class="headerlink" title="3.5.Direct"></a>3.5.Direct</h2><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p><p><img src="/2022/05/11/RabbitMQ/image-20210717170041447.png"></p><p> 在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p><strong>案例需求如下</strong>：</p><ol><li>利用@RabbitListener声明Exchange、Queue、RoutingKey</li><li>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</li><li>在publisher中编写测试方法，向itcast. direct发送消息</li></ol><p><img src="/2022/05/11/RabbitMQ/image-20210717170223317.png"></p><h3 id="3-5-1-基于注解声明队列和交换机"><a href="#3-5-1-基于注解声明队列和交换机" class="headerlink" title="3.5.1.基于注解声明队列和交换机"></a>3.5.1.基于注解声明队列和交换机</h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p><p>在consumer的SpringRabbitListener中添加两个消费者，同时基于注解来声明队列和交换机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(bindings = @QueueBinding(</span><br><span class="line">    value = @Queue(name = &quot;direct.queue1&quot;),</span><br><span class="line">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span><br><span class="line">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span><br><span class="line">))</span><br><span class="line">public void listenDirectQueue1(String msg)&#123;</span><br><span class="line">    System.out.println(&quot;消费者接收到direct.queue1的消息：【&quot; + msg + &quot;】&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener(bindings = @QueueBinding(</span><br><span class="line">    value = @Queue(name = &quot;direct.queue2&quot;),</span><br><span class="line">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span><br><span class="line">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span><br><span class="line">))</span><br><span class="line">public void listenDirectQueue2(String msg)&#123;</span><br><span class="line">    System.out.println(&quot;消费者接收到direct.queue2的消息：【&quot; + msg + &quot;】&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-2-消息发送"><a href="#3-5-2-消息发送" class="headerlink" title="3.5.2.消息发送"></a>3.5.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSendDirectExchange() &#123;</span><br><span class="line">    // 交换机名称</span><br><span class="line">    String exchangeName = &quot;itcast.direct&quot;;</span><br><span class="line">    // 消息</span><br><span class="line">    String message = &quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;;</span><br><span class="line">    // 发送消息</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, &quot;red&quot;, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-3-总结"><a href="#3-5-3-总结" class="headerlink" title="3.5.3.总结"></a>3.5.3.总结</h3><p>描述下Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><p>基于@RabbitListener注解声明队列和交换机有哪些常见注解？</p><ul><li>@Queue</li><li>@Exchange</li></ul><h2 id="3-6-Topic"><a href="#3-6-Topic" class="headerlink" title="3.6.Topic"></a>3.6.Topic</h2><h3 id="3-6-1-说明"><a href="#3-6-1-说明" class="headerlink" title="3.6.1.说明"></a>3.6.1.说明</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p><p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p><p> 通配符规则：</p><p><code>#</code>：匹配一个或多个词</p><p><code>*</code>：匹配不多不少恰好1个词</p><p>举例：</p><p><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></p><p><code>item.*</code>：只能匹配<code>item.spu</code></p><p>​     </p><p>图示：</p><p> <img src="/2022/05/11/RabbitMQ/image-20210717170705380.png"></p><p>解释：</p><ul><li>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</li><li>Queue2：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</li></ul><p>案例需求：</p><p>实现思路如下：</p><ol><li>并利用@RabbitListener声明Exchange、Queue、RoutingKey</li><li>在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2</li><li>在publisher中编写测试方法，向itcast. topic发送消息</li></ol><p><img src="/2022/05/11/RabbitMQ/image-20210717170829229.png"></p><h3 id="3-6-2-消息发送"><a href="#3-6-2-消息发送" class="headerlink" title="3.6.2.消息发送"></a>3.6.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * topicExchange</span><br><span class="line">     */</span><br><span class="line">@Test</span><br><span class="line">public void testSendTopicExchange() &#123;</span><br><span class="line">    // 交换机名称</span><br><span class="line">    String exchangeName = &quot;itcast.topic&quot;;</span><br><span class="line">    // 消息</span><br><span class="line">    String message = &quot;喜报！孙悟空大战哥斯拉，胜!&quot;;</span><br><span class="line">    // 发送消息</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, &quot;china.news&quot;, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-3-消息接收"><a href="#3-6-3-消息接收" class="headerlink" title="3.6.3.消息接收"></a>3.6.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-4-总结"><a href="#3-6-4-总结" class="headerlink" title="3.6.4.总结"></a>3.6.4.总结</h3><p>描述下Direct交换机与Topic交换机的差异？</p><ul><li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li><code>#</code>：代表0个或多个词</li><li><code>*</code>：代表1个词</li></ul><h2 id="3-7-消息转换器"><a href="#3-7-消息转换器" class="headerlink" title="3.7.消息转换器"></a>3.7.消息转换器</h2><p>之前说过，Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p><p><img src="/2022/05/11/RabbitMQ/image-20200525170410401.png"></p><p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>我们来测试一下。</p><h3 id="3-7-1-测试默认转换器"><a href="#3-7-1-测试默认转换器" class="headerlink" title="3.7.1.测试默认转换器"></a>3.7.1.测试默认转换器</h3><p>我们修改消息发送的代码，发送一个Map对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSendMap() throws InterruptedException &#123;</span><br><span class="line">    // 准备消息</span><br><span class="line">    Map&lt;String,Object&gt; msg = new HashMap&lt;&gt;();</span><br><span class="line">    msg.put(&quot;name&quot;, &quot;Jack&quot;);</span><br><span class="line">    msg.put(&quot;age&quot;, 21);</span><br><span class="line">    // 发送消息</span><br><span class="line">    rabbitTemplate.convertAndSend(&quot;simple.queue&quot;,&quot;&quot;, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>停止consumer服务</p><p>发送消息后查看控制台：</p><p><img src="/2022/05/11/RabbitMQ/image-20210422232835363.png"></p><h3 id="3-7-2-配置JSON转换器"><a href="#3-7-2-配置JSON转换器" class="headerlink" title="3.7.2.配置JSON转换器"></a>3.7.2.配置JSON转换器</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p><p>在publisher和consumer两个服务中都引入依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置消息转换器。</p><p>在启动类中添加一个Bean即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public MessageConverter jsonMessageConverter()&#123;</span><br><span class="line">    return new Jackson2JsonMessageConverter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ部署指南</title>
      <link href="/2022/05/11/RabbitMQ%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/"/>
      <url>/2022/05/11/RabbitMQ%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ部署指南"><a href="#RabbitMQ部署指南" class="headerlink" title="RabbitMQ部署指南"></a>RabbitMQ部署指南</h1><h1 id="1-单机部署"><a href="#1-单机部署" class="headerlink" title="1.单机部署"></a>1.单机部署</h1><p>我们在Centos7虚拟机中使用Docker来安装。</p><h2 id="1-1-下载镜像"><a href="#1-1-下载镜像" class="headerlink" title="1.1.下载镜像"></a>1.1.下载镜像</h2><p>方式一：在线拉取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:3-management</span><br></pre></td></tr></table></figure><p>上传到虚拟机中后，使用命令加载镜像即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i mq.tar</span><br></pre></td></tr></table></figure><h2 id="1-2-安装MQ"><a href="#1-2-安装MQ" class="headerlink" title="1.2.安装MQ"></a>1.2.安装MQ</h2><p>执行下面的命令来运行MQ容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=itcast \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq1 \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3-management</span><br></pre></td></tr></table></figure><h1 id="2-集群部署"><a href="#2-集群部署" class="headerlink" title="2.集群部署"></a>2.集群部署</h1><p>接下来，我们看看如何安装RabbitMQ的集群。</p><h2 id="2-1-集群分类"><a href="#2-1-集群分类" class="headerlink" title="2.1.集群分类"></a>2.1.集群分类</h2><p>在RabbitMQ的官方文档中，讲述了两种集群的配置方式：</p><ul><li>普通模式：普通模式集群不进行数据同步，每个MQ都有自己的队列、数据信息（其它元数据信息如交换机等会同步）。例如我们有2个MQ：mq1，和mq2，如果你的消息在mq1，而你连接到了mq2，那么mq2会去mq1拉取消息，然后返回给你。如果mq1宕机，消息就会丢失。</li><li>镜像模式：与普通模式不同，队列会在各个mq的镜像节点之间同步，因此你连接到任何一个镜像节点，均可获取到消息。而且如果一个节点宕机，并不会导致数据丢失。不过，这种方式增加了数据同步的带宽消耗。</li></ul><p>我们先来看普通模式集群。</p><h2 id="2-2-设置网络"><a href="#2-2-设置网络" class="headerlink" title="2.2.设置网络"></a>2.2.设置网络</h2><p>首先，我们需要让3台MQ互相知道对方的存在。</p><p>分别在3台机器中，设置 &#x2F;etc&#x2F;hosts文件，添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.150.101 mq1</span><br><span class="line">192.168.150.102 mq2</span><br><span class="line">192.168.150.103 mq3</span><br></pre></td></tr></table></figure><p>并在每台机器上测试，是否可以ping通对方：</p>]]></content>
      
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker基本操作命令</title>
      <link href="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="1-docker操作"><a href="#1-docker操作" class="headerlink" title="1.docker操作"></a>1.docker操作</h1><h2 id="1-1-镜像操作"><a href="#1-1-镜像操作" class="headerlink" title="1.1.镜像操作"></a>1.1.镜像操作</h2><h3 id="1-1-1-镜像名称"><a href="#1-1-1-镜像名称" class="headerlink" title="1.1.1. 镜像名称"></a>1.1.1. 镜像名称</h3><p>镜名称两部分组成：[repository]:[tag]。</p><p>没有指定tag时，默认是latest，代表最新版本的镜像</p><p> 如图：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731155141362.png"></p><p>mysql就是repository，5.7就是tag，</p><h3 id="1-1-2-镜像命令"><a href="#1-1-2-镜像命令" class="headerlink" title="1.1.2. 镜像命令"></a>1.1.2. 镜像命令</h3><p>常见的镜像操作命令</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731155649535.png"></p><h4 id="拉取镜像："><a href="#拉取镜像：" class="headerlink" title="拉取镜像："></a>拉取镜像：</h4><p>1、去镜像镜像仓库中搜索镜像，如DockerHub：</p><p>2、查看镜像名称，例如nginx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731155856199.png"></p><p>3、查看镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731155903037.png"></p><h4 id="保存，导入镜像"><a href="#保存，导入镜像" class="headerlink" title="保存，导入镜像"></a>保存，导入镜像</h4><p>利用 docker xx –help 命令查看docker save和docker load的语法</p><p>1、查看save命令语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save --help</span><br></pre></td></tr></table></figure><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731161104732.png"></p><p>保存（导出）命令格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o [保存的目标文件名称][镜像名称]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o nginx.tar nginx:latest</span><br></pre></td></tr></table></figure><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731161354344.png"></p><p>加载镜像：</p><p>1、删除镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi nginx:latest</span><br></pre></td></tr></table></figure><p>2、加载本地文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load i nginx.tar</span><br></pre></td></tr></table></figure><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731161746245.png"></p><h1 id="2-容器操作"><a href="#2-容器操作" class="headerlink" title="2.容器操作"></a>2.容器操作</h1><h2 id="2-1-容器相关命令"><a href="#2-1-容器相关命令" class="headerlink" title="2.1.容器相关命令"></a>2.1.容器相关命令</h2><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731161950495.png"></p><p>容器三个状态：</p><ul><li>运行</li><li>暂停：进程暂停，CPU不再运行，不释放内存</li><li>停止：进程终止，回收进程占用的内存，CPU等资源</li></ul><p>其中：</p><ul><li>docker run：创建并运行一个容器，处于运行状态</li><li>docker pause：让一个运行的容器暂停</li><li>docker unpause：让一个容器从暂停状态恢复运行</li><li>docker stop：停止一个运行的容器</li><li>docker start：让一个停止的容器再次运行</li><li>docker rm：删除一个容器，不能删除运行中的容器，除非添加 -f 参数</li></ul><h2 id="2-2-创建并运行容器"><a href="#2-2-创建并运行容器" class="headerlink" title="2.2.创建并运行容器"></a>2.2.创建并运行容器</h2><p>创建并运行nginx容器，处于运行状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name containerName -p 80:80 -d nginx</span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li><p>docker run ：创建并运行一个容器</p></li><li><p>–name : 给容器起一个名字，比如叫做mn</p></li><li><p>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</p></li><li><p>-d：后台运行容器</p></li><li><p>nginx：镜像名称，例如nginx</p></li></ul><h2 id="2-3-进入容器，修改文件（不建议）"><a href="#2-3-进入容器，修改文件（不建议）" class="headerlink" title="2.3.进入容器，修改文件（不建议）"></a>2.3.进入容器，修改文件（不建议）</h2><p>1）进入容器。进入我们刚刚创建的nginx容器的命令为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mn bash</span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li>docker exec ：进入容器内部，执行一个命令</li><li>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</li><li>mn ：要进入的容器的名称</li><li>bash：进入容器后执行的命令，bash是一个linux终端交互命令</li></ul><p>2）进入nginx的HTML所在目录 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</p><p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731164159811.png"></p><p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p><p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在<code>/usr/share/nginx/html</code></p><p>我们执行命令，进入该目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/nginx/html</span><br></pre></td></tr></table></figure><p> 查看目录下文件：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731164455818.png"></p><p>3）修改index.html的内容</p><p>容器内没有vi命令，无法直接修改，我们用下面的命令来修改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e <span class="string">&#x27;s#Hello world#g&#x27;</span> -e <span class="string">&#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#x27;</span> index.html</span><br></pre></td></tr></table></figure><h2 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4.小结"></a>2.4.小结</h2><p>docker run命令常用参数有哪些？</p><ul><li>–name：指定容器名称</li><li>-p：指定端口映射</li><li>-d：后台运行</li></ul><p>查看容器日志命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs</span><br></pre></td></tr></table></figure><p>添加 -f 参数可以持续查看日志</p><p>查看容器状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a #查看所有容器，包括已停止的</span><br></pre></td></tr></table></figure><h1 id="3-数据卷操作"><a href="#3-数据卷操作" class="headerlink" title="3.数据卷操作"></a>3.数据卷操作</h1><h2 id="3-1-数据卷定义"><a href="#3-1-数据卷定义" class="headerlink" title="3.1.数据卷定义"></a>3.1.数据卷定义</h2><p><strong>数据卷（volume）</strong>是一个虚拟目录，指向宿主机文件系统中的某个目录。</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731173541846.png"></p><p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p><p>这样，我们操作宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html目录，就等于操作容器内的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html目录了</p><h2 id="3-2-数据卷操作命令"><a href="#3-2-数据卷操作命令" class="headerlink" title="3.2.数据卷操作命令"></a>3.2.数据卷操作命令</h2><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume [COMMAND]</span><br></pre></td></tr></table></figure><p>docker volume 命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p><ul><li>create 创建一个volume</li><li>inspect 显示一个或者多个volume的信息</li><li>ls 列出所有的volume</li><li>prune 删除一个或者多个指定的volume</li><li>rm 删除一个或者多个指定的volume</li></ul><h2 id="3-3-创建和查看数据卷"><a href="#3-3-创建和查看数据卷" class="headerlink" title="3.3.创建和查看数据卷"></a>3.3.创建和查看数据卷</h2><p>创建数据卷</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create thml</span><br></pre></td></tr></table></figure><p>查看所有数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731173746910.png"></p><p>查看数据卷详细信息卷</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect html</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731173809877.png"></p><p>可以看到，我们创建的html这个数据卷关联的宿主机目录为<code>/var/lib/docker/volumes/html/_data</code>目录。</p><h2 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4.小结"></a>3.4.小结</h2><p>数据卷作用：</p><p>将容器与数据分离、解耦合，方便操作容器内的数据，保证数据安全</p><p>数据卷操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create   #创建数据卷</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls   #查看所有数据卷</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect   #查看数据卷详细信息，包括关联的宿主机目录位置</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm #删除指定数据卷</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume prune  #删除所有未使用的数据卷</span><br></pre></td></tr></table></figure><h2 id="3-5-挂载数据卷"><a href="#3-5-挂载数据卷" class="headerlink" title="3.5.挂载数据卷"></a>3.5.挂载数据卷</h2><p>我们在创建容器时，可以通过-v参数来挂载一个数据卷到某个容器内目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">--name mn \</span><br><span class="line">-v html:/root/html \</span><br><span class="line">-p 8080:80</span><br><span class="line">-d \</span><br><span class="line">nginx \</span><br></pre></td></tr></table></figure><h2 id="3-6-挂载目录"><a href="#3-6-挂载目录" class="headerlink" title="3.6.挂载目录"></a>3.6.挂载目录</h2><p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p><ul><li>带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录</li><li>直接挂载模式：宿主机目录 —&gt; 容器内目录</li></ul><p>如图：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731175155453.png"></p><p><strong>语法</strong>：</p><p>目录挂载与数据卷挂载的语法是类似的：</p><ul><li>-v [宿主机目录]:[容器内目录]</li><li>-v [宿主机文件]:[容器内文件]</li></ul><p>创建并运行一个MySQL容器，将宿主机目录直接挂载到容器</p><p>实现思路如下：</p><p>1）将mysql.tar文件上传到虚拟机，通过load命令加载为镜像</p><p>2）创建目录&#x2F;tmp&#x2F;mysql&#x2F;data</p><p>3）创建目录&#x2F;tmp&#x2F;mysql&#x2F;conf，将mysql配置文件hmy.cnf文件上传到&#x2F;tmp&#x2F;mysql&#x2F;conf</p><p>4）去DockerHub查阅资料，创建并运行MySQL容器，要求：</p><p>① 挂载&#x2F;tmp&#x2F;mysql&#x2F;data到mysql容器内数据存储目录</p><p>② 挂载&#x2F;tmp&#x2F;mysql&#x2F;conf&#x2F;hmy.cnf到mysql容器的配置文件</p><p>③ 设置MySQL密码</p><h2 id="3-7-小结"><a href="#3-7-小结" class="headerlink" title="3.7.小结"></a>3.7.小结</h2><p>docker run的命令中通过 -v 参数挂载文件或目录到容器中：</p><ul><li>-v volume名称:容器内目录</li><li>-v 宿主机文件:容器内文</li><li>-v 宿主机目录:容器内目录</li></ul><p>数据卷挂载与目录直接挂载的</p><ul><li>数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</li><li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li></ul><h1 id="4-Dockerfile自定义镜像"><a href="#4-Dockerfile自定义镜像" class="headerlink" title="4.Dockerfile自定义镜像"></a>4.Dockerfile自定义镜像</h1><p>常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p><p>而要自定义镜像，就必须先了解镜像的结构才行。</p><h2 id="4-1-镜像结构"><a href="#4-1-镜像结构" class="headerlink" title="4.1.镜像结构"></a>4.1.镜像结构</h2><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p><p>我们以MySQL为例，来看看镜像的组成结构：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731175806273.png"></p><p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p><p>我们要构建镜像，其实就是实现上述打包的过程。</p><h2 id="4-2-Dockerfile语法"><a href="#4-2-Dockerfile语法" class="headerlink" title="4.2.Dockerfile语法"></a>4.2.Dockerfile语法</h2><p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p><p>我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。</p><p>而描述上述信息的文件就是Dockerfile文件。</p><p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731180321133.png"></p><p>更新详细语法说明，请参考官网文档： <a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p><h2 id="4-3-构建Java项目"><a href="#4-3-构建Java项目" class="headerlink" title="4.3.构建Java项目"></a>4.3.构建Java项目</h2><h3 id="4-3-1-基于Ubuntu构建Java项目"><a href="#4-3-1-基于Ubuntu构建Java项目" class="headerlink" title="4.3.1.基于Ubuntu构建Java项目"></a>4.3.1.基于Ubuntu构建Java项目</h3><p>需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目</p><ul><li><p>步骤1：新建一个空文件夹docker-demo</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210801101207444.png"></p></li><li><p>步骤2：将docker-demo.jar文件到docker-demo这个目录</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210801101314816.png"></p></li><li><p>步骤3：拷贝jdk8.tar.gz文件到docker-demo这个目录</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210801101410200.png"></p></li><li><p>步骤4：拷贝Dockerfile到docker-demo这个目录</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210801101455590.png"></p><p>其中的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 指定基础镜像</span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line"># 配置环境变量，JDK的安装目录</span><br><span class="line">ENV JAVA_DIR=/usr/local</span><br><span class="line"></span><br><span class="line"># 拷贝jdk和java项目的包</span><br><span class="line">COPY ./jdk8.tar.gz $JAVA_DIR/</span><br><span class="line">COPY ./docker-demo.jar /tmp/app.jar</span><br><span class="line"></span><br><span class="line"># 安装JDK</span><br><span class="line">RUN cd $JAVA_DIR \</span><br><span class="line"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span><br><span class="line"> &amp;&amp; mv ./jdk1.8.0_144 ./java8</span><br><span class="line"></span><br><span class="line"># 配置环境变量</span><br><span class="line">ENV JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line">ENV PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line"># 暴露端口</span><br><span class="line">EXPOSE 8090</span><br><span class="line"># 入口，java项目的启动命令</span><br><span class="line">ENTRYPOINT java -jar /tmp/app.jar</span><br></pre></td></tr></table></figure></li><li><p>步骤5：进入docker-demo</p><p>将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下</p></li><li><p>步骤6：运行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t javaweb:1.0 .</span><br></pre></td></tr></table></figure></li></ul><p>最后访问 <a href="http://192.168.150.101:8090/hello/count%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84ip%E6%94%B9%E6%88%90%E4%BD%A0%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BAip">http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip</a></p><h3 id="4-4-基于java8构建Java项目"><a href="#4-4-基于java8构建Java项目" class="headerlink" title="4.4.基于java8构建Java项目"></a>4.4.基于java8构建Java项目</h3><p>虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p><p>例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。</p><p>需求：基于java:8-alpine镜像，将一个Java项目构建为镜像</p><p>实现思路如下：</p><ul><li><p>① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile</p></li><li><p>② 拷贝课前资料提供的docker-demo.jar到这个目录中</p></li><li><p>③ 编写Dockerfile文件：</p><p>a ）基于java:8-alpine作为基础镜像</p><p>b ）将app.jar拷贝到镜像中</p><p>c ）暴露端口</p><p>d ）编写入口ENTRYPOINT</p><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM java:8-alpine</span><br><span class="line">COPY ./app.jar /tmp/app.jar</span><br><span class="line">EXPOSE 8090</span><br><span class="line">ENTRYPOINT java -jar /tmp/app.jar</span><br></pre></td></tr></table></figure></li><li><p>④ 使用docker build命令构建镜像</p></li><li><p>⑤ 使用docker run创建容器并运行</p></li></ul><h2 id="4-5-小结"><a href="#4-5-小结" class="headerlink" title="4.5.小结"></a>4.5.小结</h2><p>小结：</p><ol><li>Dockerfile的本质是一个文件，通过指令描述镜像的构建过程</li><li>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</li><li>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</li></ol><h1 id="5-Docker-Compose"><a href="#5-Docker-Compose" class="headerlink" title="5.Docker-Compose"></a>5.Docker-Compose</h1><p>Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p><h2 id="5-1-初识DockerCompose"><a href="#5-1-初识DockerCompose" class="headerlink" title="5.1.初识DockerCompose"></a>5.1.初识DockerCompose</h2><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.8&quot;</span><br><span class="line"> services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:5.7.25</span><br><span class="line">    environment:</span><br><span class="line">     MYSQL_ROOT_PASSWORD: 123 </span><br><span class="line">    volumes:</span><br><span class="line">     - &quot;/tmp/mysql/data:/var/lib/mysql&quot;</span><br><span class="line">     - &quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">     - &quot;8090:8090&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的Compose文件就描述一个项目，其中包含两个容器：</p><ul><li>mysql：一个基于<code>mysql:5.7.25</code>镜像构建的容器，并且挂载了两个目录</li><li>web：一个基于<code>docker build</code>临时构建的镜像容器，映射端口时8090</li></ul><p>DockerCompose的详细语法参考官网：<a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p><p>其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。</p><h2 id="5-2-安装DockerCompose"><a href="#5-2-安装DockerCompose" class="headerlink" title="5.2.安装DockerCompose"></a>5.2.安装DockerCompose</h2><p>参考Centos7安装docker博客</p><h2 id="4-3-部署微服务集群"><a href="#4-3-部署微服务集群" class="headerlink" title="4.3.部署微服务集群"></a>4.3.部署微服务集群</h2><p><strong>需求</strong>：将之前学习的cloud-demo微服务集群利用DockerCompose部署</p><p><strong>实现思路</strong>：</p><p>① 查看cloud-demo文件夹，里面已经编写好了docker-compose文件</p><p>② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名</p><p>③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar</p><p>④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中</p><p>⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署</p><h3 id="4-3-1-compose文件"><a href="#4-3-1-compose文件" class="headerlink" title="4.3.1.compose文件"></a>4.3.1.compose文件</h3><p>查看cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731181341330.png"></p><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.2&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  nacos:</span><br><span class="line">    image: nacos/nacos-server</span><br><span class="line">    environment:</span><br><span class="line">      MODE: standalone</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8848:8848&quot;</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:5.7.25</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: 123</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;$PWD/mysql/data:/var/lib/mysql&quot;</span><br><span class="line">      - &quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;</span><br><span class="line">  userservice:</span><br><span class="line">    build: ./user-service</span><br><span class="line">  orderservice:</span><br><span class="line">    build: ./order-service</span><br><span class="line">  gateway:</span><br><span class="line">    build: ./gateway</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;10010:10010&quot;</span><br></pre></td></tr></table></figure><p>可以看到，其中包含5个service服务：</p><ul><li><code>nacos</code>：作为注册中心和配置中心<ul><li><code>image: nacos/nacos-server</code>： 基于nacos&#x2F;nacos-server镜像构建</li><li><code>environment</code>：环境变量<ul><li><code>MODE: standalone</code>：单点模式启动</li></ul></li><li><code>ports</code>：端口映射，这里暴露了8848端口</li></ul></li><li><code>mysql</code>：数据库<ul><li><code>image: mysql:5.7.25</code>：镜像版本是mysql:5.7.25</li><li><code>environment</code>：环境变量<ul><li><code>MYSQL_ROOT_PASSWORD: 123</code>：设置数据库root账户的密码为123</li></ul></li><li><code>volumes</code>：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据</li></ul></li><li><code>userservice</code>、<code>orderservice</code>、<code>gateway</code>：都是基于Dockerfile临时构建的</li></ul><p>查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210801095205034.png"></p><p>查看微服务目录，可以看到都包含Dockerfile文件：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210801095320586.png"></p><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM java:8-alpine</span><br><span class="line">COPY ./app.jar /tmp/app.jar</span><br><span class="line">ENTRYPOINT java -jar /tmp/app.jar</span><br></pre></td></tr></table></figure><h3 id="4-3-2-修改微服务配置"><a href="#4-3-2-修改微服务配置" class="headerlink" title="4.3.2.修改微服务配置"></a>4.3.2.修改微服务配置</h3><p>因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。</p><p>如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://mysql:3306/cloud_order?useSSL=false</span><br><span class="line">    username: root</span><br><span class="line">    password: 123</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">  application:</span><br><span class="line">    name: orderservice</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: nacos:8848 # nacos服务地址</span><br></pre></td></tr></table></figure><h3 id="4-3-3-打包"><a href="#4-3-3-打包" class="headerlink" title="4.3.3.打包"></a>4.3.3.打包</h3><p>接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。</p><p>可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;!-- 服务打包的最终名称 --&gt;</span><br><span class="line">  &lt;finalName&gt;app&lt;/finalName&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>打包后：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210801095951030.png"></p><h3 id="4-3-4-拷贝jar包到部署目录"><a href="#4-3-4-拷贝jar包到部署目录" class="headerlink" title="4.3.4.拷贝jar包到部署目录"></a>4.3.4.拷贝jar包到部署目录</h3><p>编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。</p><p>user-service：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210801100201253.png"></p><p>order-service：</p><p>同理</p><p>gateway：</p><p>同理</p><h3 id="4-3-5-部署"><a href="#4-3-5-部署" class="headerlink" title="4.3.5.部署"></a>4.3.5.部署</h3><p>最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，理由DockerCompose部署。</p><p>上传到任意目录：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210801100955653.png"></p><p>部署：</p><p>进入cloud-demo目录，然后运行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h1 id="5-Docker镜像仓库"><a href="#5-Docker镜像仓库" class="headerlink" title="5.Docker镜像仓库"></a>5.Docker镜像仓库</h1><h2 id="5-1-搭建私有镜像仓库"><a href="#5-1-搭建私有镜像仓库" class="headerlink" title="5.1.搭建私有镜像仓库"></a>5.1.搭建私有镜像仓库</h2><p>参考博客《CentOS7安装Docker.md》</p><h2 id="5-2-推送、拉取镜像"><a href="#5-2-推送、拉取镜像" class="headerlink" title="5.2.推送、拉取镜像"></a>5.2.推送、拉取镜像</h2><p>推送镜像到私有镜像服务必须先tag，步骤如下：</p><p>① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080&#x2F;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure><p>② 推送镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure><p>③ 拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7安装Docker</title>
      <link href="/2022/05/10/Centos7%E5%AE%89%E8%A3%85Docker/"/>
      <url>/2022/05/10/Centos7%E5%AE%89%E8%A3%85Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>Docker CE 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p><p>官方网站上有各种环境下的 <a href="https://docs.docker.com/install/">安装指南</a>，这里主要介绍 Docker CE 在 CentOS上的安装。</p><h1 id="1-CentOS安装Docker"><a href="#1-CentOS安装Docker" class="headerlink" title="1.CentOS安装Docker"></a>1.CentOS安装Docker</h1><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。</p><h2 id="1-1-卸载（可选）"><a href="#1-1-卸载（可选）" class="headerlink" title="1.1.卸载（可选）"></a>1.1.卸载（可选）</h2><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine \</span><br><span class="line">                  docker-ce</span><br></pre></td></tr></table></figure><h2 id="1-2-安装docker"><a href="#1-2-安装docker" class="headerlink" title="1.2.安装docker"></a>1.2.安装docker</h2><p>首先需要大家虚拟机联网，安装yum工具</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2 --skip-broken</span><br></pre></td></tr></table></figure><p>然后更新本地镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置docker镜像源</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line">sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><p>然后输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure><p>docker-ce为社区免费版本。稍等片刻，docker即可安装成功。</p><h2 id="1-3-启动docker"><a href="#1-3-启动docker" class="headerlink" title="1.3.启动docker"></a>1.3.启动docker</h2><p>Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！</p><p>启动docker前，一定要关闭防火墙后！！</p><p>启动docker前，一定要关闭防火墙后！！</p><p>启动docker前，一定要关闭防火墙后！！</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment"># 禁止开机启动防火墙</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><p>通过命令启动docker：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker  <span class="comment"># 启动docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl stop docker  <span class="comment"># 停止docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl restart docker  <span class="comment"># 重启docker服务</span></span><br></pre></td></tr></table></figure><p>然后输入命令，可以查看docker版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="/2022/05/10/Centos7%E5%AE%89%E8%A3%85Docker/image-20210418154704436.png"> </p><h2 id="1-4-配置镜像加速"><a href="#1-4-配置镜像加速" class="headerlink" title="1.4.配置镜像加速"></a>1.4.配置镜像加速</h2><p>docker官方镜像仓库网速较差，我们需要设置国内镜像服务：</p><p>参考阿里云的镜像加速文档：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p><h1 id="2-CentOS7安装DockerCompose"><a href="#2-CentOS7安装DockerCompose" class="headerlink" title="2.CentOS7安装DockerCompose"></a>2.CentOS7安装DockerCompose</h1><h2 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1.下载"></a>2.1.下载</h2><p>Linux下需要通过命令下载：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`<span class="built_in">uname</span> -s`-`<span class="built_in">uname</span> -m` &gt; /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>如果下载速度较慢，或者下载失败，可以使用资料提供的docker-compose文件：</p><p>上传到<code>/usr/local/bin/</code>目录也可以。</p><h2 id="2-2-修改文件权限"><a href="#2-2-修改文件权限" class="headerlink" title="2.2.修改文件权限"></a>2.2.修改文件权限</h2><p>修改文件权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h2 id="2-3-Base自动补全命令："><a href="#2-3-Base自动补全命令：" class="headerlink" title="2.3.Base自动补全命令："></a>2.3.Base自动补全命令：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 补全命令</span><br><span class="line">curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure><p>如果这里出现错误，需要修改自己的hosts文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;199.232.68.133 raw.githubusercontent.com&quot;</span> &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><h1 id="3-Docker镜像仓库"><a href="#3-Docker镜像仓库" class="headerlink" title="3.Docker镜像仓库"></a>3.Docker镜像仓库</h1><p>搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。</p><p>官网地址：<a href="https://hub.docker.com/_/registry">https://hub.docker.com/_/registry</a></p><h2 id="3-1-简化版镜像仓库"><a href="#3-1-简化版镜像仓库" class="headerlink" title="3.1.简化版镜像仓库"></a>3.1.简化版镜像仓库</h2><p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p><p>搭建方式比较简单，命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --restart=always \</span><br><span class="line">    --name registry\</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v registry-data:/var/lib/registry \</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure><p>命令中挂载了一个数据卷registry-data到容器内的&#x2F;var&#x2F;lib&#x2F;registry 目录，这是私有镜像库存放数据的目录。</p><p>访问<a href="http://yourip:5000/v2/_catalog">http://YourIp:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p><h2 id="3-2-配置Docker信任地址"><a href="#3-2-配置Docker信任地址" class="headerlink" title="3.2.配置Docker信任地址"></a>3.2.配置Docker信任地址</h2><p>我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开要修改的文件</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="comment"># 添加内容：</span></span><br><span class="line"><span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;http://192.168.150.101:8080&quot;</span>]</span><br><span class="line"><span class="comment"># 重加载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="3-3-带有图形化界面版本"><a href="#3-3-带有图形化界面版本" class="headerlink" title="3.3.带有图形化界面版本"></a>3.3.带有图形化界面版本</h2><p>新建文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir registry-ui</span><br></pre></td></tr></table></figure><p>进入文件夹新建yml文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd registry-ui/</span><br><span class="line">ll</span><br><span class="line">touch docker-compose.yml</span><br></pre></td></tr></table></figure><p>编辑docker-compose.yml文件</p><p>使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3.0&#x27;</span><br><span class="line">services:</span><br><span class="line">  registry:</span><br><span class="line">    image: registry</span><br><span class="line">    volumes:</span><br><span class="line">      - ./registry-data:/var/lib/registry</span><br><span class="line">  ui:</span><br><span class="line">    image: joxit/docker-registry-ui:static</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:80</span><br><span class="line">    environment:</span><br><span class="line">      - REGISTRY_TITLE=MyOceanus私有仓库</span><br><span class="line">      - REGISTRY_URL=http://registry:5000</span><br><span class="line">    depends_on:</span><br><span class="line">      - registry</span><br></pre></td></tr></table></figure><p>执行docker-compose文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>查看日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs -f</span><br></pre></td></tr></table></figure><p>在私有镜像仓库推送或者拉取镜像</p><p>推送tag本地镜像，名称前缀为私有仓库的地址：192.168.25.128:8080&#x2F;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:latest 192.168.25.128:8080/nginx:1.0</span><br></pre></td></tr></table></figure><p>推送镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.25.128:8080/nginx:1.0</span><br></pre></td></tr></table></figure><p>拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 192.168.25.128:8080/nginx:1.0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos安装</title>
      <link href="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/"/>
      <url>/2022/05/09/Nacos%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Nacos安装指南"><a href="#Nacos安装指南" class="headerlink" title="Nacos安装指南"></a>Nacos安装指南</h1><h1 id="1-Windows安装"><a href="#1-Windows安装" class="headerlink" title="1.Windows安装"></a>1.Windows安装</h1><p>开发阶段采用单机安装即可。</p><h2 id="1-1-下载安装包"><a href="#1-1-下载安装包" class="headerlink" title="1.1.下载安装包"></a>1.1.下载安装包</h2><p>在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：</p><p>GitHub主页：<a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></p><p>GitHub的Release下载页：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><p>如图：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402161102887.png"></p><p>采用1.4.1.版本的Nacos</p><p>windows版本使用<code>nacos-server-1.4.1.zip</code>包即可。</p><h2 id="1-2-解压"><a href="#1-2-解压" class="headerlink" title="1.2.解压"></a>1.2.解压</h2><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402161843337.png"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><h2 id="1-3-端口配置"><a href="#1-3-端口配置" class="headerlink" title="1.3.端口配置"></a>1.3.端口配置</h2><p>Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。</p><p><strong>如果无法关闭占用8848端口的进程</strong>，也可以进入nacos的conf目录，修改配置文件中的端口：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402162008280.png"></p><p>修改其中的内容：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402162251093.png"></p><h2 id="1-4-启动"><a href="#1-4-启动" class="headerlink" title="1.4.启动"></a>1.4.启动</h2><p>启动非常简单，进入bin目录，结构如下：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402162350977.png"></p><p>然后执行命令即可：</p><ul><li><p>windows命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure></li></ul><p>执行后的效果如图：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402162526774.png"></p><h2 id="1-5-访问"><a href="#1-5-访问" class="headerlink" title="1.5.访问"></a>1.5.访问</h2><p>在浏览器输入地址：<a href="http://127.0.0.1:8848/nacos%E5%8D%B3%E5%8F%AF%EF%BC%9A">http://127.0.0.1:8848/nacos即可：</a></p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402162630427.png"></p><p>默认的账号和密码都是nacos，进入后：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402162709515.png"></p><h1 id="2-Linux安装"><a href="#2-Linux安装" class="headerlink" title="2.Linux安装"></a>2.Linux安装</h1><p>Linux或者Mac安装方式与Windows类似。</p><h2 id="2-1-安装JDK"><a href="#2-1-安装JDK" class="headerlink" title="2.1.安装JDK"></a>2.1.安装JDK</h2><p>Nacos依赖于JDK运行，索引Linux上也需要安装JDK才行。</p><p>上传jdk安装包：</p><p>上传到某个目录，例如：<code>/usr/local/</code></p><p>然后解压缩：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf jdk-8u144-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>然后重命名为java</p><p>配置环境变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/local/java</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure><p>设置环境变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h2 id="2-2-上传安装包"><a href="#2-2-上传安装包" class="headerlink" title="2.2.上传安装包"></a>2.2.上传安装包</h2><p>如图：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402161102887.png"></p><p>也可以直接使用资料中的tar.gz：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402161130261.png"></p><p>上传到Linux服务器的某个目录，例如<code>/usr/local/src</code>目录下：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402163715580.png"></p><h2 id="2-3-解压"><a href="#2-3-解压" class="headerlink" title="2.3.解压"></a>2.3.解压</h2><p>命令解压缩安装包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf nacos-server-1.4.1.tar.gz</span><br></pre></td></tr></table></figure><p>然后删除安装包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf nacos-server-1.4.1.tar.gz</span><br></pre></td></tr></table></figure><p>目录中最终样式：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402163858429.png"></p><p>目录内部：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402164414827.png"></p><h2 id="2-4-端口配置"><a href="#2-4-端口配置" class="headerlink" title="2.4.端口配置"></a>2.4.端口配置</h2><p>与windows中类似</p><h2 id="2-5-启动"><a href="#2-5-启动" class="headerlink" title="2.5.启动"></a>2.5.启动</h2><p>在nacos&#x2F;bin目录中，输入命令启动Nacos：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh startup.sh -m standalone</span><br></pre></td></tr></table></figure><h1 id="3-Nacos的依赖"><a href="#3-Nacos的依赖" class="headerlink" title="3.Nacos的依赖"></a>3.Nacos的依赖</h1><p>父工程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos客户端依赖包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker安装常用镜像</title>
      <link href="/2022/04/24/docker%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E9%95%9C%E5%83%8F/"/>
      <url>/2022/04/24/docker%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="安装常用镜像"><a href="#安装常用镜像" class="headerlink" title="安装常用镜像"></a>安装常用镜像</h1><h2 id="安装-mysql"><a href="#安装-mysql" class="headerlink" title="安装 mysql"></a>安装 mysql</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:8.0</span><br></pre></td></tr></table></figure><h2 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h2><p>设置时区和宿主机相同启动，启动镜像名称为 mysql，前面一个端口是映射端口，root是数据库密码， -v &#x2F;etc&#x2F;localtime:&#x2F;etc&#x2F;localtime是设置时区与宿主机一致，&#x2F;data&#x2F;docker&#x2F;mysql 是宿主机目录用来保存 mysql 的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql -p 3306:3306  -e MYSQL_ROOT_PASSWORD=123456 -v /etc/localtime:/etc/localtime  -v /data/docker/mysql:/var/lib/mysql -d mysql:8.0</span><br></pre></td></tr></table></figure><h2 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull reids:5.0.4</span><br></pre></td></tr></table></figure><p>启动镜像名称为 redis，前面一个端口是映射端口，&#x2F;data&#x2F;docker&#x2F;redis是宿主机数据保存地址 ，appendonly yes是后台启动，<strong>requirepass “root”</strong>是设置密码为root</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 -v /data/docker/redis:/data -d redis:5.0.4 redis-server --appendonly yes --requirepass &quot;root&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start redis</span><br></pre></td></tr></table></figure><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><h2 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h2><p><img src="/2022/04/24/docker%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E9%95%9C%E5%83%8F/1650806080538.png" alt="1650806080538"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux_docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装docker</title>
      <link href="/2022/04/24/Linux%E5%AE%89%E8%A3%85docker/"/>
      <url>/2022/04/24/Linux%E5%AE%89%E8%A3%85docker/</url>
      
        <content type="html"><![CDATA[<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>Docker 两个分支Docker： CE 即社区免费版，Docker EE 即企业版，需付费<br>官方建议要 CentOS7.0 及以上系统版本<br>运行CentOS 6.5及以后版本时，需要内核版本&gt;&#x3D;2.6.32-431</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><p><img src="/2022/04/24/Linux%E5%AE%89%E8%A3%85docker/1650799097982.png" alt="1650799097982"></p><p>3.10OK</p><p>Docker默认使用AUFS作为存储驱动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /sys/class/misc/device-mapper</span><br></pre></td></tr></table></figure><p><img src="/2022/04/24/Linux%E5%AE%89%E8%A3%85docker/1650799973562.png" alt="1650799973562"></p><p><img src="/2022/04/24/Linux%E5%AE%89%E8%A3%85docker/1650799851866.png" alt="1650799851866"></p><p>如果没有检测到Device Mapper，需要安装device-mapper软件包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y device-mapper</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe dm_mod</span><br></pre></td></tr></table></figure><p><img src="/2022/04/24/Linux%E5%AE%89%E8%A3%85docker/1650799894545.png" alt="1650799894545"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure><p><img src="/2022/04/24/Linux%E5%AE%89%E8%A3%85docker/1650800016237.png" alt="1650800016237"></p><p><img src="/2022/04/24/Linux%E5%AE%89%E8%A3%85docker/1650800042659.png" alt="1650800042659"></p><h2 id="如安装过，卸载旧版本"><a href="#如安装过，卸载旧版本" class="headerlink" title="如安装过，卸载旧版本"></a>如安装过，卸载旧版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine</span><br></pre></td></tr></table></figure><p><img src="/2022/04/24/Linux%E5%AE%89%E8%A3%85docker/1650800058886.png" alt="1650800058886"></p><h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><h2 id="设置stable镜像仓库"><a href="#设置stable镜像仓库" class="headerlink" title="设置stable镜像仓库"></a>设置stable镜像仓库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h2 id="更新yum软件包索引"><a href="#更新yum软件包索引" class="headerlink" title="更新yum软件包索引"></a>更新yum软件包索引</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><h2 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce.x86_64  --showduplicates | sort -r</span><br></pre></td></tr></table></figure><h2 id="安装指定版本"><a href="#安装指定版本" class="headerlink" title="安装指定版本"></a>安装指定版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce-18.09.9 docker-ce-cli-18.09.9 containerd.io</span><br></pre></td></tr></table></figure><h2 id="安装最新版本"><a href="#安装最新版本" class="headerlink" title="安装最新版本"></a>安装最新版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure><h2 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h2 id="验证是否安装成功"><a href="#验证是否安装成功" class="headerlink" title="验证是否安装成功"></a>验证是否安装成功</h2>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><h2 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="查看docker版本"><a href="#查看docker版本" class="headerlink" title="查看docker版本"></a>查看docker版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><h2 id="搜索镜像-start代表受欢迎程度。OFFICIAL代表官方版本"><a href="#搜索镜像-start代表受欢迎程度。OFFICIAL代表官方版本" class="headerlink" title="搜索镜像-start代表受欢迎程度。OFFICIAL代表官方版本"></a>搜索镜像-start代表受欢迎程度。OFFICIAL代表官方版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search tomcat</span><br></pre></td></tr></table></figure><h2 id="查看当前所有镜像"><a href="#查看当前所有镜像" class="headerlink" title="查看当前所有镜像"></a>查看当前所有镜像</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><h3 id="下载镜像-1"><a href="#下载镜像-1" class="headerlink" title="下载镜像"></a>下载镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run centos echo &quot;hello word&quot;</span><br></pre></td></tr></table></figure><h3 id="运行容器-hello-word"><a href="#运行容器-hello-word" class="headerlink" title="运行容器 hello word"></a>运行容器 hello word</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="列出docker包的具体的名字"><a href="#列出docker包的具体的名字" class="headerlink" title="列出docker包的具体的名字"></a>列出docker包的具体的名字</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum list  installed | grep docker</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">containerd.io.x86_64                 1.2.4-3.1.el7 </span><br><span class="line">docker-ce.x86_64                     3:18.09.3-3.el7</span><br><span class="line">docker-ce-cli.x86_64                 1:18.09.3-3.el7</span><br></pre></td></tr></table></figure><h3 id="删除docker"><a href="#删除docker" class="headerlink" title="删除docker"></a>删除docker</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y remove containerd.io.x86_64 \</span><br></pre></td></tr></table></figure><p>或者</p><h3 id="直接删除docker"><a href="#直接删除docker" class="headerlink" title="直接删除docker"></a>直接删除docker</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-io \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><h3 id="清除镜像和容器文件："><a href="#清除镜像和容器文件：" class="headerlink" title="清除镜像和容器文件："></a>清除镜像和容器文件：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure><h1 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h1><h2 id="Docker国内镜像："><a href="#Docker国内镜像：" class="headerlink" title="Docker国内镜像："></a>Docker国内镜像：</h2><p>网易加速器：<a href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a><br>官方中国加速器：<a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a><br>ustc的镜像：<a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a><br>也可使用私人镜像加速器地址，如使用阿里云的镜像加速器：登录阿里云-&gt;产品-&gt;搜索”容器镜像服务”-&gt;镜像库-&gt;镜像加速器。</p><p>新版的 Docker 使用 &#x2F;etc&#x2F;docker&#x2F;daemon.json（Linux） 来配置 Daemon。</p><p>请在该配置文件中加入（没有该文件的话，请先建一个）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/docker/daemon.json </span><br><span class="line">&#123; </span><br><span class="line">　　&quot;registry-mirrors&quot;: [&quot;https://hub-mirror.c.163.com&quot;] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置成功后，CentOS7重启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload     #重启加速配置文件</span><br><span class="line">systemctl restart docker    #重启docker后台服务</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux安装docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器常用命令</title>
      <link href="/2022/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="一般情况下，网站（PHP后端）突然无法打开可以尝试重启服务"><a href="#一般情况下，网站（PHP后端）突然无法打开可以尝试重启服务" class="headerlink" title="一般情况下，网站（PHP后端）突然无法打开可以尝试重启服务"></a>一般情况下，网站（PHP后端）突然无法打开可以尝试重启服务</h3><p>1.服务器重启命令：reboot<br>2.php-fpm重启命令：service php-fpm restart</p><h3 id="使用nginx的服务器，有时候网站配置后，出现ngnix报错可以先检查下网站的Nginx配置文件是否出现错误"><a href="#使用nginx的服务器，有时候网站配置后，出现ngnix报错可以先检查下网站的Nginx配置文件是否出现错误" class="headerlink" title="使用nginx的服务器，有时候网站配置后，出现ngnix报错可以先检查下网站的Nginx配置文件是否出现错误"></a>使用nginx的服务器，有时候网站配置后，出现ngnix报错可以先检查下网站的Nginx配置文件是否出现错误</h3><p>1.检查nginx语法 : nginx -tc 目录&#x2F;配置文件.conf<br>例子：nginx -tc &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</p><h3 id="文件解、压缩"><a href="#文件解、压缩" class="headerlink" title="文件解、压缩"></a>文件解、压缩</h3><p>1.压缩打包命令：tar -zcvf &#x2F;data&#x2F;wwwroot&#x2F;###.tar.gz 目标文件夹名<br>2.解压命令：tar -xzvf file.tar.gz<br>例子：<br>(将abc文件夹打包压缩为abc.tar.gz)：tar -zcvf &#x2F;data&#x2F;wwwroot&#x2F;abc.tar.gz abc<br>(将abc.tar.gz解压） tar -xzvf abc.tar.gz</p><h3 id="服务器之间拷贝文件"><a href="#服务器之间拷贝文件" class="headerlink" title="服务器之间拷贝文件"></a>服务器之间拷贝文件</h3><p>1.将文件拷贝到另一台服务器：<br>scp &#x2F;data&#x2F;wwwroot&#x2F;666.tar.gz <a href="mailto:&#114;&#x6f;&#x6f;&#x74;&#64;&#x31;&#x31;&#49;&#46;&#x31;&#49;&#46;&#x31;&#49;&#46;&#49;&#x31;&#49;">&#114;&#x6f;&#x6f;&#x74;&#64;&#x31;&#x31;&#49;&#46;&#x31;&#49;&#46;&#x31;&#49;&#46;&#49;&#x31;&#49;</a>:&#x2F;data&#x2F;wwwroot&#x2F;<br>2.从另一台服务器拷贝文件：<br>scp <a href="mailto:&#114;&#111;&#x6f;&#116;&#x40;&#50;&#50;&#x32;&#x2e;&#50;&#x32;&#x2e;&#50;&#x32;&#46;&#x32;&#x32;&#x32;">&#114;&#111;&#x6f;&#116;&#x40;&#50;&#50;&#x32;&#x2e;&#50;&#x32;&#x2e;&#50;&#x32;&#46;&#x32;&#x32;&#x32;</a>:&#x2F;data&#x2F;wwwroot&#x2F;weixin.tar.gz &#x2F;data&#x2F;wwwroot</p><h3 id="数据库导出（mysqldump命令）"><a href="#数据库导出（mysqldump命令）" class="headerlink" title="数据库导出（mysqldump命令）"></a>数据库导出（mysqldump命令）</h3><h4 id="导出整个数据库"><a href="#导出整个数据库" class="headerlink" title="导出整个数据库"></a>导出整个数据库</h4><p>mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名<br>mysqldump -u linuxde -p data &gt; 目录&#x2F;linuxde.sql</p><h4 id="导出一个表"><a href="#导出一个表" class="headerlink" title="导出一个表"></a>导出一个表</h4><p>mysqldump -u 用户名 -p 数据库名 表名 &gt; 导出的文件名<br>mysqldump -u linuxde -p data users &gt; linuxde_users.sql</p><p>基本命令格（[xxx]中的内容根据实际情况改动）</p><p>mysqldump -u [username] -p -d [databaseName] [tableName] &gt;<br>[路径及导出的sql文件名];</p><p>1、导出数据库dbname的表结构<br>mysqldump -u root -p -d dbname &gt;db.sql;</p><p>2、导出数据库dbname所有表结构及表數據（不加-d）<br>mysqldump -u root -p dbname &gt;db.sql;</p><p>3、导出数据库dbname某张表的结构<br>mysqldump -uroot -pdbpasswd -d dbname test&gt;db.sql;</p><p>4、导出数据库dbname某张表(test)结构及表数据（不加-d）<br>mysqldump -u root -p dbname test&gt;db.sql;</p><h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><p>centos从7开始默认用的是firewalld，这个是基于iptables的，虽然有iptables的核心，但是iptables的服务是没安装的。所以你只要停止firewalld服务即可：</p><p>sudo systemctl stop firewalld.service &amp;&amp; sudo systemctl disable firewalld.service</p><p>如果你要改用iptables的话，需要安装iptables服务：<br>sudo yum install iptables-services<br>sudo systemctl enable iptables &amp;&amp; sudo systemctl enable ip6tables<br>sudo systemctl start iptables &amp;&amp; sudo systemctl start ip6tables</p><h3 id="搜索文件，查看文件内容"><a href="#搜索文件，查看文件内容" class="headerlink" title="搜索文件，查看文件内容"></a>搜索文件，查看文件内容</h3><p>find . -name ‘srm*’ 　　#表示当前目录下查找文件名开头是字符串‘srm’的文件</p><p>grep -A 5 foo file 显示file文件里匹配foo字串那行以foo及后5行<br>grep -B 5 foo file 显示file文件里匹配foo字串那行以foo及前5行<br>grep -C 5 foo file 显示file文件里匹配foo字串那行以及上下5行</p><p>1、查看最后1000行的数据<br>cat filename | tail -n 1000<br>2、查看1000到3000行的数据<br>cat filename | head -n 3000 | tail -n +1000<br>注：管道符的作用 | 将前面的结果作为后面结果的输出。<br>3、打印文件所有内容<br>cat filename<br>4、打印文件最后1000行的数据<br>tail -n 1000<br>5、打印文件第1000行开始以后的内容<br>tail -n +1000<br>6、打印前1000的内容<br>head -n 1000<br>7、显示1000到300行的数据<br>sed -n ‘1000,3000p’ filename</p><h3 id="创建软连接（ln-s-命令）"><a href="#创建软连接（ln-s-命令）" class="headerlink" title="创建软连接（ln -s 命令）"></a>创建软连接（ln -s 命令）</h3><p>具体用法：ln -s 源文件 软连接的位置<br>例：安装maven后直接使用mvn会出现 -bash: mvn: command not found的错误，这就需要增加一个软连接：<br>ln -s &#x2F;home&#x2F;maven&#x2F;bin&#x2F;mvn &#x2F;usr&#x2F;bin&#x2F;mvn<br>执行完，即可使用mvn命令。</p><h2 id="查看服务器硬件资源信息"><a href="#查看服务器硬件资源信息" class="headerlink" title="查看服务器硬件资源信息"></a>查看服务器硬件资源信息</h2><h3 id="内存：free-h"><a href="#内存：free-h" class="headerlink" title="内存：free -h"></a>内存：free -h</h3><p><img src="/2022/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1650765357355.png" alt="1650765357355"></p><h3 id="硬盘：df-h"><a href="#硬盘：df-h" class="headerlink" title="硬盘：df -h"></a>硬盘：df -h</h3><p><img src="/2022/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1650765373449.png" alt="1650765373449"></p><h3 id="负载：top（进入后-按Q键退出）-或者-w-（此处使用w）"><a href="#负载：top（进入后-按Q键退出）-或者-w-（此处使用w）" class="headerlink" title="负载：top（进入后 按Q键退出） 或者 w （此处使用w）"></a>负载：top（进入后 按<strong>Q键</strong>退出） 或者 w （此处使用w）</h3><p><img src="/2022/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1650765489808.png" alt="1650765489808"></p><p>load average 后的三个值表示最近一分钟、最近五分钟、最近15分钟的负载。若接近1，服务器就满负荷运载了。</p><h3 id="查看cpu信息：cat-x2F-proc-x2F-cpuinfo"><a href="#查看cpu信息：cat-x2F-proc-x2F-cpuinfo" class="headerlink" title="查看cpu信息：cat &#x2F;proc&#x2F;cpuinfo"></a>查看cpu信息：cat &#x2F;proc&#x2F;cpuinfo</h3><p><img src="/2022/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1650765598491.png" alt="1650765598491"></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>1、cd                                    作用： 进入文件夹</p><p>2、ps  -ef|grep   服务包名称     作用：查看服务的进程号以及判断该服务是否处于生存状态</p><p>3、kill -9   xxxx     作用：杀死进程号为xxxx的进程。</p><p>4、gedit      xxx                  作用：打开并编辑xxx文件</p><p>5、vi  xxx                          作用：编辑xxx文件 </p><p>6、vi配套命令，按住i，进入插入模式，编辑完成后按esc键退出编辑模式，:wq 回车保存，:q!强制退出不保存 。</p><p>7、ls                                     作用：查看当前文件夹下的文件列表</p><p>8、ls -l                  作用：查看当前文件夹下的文件列表以及相关信息比如创建时间、权限信息。</p><p> 9、find    &#x2F;  -name  xxx        作用：从根目录开始查找名为xxx的文件或文件夹</p><p>10、pwd               作用：查看当前所在目录</p><p>11、whereis  xxx    作用：搜索xxx文件或者命令</p><p>12、chmod  777  xxx     作用：是给xxx文件或者文件夹授予最高权限</p><p>13、sudo su    作用：切换为超级管理员</p><p>14、cat  xxx    作用：查看某个文件或者配置信息，经常用来查看日志</p><p>15、tail xxx   作用：查看某个文件，默认最后十行</p><p>16、apt  install  xxxx  作用：在线包管理安装命令,安装xxxx软件</p><p>17、dpkg -i   xxxx     作用：安装离线本地包xxxx</p><p>18、cp -r  原路径文件夹或文件      目的路径文件夹   作用：将文件夹或文件 复制到目的文件夹下</p><p>19、tar zxvf xxxx.tar   作用：解压后缀为.tar的压缩包。（注：压缩命令较多，压缩包后缀不同使用的解压和压缩的命令也不相同）</p><p>20、ip addr 或 ifconfig   作用：查看当前ip地址</p><h2 id="后台启动Java项目"><a href="#后台启动Java项目" class="headerlink" title="后台启动Java项目"></a>后台启动Java项目</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar springboot-0.0.1-SNAPSHOT.jar &amp;</span><br></pre></td></tr></table></figure><p><img src="/2022/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1650846711516.png" alt="1650846711516"></p><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat nohup.out</span><br></pre></td></tr></table></figure><p><img src="/2022/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1650846949085.png" alt="1650846949085"></p><h3 id="查看java启动情况"><a href="#查看java启动情况" class="headerlink" title="查看java启动情况"></a>查看java启动情况</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep java</span><br></pre></td></tr></table></figure><p><img src="/2022/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1650848408672.png" alt="1650848408672"></p><h3 id="关闭java"><a href="#关闭java" class="headerlink" title="关闭java"></a>关闭java</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 19209</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库导出文件</title>
      <link href="/2022/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%BC%E5%87%BA%E6%96%87%E4%BB%B6/"/>
      <url>/2022/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%BC%E5%87%BA%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h2><p>DataGrip有多种数据导出模式，常用的有两种：</p><ul><li><code>Dump Data to File</code></li><li><code>Dump with &#39;mysqldump&#39;</code></li></ul><p><img src="https://img.jbzj.com/file_images/article/202109/20210917114438109.png" alt="图片"></p><p>&#96;&#96;Dump Data to File&#96;模式，该模式是导出各种单个文件，比如，SQL，HTML，TSV，CSV等文件，当然这是我们在对某个表进行操作的时候使用的。</p><p><img src="https://img.jbzj.com/file_images/article/202109/20210917114438110.png" alt="图片"></p><p><code>Dump with &#39;mysqldump&#39;</code>模式，该模式是使用MySql的<code>mysqldump</code>组件进行数据导出，该方法导出的SQL文件，可以选择，是否包含数据或者是只导出数据结构。该模式是我们常用的数据库导出。下面对该模式进行说明。</p><ul><li><code>Path to mysqldump</code>选择你的<code>mysqldump</code>在本地磁盘的位置</li><li><code>Statements</code>选择模式</li><li><code>Databases</code>需要导出的数据库(不可选择，默认当前右键选中的)</li><li><code>Tables</code>需要导出的表(不可选择，默认当前右键选中的)</li><li>多选框，根据自己需求进行选择，一般默认即可</li><li><code>Out path</code>导出路径</li></ul><h2 id="导出数据结构及数据"><a href="#导出数据结构及数据" class="headerlink" title="导出数据结构及数据"></a>导出数据结构及数据</h2><blockquote><p>如果第一次导出，应该会出现<code>Can&#39;t create/write to file</code>这个错误，这时候，需要在<code>Out path</code>后面，手动添加上，需要导出的文件，例如下图，<code>test.sql</code>即可</p></blockquote><p><img src="https://img.jbzj.com/file_images/article/202109/20210917114438111.png" alt="图片"></p><h3 id="导出结构"><a href="#导出结构" class="headerlink" title="导出结构"></a>导出结构</h3><blockquote><p>导出结构与上面基本一致，只是在下面命令行的表名前面，添加一个<code>-d</code>记住，后面要添加一个空格，如下图</p></blockquote><p><img src="https://img.jbzj.com/file_images/article/202109/20210917114439112.png" alt="图片"></p><h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><p>导入数据刚开始，是一直困惑我的问题，因为<code>Import Data from File</code>这个功能貌似不是那么回事，后来发现，一个很神奇的东西。</p><p>操作步骤如下</p><ul><li>将sql文件，拖拽到DataGrip中</li><li>在需要导入数据的sql的tab上，右键</li><li>点击最下面的<code>Run</code></li><li>选择需要操作的库</li><li>完成</li></ul><p>这些说着很复杂，其实操作起来，很方便。如下图所示</p><p><img src="https://img.jbzj.com/file_images/article/202109/20210917114439113.png" alt="img"></p><p>然后选择需要操作的库</p><p><img src="https://img.jbzj.com/file_images/article/202109/20210917114439114.png" alt="img"></p><p>问题：</p><ol><li><p>首次导出可能会提示没有权限的问题：Can’t create&#x2F;write to file</p><p><img src="/2022/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%BC%E5%87%BA%E6%96%87%E4%BB%B6/1650507320837.png" alt="1650507320837"></p></li></ol><p>解决方式：<br>  只需要在Outpath后面，手动添加，需要导出的文件：forestry.sql即可。</p><p><img src="/2022/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%BC%E5%87%BA%E6%96%87%E4%BB%B6/1650507355723.png" alt="1650507355723"></p><p>  2. 如果直接点击run可能会出现这个问题：A partial dump from a server that has GTIDs will by default include the GTID</p><p>   经过查询知道，GTID是5.6以后，加入了全局事务ID（GTID）来强化数据库的一致性，故障恢复以及容错能力。</p><p>  官方：</p><p>A global transaction identifier(GTID) is a unique identifier created and associated with each transaction committed on the server of origin(master).</p><p>  可以通过添加–set-gtid-purged&#x3D;off(已试，可行)或者-gtid-mode&#x3D;OFF(未试)这两个参数设置。</p><p>  这个命令直接添加到Out path 下面的命令行中即可，里面原来的命令不需要改动，直接添加空格，输入命令即可。</p><p>  很有可能是在导入库中重新生产GTID，而不用原来的。</p><p>  参考链接：<a href="https://www.jb51.net/article/109594.htm">https://www.jb51.net/article/109594.htm</a></p><p>  3. Couldn’t execute ‘SELECT COLUMN_NAME, JSON_EXTRACT(HISTOGRAM, ‘$.”number-of-</p><p>  这是因为当前执行导出操作的mysql版本是，但需要被导出的数据库是由之前版本创建的，在之前的版本中，information_schema数据库中没有COLLMN_STATISTICS数据表</p><p>  还在之前的命令行中打上空格，并且输入–column-statistics&#x3D;0 即可忽略这个表</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL主键自增</title>
      <link href="/2022/04/21/MySQL%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E/"/>
      <url>/2022/04/21/MySQL%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="auto-increment"><a href="#auto-increment" class="headerlink" title="auto_increment"></a>auto_increment</h2><p>在使用auto_increment时，应该注意一个小问题, 当进行delete from 表名称 清空表的时候，重新插入数据 , 发现auto_increment主键字段计数不是从1开始的,而是接着最新插入的数据id开始!</p><p>那么如何重新计数呢？</p><p>可以使用以下命令:</p><p>方法1</p><p> delete from 表名称; alter table 表名称 auto_increment&#x3D;1 #–这种方法处理的好处就是 可以设置auto_increment 为任意值开始自增 #–提示：如果表列和数据很多，速度会很慢，如90多万条，会在10分钟以上, 所以注意使用场景<br>方法2</p><p> #–直接一句话搞定 truncate table 表名称 #–(好处就是简单，auto_increment值重新开始从1计数)<br>重点注意 : 一般情况下我们使用第二个就可以了，记住以上情况都是彻底删除所有记录, 所以我们在设定之前要考虑周密，设计数据库表的时候也要考虑多方面因素!</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot解决跨域问题</title>
      <link href="/2022/04/10/SpringBoot%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/10/SpringBoot%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Springboot解决跨域问题"><a href="#Springboot解决跨域问题" class="headerlink" title="Springboot解决跨域问题"></a>Springboot解决跨域问题</h1><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F7632302-b1b8cb2830a1cd14.png&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1652162323&t=b6b4f1466718fea00a2036d8b17b21a1"></p><p>在Springboot项目里加上这个配置文件<code>CorsConfig.java</code>，重启之后即可实现跨域访问，前端无需再配置跨域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.zdk.springboot.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.filter.CorsFilter;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.cors.CorsConfiguration;</span><br><span class="line">import org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class CorsConfig &#123;</span><br><span class="line"></span><br><span class="line">    //当前跨域请求最大时长。默认一天</span><br><span class="line">    private static final long MAX_AGE = 24 * 60 * 60;</span><br><span class="line"></span><br><span class="line">    private CorsConfiguration buildConfig()&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = new CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(&quot;*&quot;);//1、设置访问源地址</span><br><span class="line">        corsConfiguration.addAllowedHeader(&quot;*&quot;);//2、设置访问源请求头</span><br><span class="line">        corsConfiguration.addAllowedMethod(&quot;*&quot;);//3、设置访问源请求方法</span><br><span class="line">        corsConfiguration.setMaxAge(MAX_AGE);</span><br><span class="line">        return corsConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public CorsFilter corsFilter()&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();</span><br><span class="line">        source.registerCorsConfiguration(&quot;/**&quot;,buildConfig());//4、对接口配置跨域设置</span><br><span class="line">        return new CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Springboot解决跨域问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库服务器性能分析</title>
      <link href="/2022/03/29/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
      <url>/2022/03/29/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>MySQL查看数据库性能常用命令<br>一、查询服务器状态和配置<br>列出MySQL服务器运行各种状态值：</p><p>mysql&gt; show global status;<br>查询MySQL服务器配置信息语句：</p><p>mysql&gt; show variables;<br>二、慢查询<br>　　mysql&gt; show variables like ‘%slow%’;<br>　　+——————+——-+<br>　　| Variable_name | Value |<br>　　+——————+——-+<br>　　| log_slow_queries | ON |<br>　　| slow_launch_time | 2 |<br>　　+——————+——-+<br>　　mysql&gt; show global status like ‘%slow%’;<br>　　+———————+——-+<br>　　| Variable_name | Value |<br>　　+———————+——-+<br>　　| Slow_launch_threads | 0 |<br>　　| Slow_queries | 4148 |<br>　　+———————+——-+　</p><pre><code>     配置中打开了记录慢查询，执行时间超过2秒的即为慢查询，系统显示有4148个慢查询，你可以分析慢查询日志，找出有问题的SQL语句，慢查询时间不宜设置过长，否则意义不大，最好在5秒以内，如果你需要微秒级别的慢查询，可以考虑给MySQL打补丁：http://www.percona.com/docs/wiki/release:start，记得找对应的版本。</code></pre><p>　　打开慢查询日志可能会对系统性能有一点点影响，如果你的MySQL是主-从结构，可以考虑打开其中一台从服务器的慢查询日志，这样既可以监控慢查询，对系统性能影响又小。</p><p>三、连接数 </p><p>　　经常会遇见”MySQL: ERROR 1040: Too many connections”的情况，一种是访问量确实很高，MySQL服务器抗不住，这个时候就要考虑增加从服务器分散读压力，另外一种情况是MySQL配置文件中max_connections值过小： </p><p>　　mysql&gt; show variables like ‘max_connections’;<br>　　+—————–+——-+<br>　　| Variable_name | Value |<br>　　+—————–+——-+<br>　　| max_connections | 256 |<br>　　+—————–+——-+　　<br>       这台MySQL服务器最大连接数是256，然后查询一下服务器响应的最大连接数： 　　</p><p>mysql&gt; show global status like ‘Max_used_connections’;</p><p>　　MySQL服务器过去的最大连接数是245，没有达到服务器连接数上限256，应该没有出现1040错误，比较理想的设置是：<br>　　Max_used_connections &#x2F; max_connections * 100% ≈ 85%<br>　　最大连接数占上限连接数的85%左右，如果发现比例在10%以下，MySQL服务器连接数上限设置的过高了。</p><p>四、Key_buffer_size </p><p>　　key_buffer_size是对MyISAM表性能影响最大的一个参数，下面一台以MyISAM为主要存储引擎服务器的配置： </p><p>　　mysql&gt; show variables like ‘key_buffer_size’;<br>　　+—————–+————+<br>　　| Variable_name | Value |<br>　　+—————–+————+<br>　　| key_buffer_size | 536870912 |<br>　　+—————–+————+　　<br>       分配了512MB内存给key_buffer_size，我们再看一下key_buffer_size的使用情况： </p><p>　　mysql&gt; show global status like ‘key_read%’;<br>　　+————————+————-+<br>　　| Variable_name | Value | mysql<br>　　+————————+————-+<br>　　| Key_read_requests | 27813678764 |<br>　　| Key_reads | 6798830 |<br>　　+————————+————-+　　<br>       一共有27813678764个索引读取请求，有6798830个请求在内存中没有找到直接从硬盘读取索引，计算索引未命中缓存的概率：<br>　　key_cache_miss_rate &#x3D; Key_reads &#x2F; Key_read_requests * 100%<br>　　比如上面的数据，key_cache_miss_rate为0.0244%，4000个索引读取请求才有一个直接读硬盘，已经很BT了,key_cache_miss_rate在0.1%以下都很好(每1000个请求有一个直接读硬盘)，如果key_cache_miss_rate在0.01%以下的话，key_buffer_size分配的过多，可以适当减少。<br>　　MySQL服务器还提供了key_blocks_*参数： </p><p>　　mysql&gt; show global status like ‘key_blocks_u%’;<br>　　+————————+————-+<br>　　| Variable_name | Value |<br>　　+————————+————-+<br>　　| Key_blocks_unused | 0 |<br>　　| Key_blocks_used | 413543 |<br>　　+————————+————-+　　</p><p>​        Key_blocks_unused表示未使用的缓存簇(blocks)数，Key_blocks_used表示曾经用到的最大的blocks数，比如这台服务器，所有的缓存都用到了，要么增加key_buffer_size，要么就是过渡索引了，把缓存占满了。比较理想的设置： </p><p>　　Key_blocks_used &#x2F; (Key_blocks_unused + Key_blocks_used) * 100% ≈ 80%</p><p>五、临时表<br>　　mysql&gt; show global status like ‘created_tmp%’;<br>　　+————————-+———+<br>　　| Variable_name | Value |<br>　　+————————-+———+<br>　　| Created_tmp_disk_tables | 21197 |<br>　　| Created_tmp_files | 58 |<br>　　| Created_tmp_tables | 1771587 |<br>　　+————————-+———+　　<br>       每次创建临时表，Created_tmp_tables增加，如果是在磁盘上创建临时表，Created_tmp_disk_tables也增加,Created_tmp_files表示MySQL服务创建的临时文件文件数，比较理想的配置是：<br>　　Created_tmp_disk_tables &#x2F; Created_tmp_tables * 100% &lt;&#x3D; 25%<br>　　比如上面的服务器Created_tmp_disk_tables &#x2F; Created_tmp_tables * 100% &#x3D; 1.20%，应该相当好了。我们再看一下MySQL服务器对临时表的配置： </p><p>　　mysql&gt; show variables where Variable_name in (‘tmp_table_size’, ‘max_heap_table_size’);<br>　　+———————+———–+<br>　　| Variable_name | Value |<br>　　+———————+———–+<br>　　| max_heap_table_size | 268435456 |<br>　　| tmp_table_size | 536870912 |<br>　　+———————+———–+　　<br>      只有256MB以下的临时表才能全部放内存，超过的就会用到硬盘临时表。</p><p>六、Open Table情况<br>　　mysql&gt; show global status like ‘open%tables%’;<br>　　+—————+——-+<br>　　| Variable_name | Value |<br>　　+—————+——-+<br>　　| Open_tables | 919 |<br>　　| Opened_tables | 1951 |<br>　　+—————+——-+　<br>　 Open_tables表示打开表的数量，Opened_tables表示打开过的表数量，如果Opened_tables数量过大，说明配置中table_cache(5.1.3之后这个值叫做table_open_cache)值可能太小，我们查询一下服务器table_cache值： </p><p>　　mysql&gt; show variables like ‘table_cache’;<br>　　+—————+——-+<br>　　| Variable_name | Value |<br>　　+—————+——-+<br>　　| table_cache | 2048 |<br>　　+—————+——-+</p><p>　　比较合适的值为：<br>　　Open_tables &#x2F; Opened_tables * 100% &gt;&#x3D; 85%<br>　　Open_tables &#x2F; table_cache * 100% &lt;&#x3D; 95%</p><p>七、进程使用情况</p><p>　　mysql&gt; show global status like ‘Thread%’;<br>　　+——————-+——-+<br>　　| Variable_name | Value |<br>　　+——————-+——-+<br>　　| Threads_cached | 46 |<br>　　| Threads_connected | 2 |<br>　　| Threads_created | 570 |<br>　　| Threads_running | 1 |<br>　　+——————-+——-+　　</p><pre><code> 如果我们在MySQL服务器配置文件中设置了thread_cache_size，当客户端断开之后，服务器处理此客户的线程将会缓存起来以响应下一个客户而不是销毁(前提是缓存数未达上限)。Threads_created表示创建过的线程数，如果发现Threads_created值过大的话，表明MySQL服务器一直在创建线程，这也是比较耗资源，可以适当增加配置文件中thread_cache_size值，查询服务器thread_cache_size配置： </code></pre><p>　　mysql&gt; show variables like ‘thread_cache_size’;<br>　　+——————-+——-+<br>　　| Variable_name | Value |<br>　　+——————-+——-+<br>　　| thread_cache_size | 64 |<br>　　+——————-+——-+　　<br>      服务器还是挺健康的。</p><p>八、查询缓存(query cache)<br>　<br>　mysql&gt; show global status like ‘qcache%’;<br>　　+————————-+———–+<br>　　| Variable_name | Value |<br>　　+————————-+———–+<br>　　| Qcache_free_blocks | 22756 |<br>　　| Qcache_free_memory | 76764704 |<br>　　| Qcache_hits | 213028692 |<br>　　| Qcache_inserts | 208894227 |<br>　　| Qcache_lowmem_prunes | 4010916 |<br>　　| Qcache_not_cached | 13385031 |<br>　　| Qcache_queries_in_cache | 43560 |<br>　　| Qcache_total_blocks | 111212 |<br>　　+————————-+———–+　　  </p><p>​     MySQL查询缓存变量解释：</p><p>Qcache_free_blocks：缓存中相邻内存块的个数。数目大说明可能有碎片。FLUSH QUERY CACHE会对缓存中的碎片进行整理，从而得到一个空闲块。<br>Qcache_free_memory：缓存中的空闲内存。<br>Qcache_hits：每次查询在缓存中命中时就增大<br>Qcache_inserts：每次插入一个查询时就增大。命中次数除以插入次数就是不中比率。<br>Qcache_lowmem_prunes：缓存出现内存不足并且必须要进行清理以便为更多查询提供空间的次数。这个数字最好长时间来看;如果这个数字在不断增长，就表示可能碎片非常严重，或者内存很少。(上面的 free_blocks和free_memory可以告诉您属于哪种情况)<br>Qcache_not_cached：不适合进行缓存的查询的数量，通常是由于这些查询不是 SELECT 语句或者用了now()之类的函数。<br>Qcache_queries_in_cache：当前缓存的查询(和响应)的数量。<br>Qcache_total_blocks：缓存中块的数量。<br>　　我们再查询一下服务器关于query_cache的配置： 　　</p><p>mysql&gt; show variables like ‘query_cache%’;<br>　　+——————————+———–+<br>　　| Variable_name | Value |<br>　　+——————————+———–+<br>　　| query_cache_limit | 2097152 |<br>　　| query_cache_min_res_unit | 4096 |<br>　　| query_cache_size | 203423744 |<br>　　| query_cache_type | ON |<br>　　| query_cache_wlock_invalidate | OFF |<br>       +——————————+———–+</p><p>　　各字段的解释：</p><p>query_cache_limit：超过此大小的查询将不缓存<br>query_cache_min_res_unit：缓存块的最小大小<br>query_cache_size：查询缓存大小<br>query_cache_type：缓存类型，决定缓存什么样的查询，示例中表示不缓存 select sql_no_cache 查询<br>query_cache_wlock_invalidate：当有其他客户端正在对MyISAM表进行写操作时，如果查询在query cache中，是否返回cache结果还是等写操作完成再读表获取结果。<br>query_cache_min_res_unit的配置是一柄”双刃剑”，默认是4KB，设置值大对大数据查询有好处，但如果你的查询都是小数据查询，就容易造成内存碎片和浪费。<br>　　查询缓存碎片率 &#x3D; Qcache_free_blocks &#x2F; Qcache_total_blocks * 100%<br>　　如果查询缓存碎片率超过20%，可以用FLUSH QUERY CACHE整理缓存碎片，或者试试减小query_cache_min_res_unit，如果你的查询都是小数据量的话。<br>　　查询缓存利用率 &#x3D; (query_cache_size - Qcache_free_memory) &#x2F; query_cache_size * 100%<br>　　查询缓存利用率在25%以下的话说明query_cache_size设置的过大，可适当减小;查询缓存利用率在80%以上而且Qcache_lowmem_prunes &gt; 50的话说明query_cache_size可能有点小，要不就是碎片太多。<br>　　查询缓存命中率 &#x3D; (Qcache_hits - Qcache_inserts) &#x2F; Qcache_hits * 100%<br>　　示例服务器 查询缓存碎片率 &#x3D; 20.46%，查询缓存利用率 &#x3D; 62.26%，查询缓存命中率 &#x3D; 1.94%，命中率很差，可能写操作比较频繁吧，而且可能有些碎片。</p><p>九、排序使用情况 </p><p>　　mysql&gt; show global status like ‘sort%’;<br>　　+——————-+————+<br>　　| Variable_name | Value |<br>　　+——————-+————+<br>　　| Sort_merge_passes | 29 |<br>　　| Sort_range | 37432840 |<br>　　| Sort_rows | 9178691532 |<br>　　| Sort_scan | 1860569 |<br>　　+——————-+————+　　</p><p>​        Sort_merge_passes 包括两步。MySQL 首先会尝试在内存中做排序，使用的内存大小由系统变量 Sort_buffer_size 决定，如果它的大小不够把所有的记录都读到内存中，MySQL 就会把每次在内存中排序的结果存到临时文件中，等MySQL找到所有记录之后，再把临时文件中的记录做一次排序。这再次排序就会增加 Sort_merge_passes。实际上，MySQL 会用另一个临时文件来存再次排序的结果，所以通常会看到 Sort_merge_passes 增加的数值是建临时文件数的两倍。因为用到了临时文件，所以速度可能会比较慢，增加 Sort_buffer_size 会减少Sort_merge_passes和创建临时文件的次数。但盲目的增加 Sort_buffer_size 并不一定能提高速度，见 How fast can you sort data with MySQL?(引自<a href="http://qroom.blogspot.com/2007/09/mysql-select-sort.html">http://qroom.blogspot.com/2007/09/mysql-select-sort.html</a>) 。</p><p>　　另外，增加read_rnd_buffer_size(3.2.3是record_rnd_buffer_size)的值对排序的操作也有一点的好处，参见：<a href="http://www.mysqlperformanceblog.com/2007/07/24/what-exactly-is-read_rnd_buffer_size/">http://www.mysqlperformanceblog.com/2007/07/24/what-exactly-is-read_rnd_buffer_size/</a></p><p>十、文件打开数(open_files) </p><p>　　mysql&gt; show global status like ‘open_files’;<br>　　+—————+——-+<br>　　| Variable_name | Value |<br>　　+—————+——-+<br>　　| Open_files | 1410 |<br>　　+—————+——-+<br>　　mysql&gt; show variables like ‘open_files_limit’;<br>　　+——————+——-+<br>　　| Variable_name | Value |<br>　　+——————+——-+<br>　　| open_files_limit | 4590 |<br>　　+——————+——-+　　</p><pre><code>  比较合适的设置：Open_files / open_files_limit * 100% &lt;= 75%</code></pre><p>十一、表锁情况<br>　<br>　mysql&gt; show global status like ‘table_locks%’;<br>　　+———————–+———–+<br>　　| Variable_name | Value |<br>　　+———————–+———–+<br>　　| Table_locks_immediate | 490206328 |<br>　　| Table_locks_waited | 2084912 |<br>　　+———————–+———–+　　<br>       Table_locks_immediate表示立即释放表锁数，Table_locks_waited表示需要等待的表锁数，如果Table_locks_immediate &#x2F; Table_locks_waited &gt; 5000，最好采用InnoDB引擎，因为InnoDB是行锁而MyISAM是表锁，对于高并发写入的应用InnoDB效果会好些。示例中的服务器Table_locks_immediate &#x2F; Table_locks_waited &#x3D; 235，MyISAM就足够了。</p><p>十二、表扫描情况<br>　　mysql&gt; show global status like ‘handler_read%’;<br>　　+———————–+————-+<br>　　| Variable_name | Value |<br>　　+———————–+————-+<br>　　| Handler_read_first | 5803750 |<br>　　| Handler_read_key | 6049319850 |<br>　　| Handler_read_next | 94440908210 |<br>　　| Handler_read_prev | 34822001724 |<br>　　| Handler_read_rnd | 405482605 |<br>　　| Handler_read_rnd_next | 18912877839 |<br>　　+———————–+————-+　　<br>        各字段解释参见<a href="http://hi.baidu.com/thinkinginlamp/blog/item/31690cd7c4bc5cdaa144df9c.html%EF%BC%8C%E8%B0%83%E5%87%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%8C%E6%88%90%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0%EF%BC%9A">http://hi.baidu.com/thinkinginlamp/blog/item/31690cd7c4bc5cdaa144df9c.html，调出服务器完成的查询请求次数：</a> </p><p>　　mysql&gt; show global status like ‘com_select’;<br>　　+—————+———–+<br>　　| Variable_name | Value |<br>　　+—————+———–+<br>　　| Com_select | 222693559 |<br>　　+—————+———–+　　<br>       计算表扫描率：<br>　　表扫描率 &#x3D; Handler_read_rnd_next &#x2F; Com_select<br>　　如果表扫描率超过4000，说明进行了太多表扫描，很有可能索引没有建好，增加read_buffer_size值会有一些好处，但最好不要超过8MB。<br>　　注意：<br>　　上文提到一些数字都是参考值，了解基本原理就可以，除了MySQL提供的各种status值外，操作系统的一些性能指标也很重要，比如常用的top,iostat等，尤其是iostat，现在的系统瓶颈一般都在磁盘IO上。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List五种去重方法</title>
      <link href="/2022/03/29/List%E4%BA%94%E7%A7%8D%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2022/03/29/List%E4%BA%94%E7%A7%8D%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="List-五种去重的方法"><a href="#List-五种去重的方法" class="headerlink" title="List 五种去重的方法"></a>List 五种去重的方法</h1><p>新建一个list数组: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List list = new ArrayList(); </span><br><span class="line">list.add(26); </span><br><span class="line">list.add(39); </span><br><span class="line">list.add(39); </span><br><span class="line">list.add(39); </span><br><span class="line">list.add(39); </span><br><span class="line">list.add(5); </span><br><span class="line">list.add(40); </span><br><span class="line">list.add(39); </span><br><span class="line">list.add(25); </span><br><span class="line">System.out.println(list); </span><br></pre></td></tr></table></figure><p><strong>方法一:使用java8新特性stream进行List去重</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List newList = list.stream().distinct().collect(Collectors.toList()); </span><br><span class="line">System.out.println(“java8新特性stream去重:”+newList); </span><br><span class="line">list.add(39); </span><br></pre></td></tr></table></figure><p><strong>方法二:双重for循环去重</strong> （不推荐使用，速度太慢）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">     for (int j = 0; j &lt; list.size(); ) &#123;</span><br><span class="line">        if (i != j &amp;&amp; list.get(i) == list.get(j)) &#123;</span><br><span class="line">               list.remove(j);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            j++;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(“双重for循环去重:”+list); </span><br><span class="line">list.add(39); </span><br></pre></td></tr></table></figure><p><strong>方法三:set集合判断去重,不打乱顺序</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Set set1 = new HashSet(); </span><br><span class="line">List newList1 = new ArrayList(); </span><br><span class="line">for (Integer integer : list) &#123; </span><br><span class="line">if(set1.add(integer)) &#123; </span><br><span class="line">newList1.add(integer); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">System.out.println(“set集合判断去重:”+list); </span><br><span class="line">list.add(39); </span><br></pre></td></tr></table></figure><p><strong>方法四:遍历后判断赋给另一个list集合</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List newList2 = new ArrayList(); </span><br><span class="line">for (Integer integer : list) &#123; </span><br><span class="line">if(!newList2.contains(integer))&#123; </span><br><span class="line">newList2.add(integer); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">System.out.println(“赋值新list去重:”+newList2); </span><br><span class="line">list.add(39); </span><br></pre></td></tr></table></figure><p><strong>方法五:set和list转换去重</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set set2 = new HashSet(); </span><br><span class="line">List newList3 = new ArrayList(); </span><br><span class="line">set2.addAll(list); </span><br><span class="line">newList3.addAll(set2); </span><br><span class="line">System.out.println(“set和list转换去重:”+newList3);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java_List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdbc statement</title>
      <link href="/2022/03/27/jdbc-statement/"/>
      <url>/2022/03/27/jdbc-statement/</url>
      
        <content type="html"><![CDATA[<h2 id="Statement、PreparedStatement和CallableStatement"><a href="#Statement、PreparedStatement和CallableStatement" class="headerlink" title="Statement、PreparedStatement和CallableStatement"></a>Statement、PreparedStatement和CallableStatement</h2><ol><li><p>Statement、PreparedStatement和CallableStatement都是接口(interface)。<br>&amp;nbsp; </p></li><li><p>Statement继承自Wrapper、PreparedStatement继承自Statement、CallableStatement继承自PreparedStatement。<br>&amp;nbsp;</p></li><li><p>Statement接口提供了执行语句和获取结果的基本方法；</p></li></ol><ul><li><p>PreparedStatement接口添加了处理 IN 参数的方法；   </p></li><li><p>CallableStatement接口添加了处理 OUT 参数的方法。<br>&amp;nbsp;</p></li></ul><ol start="4"><li>Statement、PreparedStatement和CallableStatement</li></ol><ul><li><p>Statement:<br>普通的不带参的查询SQL；支持批量更新,批量删除;    </p></li><li><p>PreparedStatement:<br>可变参数的SQL,编译一次,执行多次,效率高;<br>安全性好，有效防止Sql注入等问题;<br>支持批量更新,批量删除;   </p></li><li><p>CallableStatement:<br>继承自PreparedStatement,支持带参数的SQL操作;<br>支持调用存储过程,提供了对输出和输入&#x2F;输出参数(INOUT)的支持;<br>&amp;nbsp;</p></li></ul><ol start="5"><li>Statement每次执行sql语句，数据库都要执行sql语句的编译 ，<br>最好用于仅执行一次查询并返回结果的情形，效率高于PreparedStatement。<br>&amp;nbsp;</li></ol><h2 id="PreparedStatement是预编译的，使用PreparedStatement好处："><a href="#PreparedStatement是预编译的，使用PreparedStatement好处：" class="headerlink" title="PreparedStatement是预编译的，使用PreparedStatement好处："></a>PreparedStatement是预编译的，使用PreparedStatement好处：</h2><ol><li>在执行可变参数的一条SQL时，PreparedStatement比Statement的效率高，因为DBMS预编译一条SQL当然会比多次编译一条SQL的效率要高。 </li><li>安全性好，有效防止Sql注入等问题。 </li><li>对于多次重复执行的语句，使用PreparedStament效率会更高一点，并且在这种情况下也比较适合使用batch； </li><li>代码的可读性和可维护性。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAX_VALUE的含义</title>
      <link href="/2022/03/20/MAX-VALUE%E7%9A%84%E5%90%AB%E4%B9%89/"/>
      <url>/2022/03/20/MAX-VALUE%E7%9A%84%E5%90%AB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Integer-MAX-VALUE的含义"><a href="#Integer-MAX-VALUE的含义" class="headerlink" title="Integer.MAX_VALUE的含义"></a>Integer.MAX_VALUE的含义</h1><p>在了解Integer.MAX_VALUE的含义之前，我们得先知道java中的基本数据类型</p><p>在Java中，一共有8种基本数据类型：</p><p>整数型：int , short , long , byte 。  </p><p>浮点型：float , double 。  </p><p>字符类型：char 。  </p><p>表示真值的类型：boolean 。</p><p>（String属于Java中的字符串类型，也是一个引用类型，并不属于基本的数据类型）</p><p>整数型和浮点型取值范围如下：<br><img src="https://img-blog.csdnimg.cn/2020031010134471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNDUwMA==,size_16,color_FFFFFF,t_70">  </p><ul><li>Integer.MAX_VALUE表示int数据类型的最大取值数：2 147 483 647</li><li>Integer.MIN_VALUE表示int数据类型的最小取值数：-2 147 483 648</li></ul><p>对应：</p><ul><li>Short.MAX_VALUE 为short类型的最大取值数 32 767</li><li>Short.MIN_VALUE 为short类型的最小取值数 -32 768</li></ul><p>其他数据类型同上含义</p><p>补充：  </p><p>Integer.MAX_VALUE+1&#x3D;Integer.MIN_VALUE  </p><p>因为：  </p><p>Integer.MAX_VALUE的二进制是0111 1111 1111 1111 1111 1111 1111 1111  </p><p>Integer.MIN_VALUE的二进制是 1000 0000 0000 0000 0000 0000 0000 0000</p><p>0111 1111 1111 1111 1111 1111 1111 1111+1&#x3D;1000 0000 0000 0000 0000 0000 0000 0000</p>]]></content>
      
      
      
        <tags>
            
            <tag> java_MAX_VALUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java关于substring(a)与substring(a,b)的用法</title>
      <link href="/2022/03/20/java%E5%85%B3%E4%BA%8Esubstrin(a)%E4%B8%8Esubstring(a,b)%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2022/03/20/java%E5%85%B3%E4%BA%8Esubstrin(a)%E4%B8%8Esubstring(a,b)%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="String-str-x3D-“abc“；和String-str-x3D-new-String-“abc“-；到底分别创建了几个对象？"><a href="#String-str-x3D-“abc“；和String-str-x3D-new-String-“abc“-；到底分别创建了几个对象？" class="headerlink" title="String str &#x3D; “abc“；和String str &#x3D;new String(“abc“)；到底分别创建了几个对象？"></a>String str &#x3D; “abc“；和String str &#x3D;new String(“abc“)；到底分别创建了几个对象？</h1><h2 id="一、到底创建了几个对象"><a href="#一、到底创建了几个对象" class="headerlink" title="一、到底创建了几个对象"></a>一、到底创建了几个对象</h2><p>1、String str &#x3D; “abc”; 创建了几个对象？0个 或者 1个</p><p>2、String str &#x3D; new String(“abc”);创建了几个对象？ 1个或2个</p><h2 id="二、首先了解几个基本的概念："><a href="#二、首先了解几个基本的概念：" class="headerlink" title="二、首先了解几个基本的概念："></a>二、首先了解几个基本的概念：</h2><p>1、String是一个特殊的包装类数据。即可以用String str &#x3D; new String(“abc”);的形式来创建，也可以用String str &#x3D; “abc”;的形式来创建。</p><p>2、JVM的堆中存放对象的实例，而JVM的栈中存储对象的引用。</p><p>3、字符串常量池：</p><ul><li><p>字符串的分配和其它对象一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多，JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分确定常量池中一定不存在两个相同的字符串。</p></li><li><p>Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。<br>静态常量池：即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串（数量 ）字面量，还包含类、方法的信息，占用class文件绝大部分空间。<br>运行时常量池：则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。</p></li></ul><h2 id="三、String对象的创建过程："><a href="#三、String对象的创建过程：" class="headerlink" title="三、String对象的创建过程："></a>三、String对象的创建过程：</h2><p><strong>String str &#x3D; “abc”;</strong></p><p>创建过程：<br>1、首先在常量池中查找是否存在内容为”abc”字符串对象。<br>2、如果不存在则在常量池中创建”abc”，并让str引用该对象。（也就是创建1个对象的情况）<br>3、如果存在则直接让str引用该对象（该对象是存在方法区的运行时常量池中的）。（也就是创建0个对象的情况）<br><img src="https://img-blog.csdnimg.cn/20191022114636934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI5NjkyOQ==,size_16,color_FFFFFF,t_70"></p><p><strong>String str &#x3D; new String(“abc”);</strong></p><p>创建过程：<br>1、首先在堆中（不是常量池）创建一个指定的对象”abc”，并让str引用指向该对象。（创建第1个对象）<br>2、在字符串常量池中查看是否存在内容为”abc”的字符串对象。<br>3、若存在，则让堆中创建好的字符串对象对字符串常量池的对象进行引用。（也就是只创建1个对象的情况）<br>4、若不存在，则在常量池中添加一个内容为”abc”的字符串对象，并将堆中的String对象进行引用。（也就是创建2个对象的情况）</p><p><img src="https://img-blog.csdnimg.cn/20191022115600305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI5NjkyOQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>下面代码结果为true，说明同为常量池中的一个对象：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;abc&quot;;</span><br><span class="line">String str1 = &quot;ab&quot; + &quot;c&quot;;</span><br><span class="line">System.out.println(str == str1); //true</span><br></pre></td></tr></table></figure><p>因为String str1 &#x3D; “ab” + “c”;会查找常量池中是否存在内容为”abc”的对象，如果存在则直接让str1引用该对象，因为String str &#x3D; “abc”;已经在常量池中创建了abc对象，所以str1直接引用该对象，str &#x3D;&#x3D; str1；</p><p><strong>下面代码结果为false，说明产生了新的对象：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;abc&quot;;</span><br><span class="line">String str2 = &quot;ab&quot;; </span><br><span class="line">String str3 = str2 + &quot;c&quot;; </span><br><span class="line">System.out.println(str1 == str3);//false</span><br></pre></td></tr></table></figure><p>因为String str3 &#x3D; str2 + “c”涉及到变量（不全是常量）的相加，所以会产生新的对象，其内部实现是先new一个StringBuffer，然后append（str2）再append（“c”），然后让str3引用toString返回的对象。</p><p>tip:  </p><p>1.java中String元素下标从0开始，substring(a)是从第a个字符开始截取，包含第a个字符。可以看成数学中的[ ），表示左闭右开区间  </p><p>2.substring(a, b)表示截取下标从a开始到b结束的字符，包含第a个字符但是不包含第b个字符，可以看成[a,b)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java_String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分法案例</title>
      <link href="/2022/03/19/%E4%BA%8C%E5%88%86%E6%B3%95%E6%A1%88%E4%BE%8B/"/>
      <url>/2022/03/19/%E4%BA%8C%E5%88%86%E6%B3%95%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><h2 id="给定两个大小分别为-m-和-n-的正序（从小到大）数组-nums1-和-nums2。请你找出并返回这两个正序数组的-中位数-。算法的时间复杂度应该为-O-log-m-n-。"><a href="#给定两个大小分别为-m-和-n-的正序（从小到大）数组-nums1-和-nums2。请你找出并返回这两个正序数组的-中位数-。算法的时间复杂度应该为-O-log-m-n-。" class="headerlink" title="给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。算法的时间复杂度应该为 O(log (m+n)) 。"></a>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。算法的时间复杂度应该为 O(log (m+n)) 。</h2><p>题目是求中位数，其实就是求第 k 小数的一种特殊情况，而求第 k 小数有一种算法。<br>我们一次遍历就相当于去掉不可能是中位数的一个值，也就是一个一个排除。由于数列是有序的，其实我们完全可以一半儿一半儿的排除。假设我们要找第 k 小数，我们可以每次循环排除掉 k&#x2F;2 个数。看下边一个例子。</p><p>假设我们要找第 7 小的数字。  </p><p><img src="https://pic.leetcode-cn.com/735ea8129ab5b56b7058c6286217fa4bb5f8a198e4c8b2172fe0f75b29a966cd-image.png"></p><p>我们比较两个数组的第 k&#x2F;2 个数字，如果 k 是奇数，向下取整。也就是比较第 33 个数字，上边数组中的 44 和下边数组中的 33，如果哪个小，就表明该数组的前 k&#x2F;2 个数字都不是第 k 小数字，所以可以排除。也就是 11，22，33 这三个数字不可能是第 77 小的数字，我们可以把它排除掉。将 13491349 和 4567891045678910 两个数组作为新的数组进行比较。</p><p>更一般的情况 A[1] ，A[2] ，A[3]，A[k&#x2F;2] … ，B[1]，B[2]，B[3]，B[k&#x2F;2] … ，如果 A[k&#x2F;2]&lt;B[k&#x2F;2] ，那么A[1]，A[2]，A[3]，A[k&#x2F;2]都不可能是第 k 小的数字。</p><p>A 数组中比 A[k&#x2F;2] 小的数有 k&#x2F;2-1 个，B 数组中，B[k&#x2F;2] 比 A[k&#x2F;2] 小，假设 B[k&#x2F;2] 前边的数字都比 A[k&#x2F;2] 小，也只有 k&#x2F;2-1 个，所以比 A[k&#x2F;2] 小的数字最多有 k&#x2F;1-1+k&#x2F;2-1&#x3D;k-2个，所以 A[k&#x2F;2] 最多是第 k-1 小的数。而比 A[k&#x2F;2] 小的数更不可能是第 k 小的数了，所以可以把它们排除。</p><p>橙色的部分表示已经去掉的数字。  </p><p><img src="https://pic.leetcode-cn.com/09b8649cd2b8bbea74f7f632b098fed5f8404530ff44b5a0b54a360b3cf7dd8f-image.png"></p><p>由于我们已经排除掉了 3 个数字，就是这 3 个数字一定在最前边，所以在两个新数组中，我们只需要找第 7 - 3 &#x3D; 4 小的数字就可以了，也就是 k &#x3D; 4。此时两个数组，比较第 2 个数字，3 &lt; 5，所以我们可以把小的那个数组中的 1 ，3 排除掉了。  </p><p><img src="https://pic.leetcode-cn.com/f2d72fd3dff109ad810895b9a0c8d8782f47df6b2f24f9de72704961bc547fcb-image.png"></p><p>我们又排除掉 2 个数字，所以现在找第 4 - 2 &#x3D; 2 小的数字就可以了。此时比较两个数组中的第 k &#x2F; 2 &#x3D; 1 个数，4 &#x3D;&#x3D; 4，怎么办呢？由于两个数相等，所以我们无论去掉哪个数组中的都行，因为去掉 1 个总会保留 1 个的，所以没有影响。为了统一，我们就假设 4 &gt; 4 吧，所以此时将下边的 4 去掉。  </p><p><img src="https://pic.leetcode-cn.com/3c89a8ea29f2e19057b57242c8bc37c5f09b6796b96c30f3d42caea21c12f294-image.png"></p><p>由于又去掉 1 个数字，此时我们要找第 1 小的数字，所以只需判断两个数组中第一个数字哪个小就可以了，也就是 4。所以第 7 小的数字是 4。我们每次都是取 k&#x2F;2 的数进行比较，有时候可能会遇到数组长度小于 k&#x2F;2的时候。  </p><p><img src="https://pic.leetcode-cn.com/ad87d1f63a9bbd99e12605686290800ce61b03f9fb98d87f1d8c020d404421ac-image.png"></p><p>此时 k &#x2F; 2 等于 3，而上边的数组长度是 2，我们此时将箭头指向它的末尾就可以了。这样的话，由于 2 &lt; 3，所以就会导致上边的数组 1，2 都被排除。造成下边的情况。  </p><p><img src="https://pic.leetcode-cn.com/7ea1963f184b1dcaddf951326ccbe7aa09cfbb9ebee7fffb2ede131853b3d1de-image.png"></p><p>由于 2 个元素被排除，所以此时 k &#x3D; 5，又由于上边的数组已经空了，我们只需要返回下边的数组的第 5 个数字就可以了。</p><p>从上边可以看到，无论是找第奇数个还是第偶数个数字，对我们的算法并没有影响，而且在算法进行中，k 的值都有可能从奇数变为偶数，最终都会变为 1 或者由于一个数组空了，直接返回结果。</p><p>所以我们采用递归的思路，为了防止数组长度小于 k&#x2F;2，所以每次比较 min(k&#x2F;2，len(数组) 对应的数字，把小的那个对应的数组的数字排除，将两个新数组进入递归，并且 k 要减去排除的数字的个数。递归出口就是当 k&#x3D;1 或者其中一个数字长度是 0 了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>public double findMedianSortedArrays(int[] nums1, int[] nums2) {<br>    int n &#x3D; nums1.length;<br>    int m &#x3D; nums2.length;<br>    int left &#x3D; (n + m + 1) &#x2F; 2;<br>    int right &#x3D; (n + m + 2) &#x2F; 2;<br>    &#x2F;&#x2F;将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。<br>    return (getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) + getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)) * 0.5;<br>}</p><pre><code>private int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) &#123;    int len1 = end1 - start1 + 1;    int len2 = end2 - start2 + 1;    //让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1     if (len1 &gt; len2) return getKth(nums2, start2, end2, nums1, start1, end1, k);    if (len1 == 0) return nums2[start2 + k - 1];    if (k == 1) return Math.min(nums1[start1], nums2[start2]);    int i = start1 + Math.min(len1, k / 2) - 1;    int j = start2 + Math.min(len2, k / 2) - 1;    if (nums1[i] &gt; nums2[j]) &#123;        return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));    &#125;    else &#123;        return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1));    &#125;&#125;</code></pre><p>时间复杂度：每进行一次循环，我们就减少 k&#x2F;2 个元素，所以时间复杂度是 O(log(k)，而 k&#x3D;(m+n)&#x2F;2，所以最终的复杂也就是 O(log(m+n）O(log(m+n）。</p><p>空间复杂度：虽然我们用到了递归，但是可以看到这个递归属于尾递归，所以编译器不需要不停地堆栈，所以空间复杂度为 O(1)O(1)。</p><p>作者：windliang  </p><p>链接：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/</a>  </p><p>来源：力扣（LeetCode）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String数组初始化</title>
      <link href="/2022/03/17/String%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2022/03/17/String%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="String数组初始化"><a href="#String数组初始化" class="headerlink" title="String数组初始化"></a>String数组初始化</h1><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] str = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];   </span><br><span class="line"><span class="comment">//创建一个长度为5的String(字符串)型的一维数组</span></span><br><span class="line"></span><br><span class="line">String[] str = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;“”,””,””,””,””&#125;;</span><br><span class="line"></span><br><span class="line">String[] str = &#123;“”,””,””,””,””&#125;;</span><br></pre></td></tr></table></figure><h2 id="String数组初始化区别"><a href="#String数组初始化区别" class="headerlink" title="String数组初始化区别"></a>String数组初始化区别</h2><p>首先应该明白java数组里面存的是对象的引用，所以必须初始化才能用；</p><p>String[] str &#x3D; {“1″,”2″,”3”}与String[] str &#x3D; newString[]{“1″,”2″,”3”}在内存里有什么区别？</p><p>编译执行结果没有任何区别。更不可能像有些人想当然说的在栈上分配空间，Java的对象都是在堆上分配空间的。</p><p>这里的区别仅仅是代码书写上的：</p><ul><li><p>String[] str &#x3D; {“1″,”2″,”3”}; 这种形式叫数组初始化式(ArrayInitializer)，只能用在声明同时赋值的情况下。</p></li><li><p>String[] str &#x3D; new String[]{“1″,”2″,”3”}是一般形式的赋值，&#x3D;号的右边叫数组字面量(ArrayLiteral)，数组字面量可以用在任何需要一个数组的地方(类型兼容的情况下)。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String[] str = &#123;“<span class="number">1</span>″,”<span class="number">2</span>″,”<span class="number">3</span>”&#125;; <span class="comment">// 正确的</span></span><br><span class="line"></span><br><span class="line">String[] str = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;“<span class="number">1</span>″,”<span class="number">2</span>″,”<span class="number">3</span>”&#125; <span class="comment">// 也是正确的</span></span><br></pre></td></tr></table></figure></li></ul><p>而</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String[] str;</span><br><span class="line"></span><br><span class="line">str = &#123;“<span class="number">1</span>″,”<span class="number">2</span>″,”<span class="number">3</span>”&#125;; <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><p>因为数组初始化式只能用于声明同时赋值的情况下。</p><p>改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] str;</span><br><span class="line"></span><br><span class="line">str = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;“<span class="number">1</span>″,”<span class="number">2</span>″,”<span class="number">3</span>”&#125;; <span class="comment">// 正确了</span></span><br></pre></td></tr></table></figure><p>又如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">f</span><span class="params">(String[] str)</span> &#123;undefined&#125;</span><br><span class="line"></span><br><span class="line">f(&#123;“<span class="number">1</span>″,”<span class="number">2</span>″,”<span class="number">3</span>”&#125;); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><p>正确的应该是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">f(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123;“<span class="number">1</span>″,”<span class="number">2</span>″,”<span class="number">3</span>”&#125;);</span><br></pre></td></tr></table></figure><p>还可以  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">30</span>];</span><br></pre></td></tr></table></figure><p>如果没有显式赋值，则系统自动赋默认值null。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java_String </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
