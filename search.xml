<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2022/05/11/RabbitMQ/"/>
      <url>/2022/05/11/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h1 id="1-初识MQ"><a href="#1-初识MQ" class="headerlink" title="1.初识MQ"></a>1.初识MQ</h1><h2 id="1-1-同步和异步通讯"><a href="#1-1-同步和异步通讯" class="headerlink" title="1.1.同步和异步通讯"></a>1.1.同步和异步通讯</h2><p>微服务间通讯有同步和异步两种方式：</p><p>同步通讯：就像打电话，需要实时响应。</p><p>异步通讯：就像发邮件，不需要马上回复。</p><p><img src="/2022/05/11/RabbitMQ/image-20210717161939695.png"></p><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。</p><h3 id="1-1-1-同步通讯"><a href="#1-1-1-同步通讯" class="headerlink" title="1.1.1.同步通讯"></a>1.1.1.同步通讯</h3><p>我们之前学习的Feign调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：</p><p><img src="/2022/05/11/RabbitMQ/image-20210717162004285.png"></p><p>总结：</p><p>同步调用的优点：</p><ul><li>时效性较强，可以立即得到结果</li></ul><p>同步调用的问题：</p><ul><li>耦合度高</li><li>性能和吞吐能力下降</li><li>有额外的资源消耗</li><li>有级联失败问题</li></ul><h3 id="1-1-2-异步通讯"><a href="#1-1-2-异步通讯" class="headerlink" title="1.1.2.异步通讯"></a>1.1.2.异步通讯</h3><p>异步调用则可以避免上述问题：</p><p>我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。</p><p>在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。</p><p>订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</p><p>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。</p><p><img src="/2022/05/11/RabbitMQ/image-20210422095356088.png"></p><p>Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p><p>好处：</p><ul><li>吞吐量提升：无需等待订阅者处理完成，响应更快速</li><li>故障隔离：服务没有直接调用，不存在级联失败问题</li><li>调用间没有阻塞，不会造成无效的资源占用</li><li>耦合度极低，每个服务都可以灵活插拔，可替换</li><li>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</li></ul><p>缺点：</p><ul><li>架构复杂了，业务没有明显的流程线，不好管理</li><li>需要依赖于Broker的可靠、安全、性能</li></ul><p>好在现在开源软件或云平台上 Broker 的软件是非常成熟的，比较常见的一种就是我们今天要学习的MQ技术。</p><h2 id="1-2-技术对比："><a href="#1-2-技术对比：" class="headerlink" title="1.2.技术对比："></a>1.2.技术对比：</h2><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。</p><p>比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司&#x2F;社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p><h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h1><h2 id="2-1-安装RabbitMQ"><a href="#2-1-安装RabbitMQ" class="headerlink" title="2.1.安装RabbitMQ"></a>2.1.安装RabbitMQ</h2><p>安装RabbitMQ，参考博客：</p><p>MQ的基本结构：</p><p><img src="/2022/05/11/RabbitMQ/image-20210717162752376.png"></p><p>RabbitMQ中的一些角色：</p><ul><li>publisher：生产者</li><li>consumer：消费者</li><li>exchange个：交换机，负责消息路由</li><li>queue：队列，存储消息</li><li>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</li></ul><h2 id="2-2-RabbitMQ消息模型"><a href="#2-2-RabbitMQ消息模型" class="headerlink" title="2.2.RabbitMQ消息模型"></a>2.2.RabbitMQ消息模型</h2><p>RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型：</p><p><img src="/2022/05/11/RabbitMQ/image-20210717163332646.png"></p><h2 id="2-3-导入Demo工程"><a href="#2-3-导入Demo工程" class="headerlink" title="2.3.导入Demo工程"></a>2.3.导入Demo工程</h2><p>提供了一个Demo工程，mq-demo:</p><p>导入后可以看到结构如下：</p><p><img src="/2022/05/11/RabbitMQ/image-20210717163604330.png"></p><p>包括三部分：</p><ul><li>mq-demo：父工程，管理项目依赖</li><li>publisher：消息的发送者</li><li>consumer：消息的消费者</li></ul><h2 id="2-4-入门案例"><a href="#2-4-入门案例" class="headerlink" title="2.4.入门案例"></a>2.4.入门案例</h2><p>简单队列模式的模型图：</p><p> <img src="/2022/05/11/RabbitMQ/image-20210717163434647.png"></p><p>官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p><ul><li>publisher：消息发布者，将消息发送到队列queue</li><li>queue：消息队列，负责接受并缓存消息</li><li>consumer：订阅队列，处理队列中的消息</li></ul><h3 id="2-4-1-publisher实现"><a href="#2-4-1-publisher实现" class="headerlink" title="2.4.1.publisher实现"></a>2.4.1.publisher实现</h3><p>思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>发送消息</li><li>关闭连接和channel</li></ul><p>代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line">import com.rabbitmq.client.ConnectionFactory;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">public class PublisherTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void testSendMessage() throws IOException, TimeoutException &#123;</span><br><span class="line">        // 1.建立连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span><br><span class="line">        factory.setHost(&quot;192.168.150.101&quot;);</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        factory.setVirtualHost(&quot;/&quot;);</span><br><span class="line">        factory.setUsername(&quot;itcast&quot;);</span><br><span class="line">        factory.setPassword(&quot;123321&quot;);</span><br><span class="line">        // 1.2.建立连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        // 2.创建通道Channel</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 3.创建队列</span><br><span class="line">        String queueName = &quot;simple.queue&quot;;</span><br><span class="line">        channel.queueDeclare(queueName, false, false, false, null);</span><br><span class="line"></span><br><span class="line">        // 4.发送消息</span><br><span class="line">        String message = &quot;hello, rabbitmq!&quot;;</span><br><span class="line">        channel.basicPublish(&quot;&quot;, queueName, null, message.getBytes());</span><br><span class="line">        System.out.println(&quot;发送消息成功：【&quot; + message + &quot;】&quot;);</span><br><span class="line"></span><br><span class="line">        // 5.关闭通道和连接</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-2-consumer实现"><a href="#2-4-2-consumer实现" class="headerlink" title="2.4.2.consumer实现"></a>2.4.2.consumer实现</h3><p>代码思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>订阅消息</li></ul><p>代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">public class ConsumerTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        // 1.建立连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span><br><span class="line">        factory.setHost(&quot;192.168.150.101&quot;);</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        factory.setVirtualHost(&quot;/&quot;);</span><br><span class="line">        factory.setUsername(&quot;itcast&quot;);</span><br><span class="line">        factory.setPassword(&quot;123321&quot;);</span><br><span class="line">        // 1.2.建立连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        // 2.创建通道Channel</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        // 3.创建队列</span><br><span class="line">        String queueName = &quot;simple.queue&quot;;</span><br><span class="line">        channel.queueDeclare(queueName, false, false, false, null);</span><br><span class="line"></span><br><span class="line">        // 4.订阅消息</span><br><span class="line">        channel.basicConsume(queueName, true, new DefaultConsumer(channel)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope,</span><br><span class="line">                                       AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                // 5.处理消息</span><br><span class="line">                String message = new String(body);</span><br><span class="line">                System.out.println(&quot;接收到消息：【&quot; + message + &quot;】&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(&quot;等待接收消息。。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5.总结"></a>2.5.总结</h2><p>基本消息队列的消息发送流程：</p><ol><li>建立connection</li><li>创建channel</li><li>利用channel声明队列</li><li>利用channel向队列发送消息</li></ol><p>基本消息队列的消息接收流程：</p><ol><li>建立connection</li><li>创建channel</li><li>利用channel声明队列</li><li>定义consumer的消费行为handleDelivery()</li><li>利用channel将消费者与队列绑定</li></ol><h1 id="3-SpringAMQP"><a href="#3-SpringAMQP" class="headerlink" title="3.SpringAMQP"></a>3.SpringAMQP</h1><p>SpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。</p><p>SpringAmqp的官方地址：<a href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a></p><p><img src="/2022/05/11/RabbitMQ/image-20210717164024967.png"></p><p><img src="/2022/05/11/RabbitMQ/image-20210717164038678.png"></p><p>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息</li></ul><h2 id="3-1-Basic-Queue-简单队列模型"><a href="#3-1-Basic-Queue-简单队列模型" class="headerlink" title="3.1.Basic Queue 简单队列模型"></a>3.1.Basic Queue 简单队列模型</h2><p>在父工程mq-demo中引入依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="3-1-1-消息发送"><a href="#3-1-1-消息发送" class="headerlink" title="3.1.1.消息发送"></a>3.1.1.消息发送</h3><p>首先配置MQ地址，在publisher服务的application.yml中添加配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 192.168.150.101 # 主机名</span><br><span class="line">    port: 5672 # 端口</span><br><span class="line">    virtual-host: / # 虚拟主机</span><br><span class="line">    username: itcast # 用户名</span><br><span class="line">    password: 123321 # 密码</span><br></pre></td></tr></table></figure><p>然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class SpringAmqpTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testSimpleQueue() &#123;</span><br><span class="line">        // 队列名称</span><br><span class="line">        String queueName = &quot;simple.queue&quot;;</span><br><span class="line">        // 消息</span><br><span class="line">        String message = &quot;hello, spring amqp!&quot;;</span><br><span class="line">        // 发送消息</span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-消息接收"><a href="#3-1-2-消息接收" class="headerlink" title="3.1.2.消息接收"></a>3.1.2.消息接收</h3><p>首先配置MQ地址，在consumer服务的application.yml中添加配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 192.168.150.101 # 主机名</span><br><span class="line">    port: 5672 # 端口</span><br><span class="line">    virtual-host: / # 虚拟主机</span><br><span class="line">    username: itcast # 用户名</span><br><span class="line">    password: 123321 # 密码</span><br></pre></td></tr></table></figure><p>然后在consumer服务的<code>cn.itcast.mq.listener</code>包中新建一个类SpringRabbitListener，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class SpringRabbitListener &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = &quot;simple.queue&quot;)</span><br><span class="line">    public void listenSimpleQueueMessage(String msg) throws InterruptedException &#123;</span><br><span class="line">        System.out.println(&quot;spring 消费者接收到消息：【&quot; + msg + &quot;】&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-3-测试"><a href="#3-1-3-测试" class="headerlink" title="3.1.3.测试"></a>3.1.3.测试</h3><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息</p><h2 id="3-2-WorkQueue"><a href="#3-2-WorkQueue" class="headerlink" title="3.2.WorkQueue"></a>3.2.WorkQueue</h2><p>Work queues，也被称为（Task queues），任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。</p><p><img src="/2022/05/11/RabbitMQ/image-20210717164238910.png"></p><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p><p>此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。</p><h3 id="3-2-1-消息发送"><a href="#3-2-1-消息发送" class="headerlink" title="3.2.1.消息发送"></a>3.2.1.消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。</p><p>在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * workQueue</span><br><span class="line">     * 向队列中不停发送消息，模拟消息堆积。</span><br><span class="line">     */</span><br><span class="line">@Test</span><br><span class="line">public void testWorkQueue() throws InterruptedException &#123;</span><br><span class="line">    // 队列名称</span><br><span class="line">    String queueName = &quot;simple.queue&quot;;</span><br><span class="line">    // 消息</span><br><span class="line">    String message = &quot;hello, message_&quot;;</span><br><span class="line">    for (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">        // 发送消息</span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">        Thread.sleep(20);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-消息接收"><a href="#3-2-2-消息接收" class="headerlink" title="3.2.2.消息接收"></a>3.2.2.消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;simple.queue&quot;)</span><br><span class="line">public void listenWorkQueue1(String msg) throws InterruptedException &#123;</span><br><span class="line">    System.out.println(&quot;消费者1接收到消息：【&quot; + msg + &quot;】&quot; + LocalTime.now());</span><br><span class="line">    Thread.sleep(20);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener(queues = &quot;simple.queue&quot;)</span><br><span class="line">public void listenWorkQueue2(String msg) throws InterruptedException &#123;</span><br><span class="line">    System.err.println(&quot;消费者2........接收到消息：【&quot; + msg + &quot;】&quot; + LocalTime.now());</span><br><span class="line">    Thread.sleep(200);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这个消费者sleep了1000秒，模拟任务耗时。</p><h3 id="3-2-3-测试"><a href="#3-2-3-测试" class="headerlink" title="3.2.3.测试"></a>3.2.3.测试</h3><p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。</p><p>可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。</p><p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。</p><h3 id="3-2-4-能者多劳"><a href="#3-2-4-能者多劳" class="headerlink" title="3.2.4.能者多劳"></a>3.2.4.能者多劳</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    listener:</span><br><span class="line">      simple:</span><br><span class="line">        prefetch: 1 # 每次只能获取一条消息，处理完成才能获取下一个消息</span><br></pre></td></tr></table></figure><h3 id="3-2-5-总结"><a href="#3-2-5-总结" class="headerlink" title="3.2.5.总结"></a>3.2.5.总结</h3><p>Work模型的使用：</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h2 id="3-3-发布-x2F-订阅"><a href="#3-3-发布-x2F-订阅" class="headerlink" title="3.3.发布&#x2F;订阅"></a>3.3.发布&#x2F;订阅</h2><p>发布订阅的模型如图：  </p><p><img src="/2022/05/11/RabbitMQ/image-20210717165309625.png"></p><p>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p><ul><li>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li><li>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：<ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li></ul></li><li>Consumer：消费者，与以前一样，订阅队列，没有变化</li><li>Queue：消息队列也与以前一样，接收消息、缓存消息。</li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><h2 id="3-4-Fanout"><a href="#3-4-Fanout" class="headerlink" title="3.4.Fanout"></a>3.4.Fanout</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。</p><p><img src="/2022/05/11/RabbitMQ/image-20210717165438225.png"></p><p>在广播模式下，消息发送流程是这样的：</p><ul><li>1）  可以有多个队列</li><li>2）  每个队列都要绑定到Exchange（交换机）</li><li>3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li><li>4）  交换机把消息发送给绑定过的所有队列</li><li>5）  订阅队列的消费者都能拿到消息</li></ul><p>我们的计划是这样的：</p><ul><li>创建一个交换机 itcast.fanout，类型是Fanout</li><li>创建两个队列fanout.queue1和fanout.queue2，绑定到交换机itcast.fanout</li></ul><p><img src="/2022/05/11/RabbitMQ/image-20210717165509466.png"></p><h3 id="3-4-1-声明队列和交换机"><a href="#3-4-1-声明队列和交换机" class="headerlink" title="3.4.1.声明队列和交换机"></a>3.4.1.声明队列和交换机</h3><p>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：</p><p><img src="/2022/05/11/RabbitMQ/image-20210717165552676.png"></p><p>在consumer中创建一个类，声明队列和交换机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import org.springframework.amqp.core.Binding;</span><br><span class="line">import org.springframework.amqp.core.BindingBuilder;</span><br><span class="line">import org.springframework.amqp.core.FanoutExchange;</span><br><span class="line">import org.springframework.amqp.core.Queue;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class FanoutConfig &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 声明交换机</span><br><span class="line">     * @return Fanout类型交换机</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public FanoutExchange fanoutExchange()&#123;</span><br><span class="line">        return new FanoutExchange(&quot;itcast.fanout&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 第1个队列</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue fanoutQueue1()&#123;</span><br><span class="line">        return new Queue(&quot;fanout.queue1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 绑定队列和交换机</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding bindingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange)&#123;</span><br><span class="line">        return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 第2个队列</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue fanoutQueue2()&#123;</span><br><span class="line">        return new Queue(&quot;fanout.queue2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 绑定队列和交换机</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding bindingQueue2(Queue fanoutQueue2, FanoutExchange fanoutExchange)&#123;</span><br><span class="line">        return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-2-消息发送"><a href="#3-4-2-消息发送" class="headerlink" title="3.4.2.消息发送"></a>3.4.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testFanoutExchange() &#123;</span><br><span class="line">    // 队列名称</span><br><span class="line">    String exchangeName = &quot;itcast.fanout&quot;;</span><br><span class="line">    // 消息</span><br><span class="line">    String message = &quot;hello, everyone!&quot;;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, &quot;&quot;, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-4-3-消息接收"><a href="#3-4-3-消息接收" class="headerlink" title="3.4.3.消息接收"></a>3.4.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span><br><span class="line">public void listenFanoutQueue1(String msg) &#123;</span><br><span class="line">    System.out.println(&quot;消费者1接收到Fanout消息：【&quot; + msg + &quot;】&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span><br><span class="line">public void listenFanoutQueue2(String msg) &#123;</span><br><span class="line">    System.out.println(&quot;消费者2接收到Fanout消息：【&quot; + msg + &quot;】&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>交换机的作用是什么？</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><p>声明队列、交换机、绑定关系的Bean是什么？</p><ul><li>Queue</li><li>FanoutExchange</li><li>Binding</li></ul><h2 id="3-5-Direct"><a href="#3-5-Direct" class="headerlink" title="3.5.Direct"></a>3.5.Direct</h2><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p><p><img src="/2022/05/11/RabbitMQ/image-20210717170041447.png"></p><p> 在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p><strong>案例需求如下</strong>：</p><ol><li>利用@RabbitListener声明Exchange、Queue、RoutingKey</li><li>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</li><li>在publisher中编写测试方法，向itcast. direct发送消息</li></ol><p><img src="/2022/05/11/RabbitMQ/image-20210717170223317.png"></p><h3 id="3-5-1-基于注解声明队列和交换机"><a href="#3-5-1-基于注解声明队列和交换机" class="headerlink" title="3.5.1.基于注解声明队列和交换机"></a>3.5.1.基于注解声明队列和交换机</h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p><p>在consumer的SpringRabbitListener中添加两个消费者，同时基于注解来声明队列和交换机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(bindings = @QueueBinding(</span><br><span class="line">    value = @Queue(name = &quot;direct.queue1&quot;),</span><br><span class="line">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span><br><span class="line">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span><br><span class="line">))</span><br><span class="line">public void listenDirectQueue1(String msg)&#123;</span><br><span class="line">    System.out.println(&quot;消费者接收到direct.queue1的消息：【&quot; + msg + &quot;】&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RabbitListener(bindings = @QueueBinding(</span><br><span class="line">    value = @Queue(name = &quot;direct.queue2&quot;),</span><br><span class="line">    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),</span><br><span class="line">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span><br><span class="line">))</span><br><span class="line">public void listenDirectQueue2(String msg)&#123;</span><br><span class="line">    System.out.println(&quot;消费者接收到direct.queue2的消息：【&quot; + msg + &quot;】&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-2-消息发送"><a href="#3-5-2-消息发送" class="headerlink" title="3.5.2.消息发送"></a>3.5.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSendDirectExchange() &#123;</span><br><span class="line">    // 交换机名称</span><br><span class="line">    String exchangeName = &quot;itcast.direct&quot;;</span><br><span class="line">    // 消息</span><br><span class="line">    String message = &quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;;</span><br><span class="line">    // 发送消息</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, &quot;red&quot;, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-3-总结"><a href="#3-5-3-总结" class="headerlink" title="3.5.3.总结"></a>3.5.3.总结</h3><p>描述下Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><p>基于@RabbitListener注解声明队列和交换机有哪些常见注解？</p><ul><li>@Queue</li><li>@Exchange</li></ul><h2 id="3-6-Topic"><a href="#3-6-Topic" class="headerlink" title="3.6.Topic"></a>3.6.Topic</h2><h3 id="3-6-1-说明"><a href="#3-6-1-说明" class="headerlink" title="3.6.1.说明"></a>3.6.1.说明</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p><p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p><p> 通配符规则：</p><p><code>#</code>：匹配一个或多个词</p><p><code>*</code>：匹配不多不少恰好1个词</p><p>举例：</p><p><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></p><p><code>item.*</code>：只能匹配<code>item.spu</code></p><p>​     </p><p>图示：</p><p> <img src="/2022/05/11/RabbitMQ/image-20210717170705380.png"></p><p>解释：</p><ul><li>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</li><li>Queue2：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</li></ul><p>案例需求：</p><p>实现思路如下：</p><ol><li>并利用@RabbitListener声明Exchange、Queue、RoutingKey</li><li>在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2</li><li>在publisher中编写测试方法，向itcast. topic发送消息</li></ol><p><img src="/2022/05/11/RabbitMQ/image-20210717170829229.png"></p><h3 id="3-6-2-消息发送"><a href="#3-6-2-消息发送" class="headerlink" title="3.6.2.消息发送"></a>3.6.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * topicExchange</span><br><span class="line">     */</span><br><span class="line">@Test</span><br><span class="line">public void testSendTopicExchange() &#123;</span><br><span class="line">    // 交换机名称</span><br><span class="line">    String exchangeName = &quot;itcast.topic&quot;;</span><br><span class="line">    // 消息</span><br><span class="line">    String message = &quot;喜报！孙悟空大战哥斯拉，胜!&quot;;</span><br><span class="line">    // 发送消息</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, &quot;china.news&quot;, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-3-消息接收"><a href="#3-6-3-消息接收" class="headerlink" title="3.6.3.消息接收"></a>3.6.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-4-总结"><a href="#3-6-4-总结" class="headerlink" title="3.6.4.总结"></a>3.6.4.总结</h3><p>描述下Direct交换机与Topic交换机的差异？</p><ul><li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li><code>#</code>：代表0个或多个词</li><li><code>*</code>：代表1个词</li></ul><h2 id="3-7-消息转换器"><a href="#3-7-消息转换器" class="headerlink" title="3.7.消息转换器"></a>3.7.消息转换器</h2><p>之前说过，Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p><p><img src="/2022/05/11/RabbitMQ/image-20200525170410401.png"></p><p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>我们来测试一下。</p><h3 id="3-7-1-测试默认转换器"><a href="#3-7-1-测试默认转换器" class="headerlink" title="3.7.1.测试默认转换器"></a>3.7.1.测试默认转换器</h3><p>我们修改消息发送的代码，发送一个Map对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSendMap() throws InterruptedException &#123;</span><br><span class="line">    // 准备消息</span><br><span class="line">    Map&lt;String,Object&gt; msg = new HashMap&lt;&gt;();</span><br><span class="line">    msg.put(&quot;name&quot;, &quot;Jack&quot;);</span><br><span class="line">    msg.put(&quot;age&quot;, 21);</span><br><span class="line">    // 发送消息</span><br><span class="line">    rabbitTemplate.convertAndSend(&quot;simple.queue&quot;,&quot;&quot;, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>停止consumer服务</p><p>发送消息后查看控制台：</p><p><img src="/2022/05/11/RabbitMQ/image-20210422232835363.png"></p><h3 id="3-7-2-配置JSON转换器"><a href="#3-7-2-配置JSON转换器" class="headerlink" title="3.7.2.配置JSON转换器"></a>3.7.2.配置JSON转换器</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p><p>在publisher和consumer两个服务中都引入依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置消息转换器。</p><p>在启动类中添加一个Bean即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public MessageConverter jsonMessageConverter()&#123;</span><br><span class="line">    return new Jackson2JsonMessageConverter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ部署指南</title>
      <link href="/2022/05/11/RabbitMQ%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/"/>
      <url>/2022/05/11/RabbitMQ%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ部署指南"><a href="#RabbitMQ部署指南" class="headerlink" title="RabbitMQ部署指南"></a>RabbitMQ部署指南</h1><h1 id="1-单机部署"><a href="#1-单机部署" class="headerlink" title="1.单机部署"></a>1.单机部署</h1><p>我们在Centos7虚拟机中使用Docker来安装。</p><h2 id="1-1-下载镜像"><a href="#1-1-下载镜像" class="headerlink" title="1.1.下载镜像"></a>1.1.下载镜像</h2><p>方式一：在线拉取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:3-management</span><br></pre></td></tr></table></figure><p>上传到虚拟机中后，使用命令加载镜像即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i mq.tar</span><br></pre></td></tr></table></figure><h2 id="1-2-安装MQ"><a href="#1-2-安装MQ" class="headerlink" title="1.2.安装MQ"></a>1.2.安装MQ</h2><p>执行下面的命令来运行MQ容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=itcast \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq1 \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3-management</span><br></pre></td></tr></table></figure><h1 id="2-集群部署"><a href="#2-集群部署" class="headerlink" title="2.集群部署"></a>2.集群部署</h1><p>接下来，我们看看如何安装RabbitMQ的集群。</p><h2 id="2-1-集群分类"><a href="#2-1-集群分类" class="headerlink" title="2.1.集群分类"></a>2.1.集群分类</h2><p>在RabbitMQ的官方文档中，讲述了两种集群的配置方式：</p><ul><li>普通模式：普通模式集群不进行数据同步，每个MQ都有自己的队列、数据信息（其它元数据信息如交换机等会同步）。例如我们有2个MQ：mq1，和mq2，如果你的消息在mq1，而你连接到了mq2，那么mq2会去mq1拉取消息，然后返回给你。如果mq1宕机，消息就会丢失。</li><li>镜像模式：与普通模式不同，队列会在各个mq的镜像节点之间同步，因此你连接到任何一个镜像节点，均可获取到消息。而且如果一个节点宕机，并不会导致数据丢失。不过，这种方式增加了数据同步的带宽消耗。</li></ul><p>我们先来看普通模式集群。</p><h2 id="2-2-设置网络"><a href="#2-2-设置网络" class="headerlink" title="2.2.设置网络"></a>2.2.设置网络</h2><p>首先，我们需要让3台MQ互相知道对方的存在。</p><p>分别在3台机器中，设置 &#x2F;etc&#x2F;hosts文件，添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.150.101 mq1</span><br><span class="line">192.168.150.102 mq2</span><br><span class="line">192.168.150.103 mq3</span><br></pre></td></tr></table></figure><p>并在每台机器上测试，是否可以ping通对方：</p>]]></content>
      
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker基本操作命令</title>
      <link href="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="1-docker操作"><a href="#1-docker操作" class="headerlink" title="1.docker操作"></a>1.docker操作</h1><h2 id="1-1-镜像操作"><a href="#1-1-镜像操作" class="headerlink" title="1.1.镜像操作"></a>1.1.镜像操作</h2><h3 id="1-1-1-镜像名称"><a href="#1-1-1-镜像名称" class="headerlink" title="1.1.1. 镜像名称"></a>1.1.1. 镜像名称</h3><p>镜名称两部分组成：[repository]:[tag]。</p><p>没有指定tag时，默认是latest，代表最新版本的镜像</p><p> 如图：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731155141362.png"></p><p>mysql就是repository，5.7就是tag，</p><h3 id="1-1-2-镜像命令"><a href="#1-1-2-镜像命令" class="headerlink" title="1.1.2. 镜像命令"></a>1.1.2. 镜像命令</h3><p>常见的镜像操作命令</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731155649535.png"></p><h4 id="拉取镜像："><a href="#拉取镜像：" class="headerlink" title="拉取镜像："></a>拉取镜像：</h4><p>1、去镜像镜像仓库中搜索镜像，如DockerHub：</p><p>2、查看镜像名称，例如nginx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731155856199.png"></p><p>3、查看镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731155903037.png"></p><h4 id="保存，导入镜像"><a href="#保存，导入镜像" class="headerlink" title="保存，导入镜像"></a>保存，导入镜像</h4><p>利用 docker xx –help 命令查看docker save和docker load的语法</p><p>1、查看save命令语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save --help</span><br></pre></td></tr></table></figure><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731161104732.png"></p><p>保存（导出）命令格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o [保存的目标文件名称][镜像名称]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o nginx.tar nginx:latest</span><br></pre></td></tr></table></figure><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731161354344.png"></p><p>加载镜像：</p><p>1、删除镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi nginx:latest</span><br></pre></td></tr></table></figure><p>2、加载本地文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load i nginx.tar</span><br></pre></td></tr></table></figure><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731161746245.png"></p><h1 id="2-容器操作"><a href="#2-容器操作" class="headerlink" title="2.容器操作"></a>2.容器操作</h1><h2 id="2-1-容器相关命令"><a href="#2-1-容器相关命令" class="headerlink" title="2.1.容器相关命令"></a>2.1.容器相关命令</h2><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731161950495.png"></p><p>容器三个状态：</p><ul><li>运行</li><li>暂停：进程暂停，CPU不再运行，不释放内存</li><li>停止：进程终止，回收进程占用的内存，CPU等资源</li></ul><p>其中：</p><ul><li>docker run：创建并运行一个容器，处于运行状态</li><li>docker pause：让一个运行的容器暂停</li><li>docker unpause：让一个容器从暂停状态恢复运行</li><li>docker stop：停止一个运行的容器</li><li>docker start：让一个停止的容器再次运行</li><li>docker rm：删除一个容器，不能删除运行中的容器，除非添加 -f 参数</li></ul><h2 id="2-2-创建并运行容器"><a href="#2-2-创建并运行容器" class="headerlink" title="2.2.创建并运行容器"></a>2.2.创建并运行容器</h2><p>创建并运行nginx容器，处于运行状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name containerName -p 80:80 -d nginx</span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li><p>docker run ：创建并运行一个容器</p></li><li><p>–name : 给容器起一个名字，比如叫做mn</p></li><li><p>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</p></li><li><p>-d：后台运行容器</p></li><li><p>nginx：镜像名称，例如nginx</p></li></ul><h2 id="2-3-进入容器，修改文件（不建议）"><a href="#2-3-进入容器，修改文件（不建议）" class="headerlink" title="2.3.进入容器，修改文件（不建议）"></a>2.3.进入容器，修改文件（不建议）</h2><p>1）进入容器。进入我们刚刚创建的nginx容器的命令为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mn bash</span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li>docker exec ：进入容器内部，执行一个命令</li><li>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</li><li>mn ：要进入的容器的名称</li><li>bash：进入容器后执行的命令，bash是一个linux终端交互命令</li></ul><p>2）进入nginx的HTML所在目录 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</p><p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731164159811.png"></p><p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p><p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在<code>/usr/share/nginx/html</code></p><p>我们执行命令，进入该目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/nginx/html</span><br></pre></td></tr></table></figure><p> 查看目录下文件：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731164455818.png"></p><p>3）修改index.html的内容</p><p>容器内没有vi命令，无法直接修改，我们用下面的命令来修改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e <span class="string">&#x27;s#Hello world#g&#x27;</span> -e <span class="string">&#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#x27;</span> index.html</span><br></pre></td></tr></table></figure><h2 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4.小结"></a>2.4.小结</h2><p>docker run命令常用参数有哪些？</p><ul><li>–name：指定容器名称</li><li>-p：指定端口映射</li><li>-d：后台运行</li></ul><p>查看容器日志命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs</span><br></pre></td></tr></table></figure><p>添加 -f 参数可以持续查看日志</p><p>查看容器状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a #查看所有容器，包括已停止的</span><br></pre></td></tr></table></figure><h1 id="3-数据卷操作"><a href="#3-数据卷操作" class="headerlink" title="3.数据卷操作"></a>3.数据卷操作</h1><h2 id="3-1-数据卷定义"><a href="#3-1-数据卷定义" class="headerlink" title="3.1.数据卷定义"></a>3.1.数据卷定义</h2><p><strong>数据卷（volume）</strong>是一个虚拟目录，指向宿主机文件系统中的某个目录。</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731173541846.png"></p><p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p><p>这样，我们操作宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html目录，就等于操作容器内的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html目录了</p><h2 id="3-2-数据卷操作命令"><a href="#3-2-数据卷操作命令" class="headerlink" title="3.2.数据卷操作命令"></a>3.2.数据卷操作命令</h2><p>基本语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume [COMMAND]</span><br></pre></td></tr></table></figure><p>docker volume 命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p><ul><li>create 创建一个volume</li><li>inspect 显示一个或者多个volume的信息</li><li>ls 列出所有的volume</li><li>prune 删除一个或者多个指定的volume</li><li>rm 删除一个或者多个指定的volume</li></ul><h2 id="3-3-创建和查看数据卷"><a href="#3-3-创建和查看数据卷" class="headerlink" title="3.3.创建和查看数据卷"></a>3.3.创建和查看数据卷</h2><p>创建数据卷</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create thml</span><br></pre></td></tr></table></figure><p>查看所有数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731173746910.png"></p><p>查看数据卷详细信息卷</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect html</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731173809877.png"></p><p>可以看到，我们创建的html这个数据卷关联的宿主机目录为<code>/var/lib/docker/volumes/html/_data</code>目录。</p><h2 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4.小结"></a>3.4.小结</h2><p>数据卷作用：</p><p>将容器与数据分离、解耦合，方便操作容器内的数据，保证数据安全</p><p>数据卷操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create   #创建数据卷</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls   #查看所有数据卷</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect   #查看数据卷详细信息，包括关联的宿主机目录位置</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm #删除指定数据卷</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume prune  #删除所有未使用的数据卷</span><br></pre></td></tr></table></figure><h2 id="3-5-挂载数据卷"><a href="#3-5-挂载数据卷" class="headerlink" title="3.5.挂载数据卷"></a>3.5.挂载数据卷</h2><p>我们在创建容器时，可以通过-v参数来挂载一个数据卷到某个容器内目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">--name mn \</span><br><span class="line">-v html:/root/html \</span><br><span class="line">-p 8080:80</span><br><span class="line">-d \</span><br><span class="line">nginx \</span><br></pre></td></tr></table></figure><h2 id="3-6-挂载目录"><a href="#3-6-挂载目录" class="headerlink" title="3.6.挂载目录"></a>3.6.挂载目录</h2><p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p><ul><li>带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录</li><li>直接挂载模式：宿主机目录 —&gt; 容器内目录</li></ul><p>如图：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731175155453.png"></p><p><strong>语法</strong>：</p><p>目录挂载与数据卷挂载的语法是类似的：</p><ul><li>-v [宿主机目录]:[容器内目录]</li><li>-v [宿主机文件]:[容器内文件]</li></ul><p>创建并运行一个MySQL容器，将宿主机目录直接挂载到容器</p><p>实现思路如下：</p><p>1）将mysql.tar文件上传到虚拟机，通过load命令加载为镜像</p><p>2）创建目录&#x2F;tmp&#x2F;mysql&#x2F;data</p><p>3）创建目录&#x2F;tmp&#x2F;mysql&#x2F;conf，将mysql配置文件hmy.cnf文件上传到&#x2F;tmp&#x2F;mysql&#x2F;conf</p><p>4）去DockerHub查阅资料，创建并运行MySQL容器，要求：</p><p>① 挂载&#x2F;tmp&#x2F;mysql&#x2F;data到mysql容器内数据存储目录</p><p>② 挂载&#x2F;tmp&#x2F;mysql&#x2F;conf&#x2F;hmy.cnf到mysql容器的配置文件</p><p>③ 设置MySQL密码</p><h2 id="3-7-小结"><a href="#3-7-小结" class="headerlink" title="3.7.小结"></a>3.7.小结</h2><p>docker run的命令中通过 -v 参数挂载文件或目录到容器中：</p><ul><li>-v volume名称:容器内目录</li><li>-v 宿主机文件:容器内文</li><li>-v 宿主机目录:容器内目录</li></ul><p>数据卷挂载与目录直接挂载的</p><ul><li>数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</li><li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li></ul><h1 id="4-Dockerfile自定义镜像"><a href="#4-Dockerfile自定义镜像" class="headerlink" title="4.Dockerfile自定义镜像"></a>4.Dockerfile自定义镜像</h1><p>常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p><p>而要自定义镜像，就必须先了解镜像的结构才行。</p><h2 id="4-1-镜像结构"><a href="#4-1-镜像结构" class="headerlink" title="4.1.镜像结构"></a>4.1.镜像结构</h2><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p><p>我们以MySQL为例，来看看镜像的组成结构：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731175806273.png"></p><p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p><p>我们要构建镜像，其实就是实现上述打包的过程。</p><h2 id="4-2-Dockerfile语法"><a href="#4-2-Dockerfile语法" class="headerlink" title="4.2.Dockerfile语法"></a>4.2.Dockerfile语法</h2><p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p><p>我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。</p><p>而描述上述信息的文件就是Dockerfile文件。</p><p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731180321133.png"></p><p>更新详细语法说明，请参考官网文档： <a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p><h2 id="4-3-构建Java项目"><a href="#4-3-构建Java项目" class="headerlink" title="4.3.构建Java项目"></a>4.3.构建Java项目</h2><h3 id="4-3-1-基于Ubuntu构建Java项目"><a href="#4-3-1-基于Ubuntu构建Java项目" class="headerlink" title="4.3.1.基于Ubuntu构建Java项目"></a>4.3.1.基于Ubuntu构建Java项目</h3><p>需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目</p><ul><li><p>步骤1：新建一个空文件夹docker-demo</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210801101207444.png"></p></li><li><p>步骤2：将docker-demo.jar文件到docker-demo这个目录</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210801101314816.png"></p></li><li><p>步骤3：拷贝jdk8.tar.gz文件到docker-demo这个目录</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210801101410200.png"></p></li><li><p>步骤4：拷贝Dockerfile到docker-demo这个目录</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210801101455590.png"></p><p>其中的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 指定基础镜像</span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line"># 配置环境变量，JDK的安装目录</span><br><span class="line">ENV JAVA_DIR=/usr/local</span><br><span class="line"></span><br><span class="line"># 拷贝jdk和java项目的包</span><br><span class="line">COPY ./jdk8.tar.gz $JAVA_DIR/</span><br><span class="line">COPY ./docker-demo.jar /tmp/app.jar</span><br><span class="line"></span><br><span class="line"># 安装JDK</span><br><span class="line">RUN cd $JAVA_DIR \</span><br><span class="line"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span><br><span class="line"> &amp;&amp; mv ./jdk1.8.0_144 ./java8</span><br><span class="line"></span><br><span class="line"># 配置环境变量</span><br><span class="line">ENV JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line">ENV PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line"># 暴露端口</span><br><span class="line">EXPOSE 8090</span><br><span class="line"># 入口，java项目的启动命令</span><br><span class="line">ENTRYPOINT java -jar /tmp/app.jar</span><br></pre></td></tr></table></figure></li><li><p>步骤5：进入docker-demo</p><p>将准备好的docker-demo上传到虚拟机任意目录，然后进入docker-demo目录下</p></li><li><p>步骤6：运行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t javaweb:1.0 .</span><br></pre></td></tr></table></figure></li></ul><p>最后访问 <a href="http://192.168.150.101:8090/hello/count%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84ip%E6%94%B9%E6%88%90%E4%BD%A0%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BAip">http://192.168.150.101:8090/hello/count，其中的ip改成你的虚拟机ip</a></p><h3 id="4-4-基于java8构建Java项目"><a href="#4-4-基于java8构建Java项目" class="headerlink" title="4.4.基于java8构建Java项目"></a>4.4.基于java8构建Java项目</h3><p>虽然我们可以基于Ubuntu基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p><p>例如，构建java项目的镜像，可以在已经准备了JDK的基础镜像基础上构建。</p><p>需求：基于java:8-alpine镜像，将一个Java项目构建为镜像</p><p>实现思路如下：</p><ul><li><p>① 新建一个空的目录，然后在目录中新建一个文件，命名为Dockerfile</p></li><li><p>② 拷贝课前资料提供的docker-demo.jar到这个目录中</p></li><li><p>③ 编写Dockerfile文件：</p><p>a ）基于java:8-alpine作为基础镜像</p><p>b ）将app.jar拷贝到镜像中</p><p>c ）暴露端口</p><p>d ）编写入口ENTRYPOINT</p><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM java:8-alpine</span><br><span class="line">COPY ./app.jar /tmp/app.jar</span><br><span class="line">EXPOSE 8090</span><br><span class="line">ENTRYPOINT java -jar /tmp/app.jar</span><br></pre></td></tr></table></figure></li><li><p>④ 使用docker build命令构建镜像</p></li><li><p>⑤ 使用docker run创建容器并运行</p></li></ul><h2 id="4-5-小结"><a href="#4-5-小结" class="headerlink" title="4.5.小结"></a>4.5.小结</h2><p>小结：</p><ol><li>Dockerfile的本质是一个文件，通过指令描述镜像的构建过程</li><li>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</li><li>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</li></ol><h1 id="5-Docker-Compose"><a href="#5-Docker-Compose" class="headerlink" title="5.Docker-Compose"></a>5.Docker-Compose</h1><p>Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p><h2 id="5-1-初识DockerCompose"><a href="#5-1-初识DockerCompose" class="headerlink" title="5.1.初识DockerCompose"></a>5.1.初识DockerCompose</h2><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.8&quot;</span><br><span class="line"> services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:5.7.25</span><br><span class="line">    environment:</span><br><span class="line">     MYSQL_ROOT_PASSWORD: 123 </span><br><span class="line">    volumes:</span><br><span class="line">     - &quot;/tmp/mysql/data:/var/lib/mysql&quot;</span><br><span class="line">     - &quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">     - &quot;8090:8090&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的Compose文件就描述一个项目，其中包含两个容器：</p><ul><li>mysql：一个基于<code>mysql:5.7.25</code>镜像构建的容器，并且挂载了两个目录</li><li>web：一个基于<code>docker build</code>临时构建的镜像容器，映射端口时8090</li></ul><p>DockerCompose的详细语法参考官网：<a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p><p>其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。</p><h2 id="5-2-安装DockerCompose"><a href="#5-2-安装DockerCompose" class="headerlink" title="5.2.安装DockerCompose"></a>5.2.安装DockerCompose</h2><p>参考Centos7安装docker博客</p><h2 id="4-3-部署微服务集群"><a href="#4-3-部署微服务集群" class="headerlink" title="4.3.部署微服务集群"></a>4.3.部署微服务集群</h2><p><strong>需求</strong>：将之前学习的cloud-demo微服务集群利用DockerCompose部署</p><p><strong>实现思路</strong>：</p><p>① 查看cloud-demo文件夹，里面已经编写好了docker-compose文件</p><p>② 修改自己的cloud-demo项目，将数据库、nacos地址都命名为docker-compose中的服务名</p><p>③ 使用maven打包工具，将项目中的每个微服务都打包为app.jar</p><p>④ 将打包好的app.jar拷贝到cloud-demo中的每一个对应的子目录中</p><p>⑤ 将cloud-demo上传至虚拟机，利用 docker-compose up -d 来部署</p><h3 id="4-3-1-compose文件"><a href="#4-3-1-compose文件" class="headerlink" title="4.3.1.compose文件"></a>4.3.1.compose文件</h3><p>查看cloud-demo文件夹，里面已经编写好了docker-compose文件，而且每个微服务都准备了一个独立的目录：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210731181341330.png"></p><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.2&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  nacos:</span><br><span class="line">    image: nacos/nacos-server</span><br><span class="line">    environment:</span><br><span class="line">      MODE: standalone</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8848:8848&quot;</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:5.7.25</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: 123</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;$PWD/mysql/data:/var/lib/mysql&quot;</span><br><span class="line">      - &quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;</span><br><span class="line">  userservice:</span><br><span class="line">    build: ./user-service</span><br><span class="line">  orderservice:</span><br><span class="line">    build: ./order-service</span><br><span class="line">  gateway:</span><br><span class="line">    build: ./gateway</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;10010:10010&quot;</span><br></pre></td></tr></table></figure><p>可以看到，其中包含5个service服务：</p><ul><li><code>nacos</code>：作为注册中心和配置中心<ul><li><code>image: nacos/nacos-server</code>： 基于nacos&#x2F;nacos-server镜像构建</li><li><code>environment</code>：环境变量<ul><li><code>MODE: standalone</code>：单点模式启动</li></ul></li><li><code>ports</code>：端口映射，这里暴露了8848端口</li></ul></li><li><code>mysql</code>：数据库<ul><li><code>image: mysql:5.7.25</code>：镜像版本是mysql:5.7.25</li><li><code>environment</code>：环境变量<ul><li><code>MYSQL_ROOT_PASSWORD: 123</code>：设置数据库root账户的密码为123</li></ul></li><li><code>volumes</code>：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据</li></ul></li><li><code>userservice</code>、<code>orderservice</code>、<code>gateway</code>：都是基于Dockerfile临时构建的</li></ul><p>查看mysql目录，可以看到其中已经准备好了cloud_order、cloud_user表：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210801095205034.png"></p><p>查看微服务目录，可以看到都包含Dockerfile文件：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210801095320586.png"></p><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM java:8-alpine</span><br><span class="line">COPY ./app.jar /tmp/app.jar</span><br><span class="line">ENTRYPOINT java -jar /tmp/app.jar</span><br></pre></td></tr></table></figure><h3 id="4-3-2-修改微服务配置"><a href="#4-3-2-修改微服务配置" class="headerlink" title="4.3.2.修改微服务配置"></a>4.3.2.修改微服务配置</h3><p>因为微服务将来要部署为docker容器，而容器之间互联不是通过IP地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。</p><p>如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://mysql:3306/cloud_order?useSSL=false</span><br><span class="line">    username: root</span><br><span class="line">    password: 123</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">  application:</span><br><span class="line">    name: orderservice</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: nacos:8848 # nacos服务地址</span><br></pre></td></tr></table></figure><h3 id="4-3-3-打包"><a href="#4-3-3-打包" class="headerlink" title="4.3.3.打包"></a>4.3.3.打包</h3><p>接下来需要将我们的每个微服务都打包。因为之前查看到Dockerfile中的jar包名称都是app.jar，因此我们的每个微服务都需要用这个名称。</p><p>可以通过修改pom.xml中的打包名称来实现，每个微服务都需要修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;!-- 服务打包的最终名称 --&gt;</span><br><span class="line">  &lt;finalName&gt;app&lt;/finalName&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>打包后：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210801095951030.png"></p><h3 id="4-3-4-拷贝jar包到部署目录"><a href="#4-3-4-拷贝jar包到部署目录" class="headerlink" title="4.3.4.拷贝jar包到部署目录"></a>4.3.4.拷贝jar包到部署目录</h3><p>编译打包好的app.jar文件，需要放到Dockerfile的同级目录中。注意：每个微服务的app.jar放到与服务名称对应的目录，别搞错了。</p><p>user-service：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210801100201253.png"></p><p>order-service：</p><p>同理</p><p>gateway：</p><p>同理</p><h3 id="4-3-5-部署"><a href="#4-3-5-部署" class="headerlink" title="4.3.5.部署"></a>4.3.5.部署</h3><p>最后，我们需要将文件整个cloud-demo文件夹上传到虚拟机中，理由DockerCompose部署。</p><p>上传到任意目录：</p><p><img src="/2022/05/10/docker%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/image-20210801100955653.png"></p><p>部署：</p><p>进入cloud-demo目录，然后运行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h1 id="5-Docker镜像仓库"><a href="#5-Docker镜像仓库" class="headerlink" title="5.Docker镜像仓库"></a>5.Docker镜像仓库</h1><h2 id="5-1-搭建私有镜像仓库"><a href="#5-1-搭建私有镜像仓库" class="headerlink" title="5.1.搭建私有镜像仓库"></a>5.1.搭建私有镜像仓库</h2><p>参考博客《CentOS7安装Docker.md》</p><h2 id="5-2-推送、拉取镜像"><a href="#5-2-推送、拉取镜像" class="headerlink" title="5.2.推送、拉取镜像"></a>5.2.推送、拉取镜像</h2><p>推送镜像到私有镜像服务必须先tag，步骤如下：</p><p>① 重新tag本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080&#x2F;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:latest 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure><p>② 推送镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure><p>③ 拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7安装Docker</title>
      <link href="/2022/05/10/Centos7%E5%AE%89%E8%A3%85Docker/"/>
      <url>/2022/05/10/Centos7%E5%AE%89%E8%A3%85Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>Docker CE 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p><p>官方网站上有各种环境下的 <a href="https://docs.docker.com/install/">安装指南</a>，这里主要介绍 Docker CE 在 CentOS上的安装。</p><h1 id="1-CentOS安装Docker"><a href="#1-CentOS安装Docker" class="headerlink" title="1.CentOS安装Docker"></a>1.CentOS安装Docker</h1><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。</p><h2 id="1-1-卸载（可选）"><a href="#1-1-卸载（可选）" class="headerlink" title="1.1.卸载（可选）"></a>1.1.卸载（可选）</h2><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine \</span><br><span class="line">                  docker-ce</span><br></pre></td></tr></table></figure><h2 id="1-2-安装docker"><a href="#1-2-安装docker" class="headerlink" title="1.2.安装docker"></a>1.2.安装docker</h2><p>首先需要大家虚拟机联网，安装yum工具</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2 --skip-broken</span><br></pre></td></tr></table></figure><p>然后更新本地镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置docker镜像源</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line">sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><p>然后输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure><p>docker-ce为社区免费版本。稍等片刻，docker即可安装成功。</p><h2 id="1-3-启动docker"><a href="#1-3-启动docker" class="headerlink" title="1.3.启动docker"></a>1.3.启动docker</h2><p>Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！</p><p>启动docker前，一定要关闭防火墙后！！</p><p>启动docker前，一定要关闭防火墙后！！</p><p>启动docker前，一定要关闭防火墙后！！</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment"># 禁止开机启动防火墙</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><p>通过命令启动docker：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker  <span class="comment"># 启动docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl stop docker  <span class="comment"># 停止docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl restart docker  <span class="comment"># 重启docker服务</span></span><br></pre></td></tr></table></figure><p>然后输入命令，可以查看docker版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="/2022/05/10/Centos7%E5%AE%89%E8%A3%85Docker/image-20210418154704436.png"> </p><h2 id="1-4-配置镜像加速"><a href="#1-4-配置镜像加速" class="headerlink" title="1.4.配置镜像加速"></a>1.4.配置镜像加速</h2><p>docker官方镜像仓库网速较差，我们需要设置国内镜像服务：</p><p>参考阿里云的镜像加速文档：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p><h1 id="2-CentOS7安装DockerCompose"><a href="#2-CentOS7安装DockerCompose" class="headerlink" title="2.CentOS7安装DockerCompose"></a>2.CentOS7安装DockerCompose</h1><h2 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1.下载"></a>2.1.下载</h2><p>Linux下需要通过命令下载：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`<span class="built_in">uname</span> -s`-`<span class="built_in">uname</span> -m` &gt; /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>如果下载速度较慢，或者下载失败，可以使用资料提供的docker-compose文件：</p><p>上传到<code>/usr/local/bin/</code>目录也可以。</p><h2 id="2-2-修改文件权限"><a href="#2-2-修改文件权限" class="headerlink" title="2.2.修改文件权限"></a>2.2.修改文件权限</h2><p>修改文件权限：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h2 id="2-3-Base自动补全命令："><a href="#2-3-Base自动补全命令：" class="headerlink" title="2.3.Base自动补全命令："></a>2.3.Base自动补全命令：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 补全命令</span><br><span class="line">curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure><p>如果这里出现错误，需要修改自己的hosts文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;199.232.68.133 raw.githubusercontent.com&quot;</span> &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><h1 id="3-Docker镜像仓库"><a href="#3-Docker镜像仓库" class="headerlink" title="3.Docker镜像仓库"></a>3.Docker镜像仓库</h1><p>搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。</p><p>官网地址：<a href="https://hub.docker.com/_/registry">https://hub.docker.com/_/registry</a></p><h2 id="3-1-简化版镜像仓库"><a href="#3-1-简化版镜像仓库" class="headerlink" title="3.1.简化版镜像仓库"></a>3.1.简化版镜像仓库</h2><p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p><p>搭建方式比较简单，命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --restart=always \</span><br><span class="line">    --name registry\</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v registry-data:/var/lib/registry \</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure><p>命令中挂载了一个数据卷registry-data到容器内的&#x2F;var&#x2F;lib&#x2F;registry 目录，这是私有镜像库存放数据的目录。</p><p>访问<a href="http://yourip:5000/v2/_catalog">http://YourIp:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p><h2 id="3-2-配置Docker信任地址"><a href="#3-2-配置Docker信任地址" class="headerlink" title="3.2.配置Docker信任地址"></a>3.2.配置Docker信任地址</h2><p>我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开要修改的文件</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="comment"># 添加内容：</span></span><br><span class="line"><span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;http://192.168.150.101:8080&quot;</span>]</span><br><span class="line"><span class="comment"># 重加载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="3-3-带有图形化界面版本"><a href="#3-3-带有图形化界面版本" class="headerlink" title="3.3.带有图形化界面版本"></a>3.3.带有图形化界面版本</h2><p>新建文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir registry-ui</span><br></pre></td></tr></table></figure><p>进入文件夹新建yml文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd registry-ui/</span><br><span class="line">ll</span><br><span class="line">touch docker-compose.yml</span><br></pre></td></tr></table></figure><p>编辑docker-compose.yml文件</p><p>使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3.0&#x27;</span><br><span class="line">services:</span><br><span class="line">  registry:</span><br><span class="line">    image: registry</span><br><span class="line">    volumes:</span><br><span class="line">      - ./registry-data:/var/lib/registry</span><br><span class="line">  ui:</span><br><span class="line">    image: joxit/docker-registry-ui:static</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:80</span><br><span class="line">    environment:</span><br><span class="line">      - REGISTRY_TITLE=MyOceanus私有仓库</span><br><span class="line">      - REGISTRY_URL=http://registry:5000</span><br><span class="line">    depends_on:</span><br><span class="line">      - registry</span><br></pre></td></tr></table></figure><p>执行docker-compose文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>查看日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs -f</span><br></pre></td></tr></table></figure><p>在私有镜像仓库推送或者拉取镜像</p><p>推送tag本地镜像，名称前缀为私有仓库的地址：192.168.25.128:8080&#x2F;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:latest 192.168.25.128:8080/nginx:1.0</span><br></pre></td></tr></table></figure><p>推送镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.25.128:8080/nginx:1.0</span><br></pre></td></tr></table></figure><p>拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 192.168.25.128:8080/nginx:1.0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos安装</title>
      <link href="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/"/>
      <url>/2022/05/09/Nacos%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Nacos安装指南"><a href="#Nacos安装指南" class="headerlink" title="Nacos安装指南"></a>Nacos安装指南</h1><h1 id="1-Windows安装"><a href="#1-Windows安装" class="headerlink" title="1.Windows安装"></a>1.Windows安装</h1><p>开发阶段采用单机安装即可。</p><h2 id="1-1-下载安装包"><a href="#1-1-下载安装包" class="headerlink" title="1.1.下载安装包"></a>1.1.下载安装包</h2><p>在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：</p><p>GitHub主页：<a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></p><p>GitHub的Release下载页：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><p>如图：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402161102887.png"></p><p>采用1.4.1.版本的Nacos</p><p>windows版本使用<code>nacos-server-1.4.1.zip</code>包即可。</p><h2 id="1-2-解压"><a href="#1-2-解压" class="headerlink" title="1.2.解压"></a>1.2.解压</h2><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402161843337.png"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><h2 id="1-3-端口配置"><a href="#1-3-端口配置" class="headerlink" title="1.3.端口配置"></a>1.3.端口配置</h2><p>Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。</p><p><strong>如果无法关闭占用8848端口的进程</strong>，也可以进入nacos的conf目录，修改配置文件中的端口：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402162008280.png"></p><p>修改其中的内容：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402162251093.png"></p><h2 id="1-4-启动"><a href="#1-4-启动" class="headerlink" title="1.4.启动"></a>1.4.启动</h2><p>启动非常简单，进入bin目录，结构如下：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402162350977.png"></p><p>然后执行命令即可：</p><ul><li><p>windows命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure></li></ul><p>执行后的效果如图：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402162526774.png"></p><h2 id="1-5-访问"><a href="#1-5-访问" class="headerlink" title="1.5.访问"></a>1.5.访问</h2><p>在浏览器输入地址：<a href="http://127.0.0.1:8848/nacos%E5%8D%B3%E5%8F%AF%EF%BC%9A">http://127.0.0.1:8848/nacos即可：</a></p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402162630427.png"></p><p>默认的账号和密码都是nacos，进入后：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402162709515.png"></p><h1 id="2-Linux安装"><a href="#2-Linux安装" class="headerlink" title="2.Linux安装"></a>2.Linux安装</h1><p>Linux或者Mac安装方式与Windows类似。</p><h2 id="2-1-安装JDK"><a href="#2-1-安装JDK" class="headerlink" title="2.1.安装JDK"></a>2.1.安装JDK</h2><p>Nacos依赖于JDK运行，索引Linux上也需要安装JDK才行。</p><p>上传jdk安装包：</p><p>上传到某个目录，例如：<code>/usr/local/</code></p><p>然后解压缩：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf jdk-8u144-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>然后重命名为java</p><p>配置环境变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/local/java</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure><p>设置环境变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h2 id="2-2-上传安装包"><a href="#2-2-上传安装包" class="headerlink" title="2.2.上传安装包"></a>2.2.上传安装包</h2><p>如图：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402161102887.png"></p><p>也可以直接使用资料中的tar.gz：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402161130261.png"></p><p>上传到Linux服务器的某个目录，例如<code>/usr/local/src</code>目录下：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402163715580.png"></p><h2 id="2-3-解压"><a href="#2-3-解压" class="headerlink" title="2.3.解压"></a>2.3.解压</h2><p>命令解压缩安装包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf nacos-server-1.4.1.tar.gz</span><br></pre></td></tr></table></figure><p>然后删除安装包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf nacos-server-1.4.1.tar.gz</span><br></pre></td></tr></table></figure><p>目录中最终样式：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402163858429.png"></p><p>目录内部：</p><p><img src="/2022/05/09/Nacos%E5%AE%89%E8%A3%85/image-20210402164414827.png"></p><h2 id="2-4-端口配置"><a href="#2-4-端口配置" class="headerlink" title="2.4.端口配置"></a>2.4.端口配置</h2><p>与windows中类似</p><h2 id="2-5-启动"><a href="#2-5-启动" class="headerlink" title="2.5.启动"></a>2.5.启动</h2><p>在nacos&#x2F;bin目录中，输入命令启动Nacos：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh startup.sh -m standalone</span><br></pre></td></tr></table></figure><h1 id="3-Nacos的依赖"><a href="#3-Nacos的依赖" class="headerlink" title="3.Nacos的依赖"></a>3.Nacos的依赖</h1><p>父工程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos客户端依赖包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker安装常用镜像</title>
      <link href="/2022/04/24/docker%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E9%95%9C%E5%83%8F/"/>
      <url>/2022/04/24/docker%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="安装常用镜像"><a href="#安装常用镜像" class="headerlink" title="安装常用镜像"></a>安装常用镜像</h1><h2 id="安装-mysql"><a href="#安装-mysql" class="headerlink" title="安装 mysql"></a>安装 mysql</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:8.0</span><br></pre></td></tr></table></figure><h2 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h2><p>设置时区和宿主机相同启动，启动镜像名称为 mysql，前面一个端口是映射端口，root是数据库密码， -v &#x2F;etc&#x2F;localtime:&#x2F;etc&#x2F;localtime是设置时区与宿主机一致，&#x2F;data&#x2F;docker&#x2F;mysql 是宿主机目录用来保存 mysql 的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql -p 3306:3306  -e MYSQL_ROOT_PASSWORD=123456 -v /etc/localtime:/etc/localtime  -v /data/docker/mysql:/var/lib/mysql -d mysql:8.0</span><br></pre></td></tr></table></figure><h2 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull reids:5.0.4</span><br></pre></td></tr></table></figure><p>启动镜像名称为 redis，前面一个端口是映射端口，&#x2F;data&#x2F;docker&#x2F;redis是宿主机数据保存地址 ，appendonly yes是后台启动，<strong>requirepass “root”</strong>是设置密码为root</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 -v /data/docker/redis:/data -d redis:5.0.4 redis-server --appendonly yes --requirepass &quot;root&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start redis</span><br></pre></td></tr></table></figure><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><h2 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h2><p><img src="/2022/04/24/docker%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E9%95%9C%E5%83%8F/1650806080538.png" alt="1650806080538"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux_docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装docker</title>
      <link href="/2022/04/24/Linux%E5%AE%89%E8%A3%85docker/"/>
      <url>/2022/04/24/Linux%E5%AE%89%E8%A3%85docker/</url>
      
        <content type="html"><![CDATA[<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>Docker 两个分支Docker： CE 即社区免费版，Docker EE 即企业版，需付费<br>官方建议要 CentOS7.0 及以上系统版本<br>运行CentOS 6.5及以后版本时，需要内核版本&gt;&#x3D;2.6.32-431</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><p><img src="/2022/04/24/Linux%E5%AE%89%E8%A3%85docker/1650799097982.png" alt="1650799097982"></p><p>3.10OK</p><p>Docker默认使用AUFS作为存储驱动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /sys/class/misc/device-mapper</span><br></pre></td></tr></table></figure><p><img src="/2022/04/24/Linux%E5%AE%89%E8%A3%85docker/1650799973562.png" alt="1650799973562"></p><p><img src="/2022/04/24/Linux%E5%AE%89%E8%A3%85docker/1650799851866.png" alt="1650799851866"></p><p>如果没有检测到Device Mapper，需要安装device-mapper软件包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y device-mapper</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe dm_mod</span><br></pre></td></tr></table></figure><p><img src="/2022/04/24/Linux%E5%AE%89%E8%A3%85docker/1650799894545.png" alt="1650799894545"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure><p><img src="/2022/04/24/Linux%E5%AE%89%E8%A3%85docker/1650800016237.png" alt="1650800016237"></p><p><img src="/2022/04/24/Linux%E5%AE%89%E8%A3%85docker/1650800042659.png" alt="1650800042659"></p><h2 id="如安装过，卸载旧版本"><a href="#如安装过，卸载旧版本" class="headerlink" title="如安装过，卸载旧版本"></a>如安装过，卸载旧版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine</span><br></pre></td></tr></table></figure><p><img src="/2022/04/24/Linux%E5%AE%89%E8%A3%85docker/1650800058886.png" alt="1650800058886"></p><h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><h2 id="设置stable镜像仓库"><a href="#设置stable镜像仓库" class="headerlink" title="设置stable镜像仓库"></a>设置stable镜像仓库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h2 id="更新yum软件包索引"><a href="#更新yum软件包索引" class="headerlink" title="更新yum软件包索引"></a>更新yum软件包索引</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><h2 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce.x86_64  --showduplicates | sort -r</span><br></pre></td></tr></table></figure><h2 id="安装指定版本"><a href="#安装指定版本" class="headerlink" title="安装指定版本"></a>安装指定版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce-18.09.9 docker-ce-cli-18.09.9 containerd.io</span><br></pre></td></tr></table></figure><h2 id="安装最新版本"><a href="#安装最新版本" class="headerlink" title="安装最新版本"></a>安装最新版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure><h2 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h2 id="验证是否安装成功"><a href="#验证是否安装成功" class="headerlink" title="验证是否安装成功"></a>验证是否安装成功</h2>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><h2 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="查看docker版本"><a href="#查看docker版本" class="headerlink" title="查看docker版本"></a>查看docker版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><h2 id="搜索镜像-start代表受欢迎程度。OFFICIAL代表官方版本"><a href="#搜索镜像-start代表受欢迎程度。OFFICIAL代表官方版本" class="headerlink" title="搜索镜像-start代表受欢迎程度。OFFICIAL代表官方版本"></a>搜索镜像-start代表受欢迎程度。OFFICIAL代表官方版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search tomcat</span><br></pre></td></tr></table></figure><h2 id="查看当前所有镜像"><a href="#查看当前所有镜像" class="headerlink" title="查看当前所有镜像"></a>查看当前所有镜像</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><h3 id="下载镜像-1"><a href="#下载镜像-1" class="headerlink" title="下载镜像"></a>下载镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run centos echo &quot;hello word&quot;</span><br></pre></td></tr></table></figure><h3 id="运行容器-hello-word"><a href="#运行容器-hello-word" class="headerlink" title="运行容器 hello word"></a>运行容器 hello word</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="列出docker包的具体的名字"><a href="#列出docker包的具体的名字" class="headerlink" title="列出docker包的具体的名字"></a>列出docker包的具体的名字</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum list  installed | grep docker</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">containerd.io.x86_64                 1.2.4-3.1.el7 </span><br><span class="line">docker-ce.x86_64                     3:18.09.3-3.el7</span><br><span class="line">docker-ce-cli.x86_64                 1:18.09.3-3.el7</span><br></pre></td></tr></table></figure><h3 id="删除docker"><a href="#删除docker" class="headerlink" title="删除docker"></a>删除docker</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y remove containerd.io.x86_64 \</span><br></pre></td></tr></table></figure><p>或者</p><h3 id="直接删除docker"><a href="#直接删除docker" class="headerlink" title="直接删除docker"></a>直接删除docker</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-io \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><h3 id="清除镜像和容器文件："><a href="#清除镜像和容器文件：" class="headerlink" title="清除镜像和容器文件："></a>清除镜像和容器文件：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure><h1 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h1><h2 id="Docker国内镜像："><a href="#Docker国内镜像：" class="headerlink" title="Docker国内镜像："></a>Docker国内镜像：</h2><p>网易加速器：<a href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a><br>官方中国加速器：<a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a><br>ustc的镜像：<a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a><br>也可使用私人镜像加速器地址，如使用阿里云的镜像加速器：登录阿里云-&gt;产品-&gt;搜索”容器镜像服务”-&gt;镜像库-&gt;镜像加速器。</p><p>新版的 Docker 使用 &#x2F;etc&#x2F;docker&#x2F;daemon.json（Linux） 来配置 Daemon。</p><p>请在该配置文件中加入（没有该文件的话，请先建一个）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/docker/daemon.json </span><br><span class="line">&#123; </span><br><span class="line">　　&quot;registry-mirrors&quot;: [&quot;https://hub-mirror.c.163.com&quot;] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置成功后，CentOS7重启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload     #重启加速配置文件</span><br><span class="line">systemctl restart docker    #重启docker后台服务</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux安装docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器常用命令</title>
      <link href="/2022/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="一般情况下，网站（PHP后端）突然无法打开可以尝试重启服务"><a href="#一般情况下，网站（PHP后端）突然无法打开可以尝试重启服务" class="headerlink" title="一般情况下，网站（PHP后端）突然无法打开可以尝试重启服务"></a>一般情况下，网站（PHP后端）突然无法打开可以尝试重启服务</h3><p>1.服务器重启命令：reboot<br>2.php-fpm重启命令：service php-fpm restart</p><h3 id="使用nginx的服务器，有时候网站配置后，出现ngnix报错可以先检查下网站的Nginx配置文件是否出现错误"><a href="#使用nginx的服务器，有时候网站配置后，出现ngnix报错可以先检查下网站的Nginx配置文件是否出现错误" class="headerlink" title="使用nginx的服务器，有时候网站配置后，出现ngnix报错可以先检查下网站的Nginx配置文件是否出现错误"></a>使用nginx的服务器，有时候网站配置后，出现ngnix报错可以先检查下网站的Nginx配置文件是否出现错误</h3><p>1.检查nginx语法 : nginx -tc 目录&#x2F;配置文件.conf<br>例子：nginx -tc &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</p><h3 id="文件解、压缩"><a href="#文件解、压缩" class="headerlink" title="文件解、压缩"></a>文件解、压缩</h3><p>1.压缩打包命令：tar -zcvf &#x2F;data&#x2F;wwwroot&#x2F;###.tar.gz 目标文件夹名<br>2.解压命令：tar -xzvf file.tar.gz<br>例子：<br>(将abc文件夹打包压缩为abc.tar.gz)：tar -zcvf &#x2F;data&#x2F;wwwroot&#x2F;abc.tar.gz abc<br>(将abc.tar.gz解压） tar -xzvf abc.tar.gz</p><h3 id="服务器之间拷贝文件"><a href="#服务器之间拷贝文件" class="headerlink" title="服务器之间拷贝文件"></a>服务器之间拷贝文件</h3><p>1.将文件拷贝到另一台服务器：<br>scp &#x2F;data&#x2F;wwwroot&#x2F;666.tar.gz <a href="mailto:&#114;&#x6f;&#x6f;&#x74;&#64;&#x31;&#49;&#49;&#46;&#x31;&#x31;&#x2e;&#49;&#x31;&#46;&#x31;&#x31;&#49;">&#114;&#x6f;&#x6f;&#x74;&#64;&#x31;&#49;&#49;&#46;&#x31;&#x31;&#x2e;&#49;&#x31;&#46;&#x31;&#x31;&#49;</a>:&#x2F;data&#x2F;wwwroot&#x2F;<br>2.从另一台服务器拷贝文件：<br>scp <a href="mailto:&#114;&#x6f;&#x6f;&#116;&#64;&#50;&#x32;&#x32;&#x2e;&#50;&#50;&#x2e;&#x32;&#50;&#46;&#x32;&#50;&#50;">&#114;&#x6f;&#x6f;&#116;&#64;&#50;&#x32;&#x32;&#x2e;&#50;&#50;&#x2e;&#x32;&#50;&#46;&#x32;&#50;&#50;</a>:&#x2F;data&#x2F;wwwroot&#x2F;weixin.tar.gz &#x2F;data&#x2F;wwwroot</p><h3 id="数据库导出（mysqldump命令）"><a href="#数据库导出（mysqldump命令）" class="headerlink" title="数据库导出（mysqldump命令）"></a>数据库导出（mysqldump命令）</h3><h4 id="导出整个数据库"><a href="#导出整个数据库" class="headerlink" title="导出整个数据库"></a>导出整个数据库</h4><p>mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名<br>mysqldump -u linuxde -p data &gt; 目录&#x2F;linuxde.sql</p><h4 id="导出一个表"><a href="#导出一个表" class="headerlink" title="导出一个表"></a>导出一个表</h4><p>mysqldump -u 用户名 -p 数据库名 表名 &gt; 导出的文件名<br>mysqldump -u linuxde -p data users &gt; linuxde_users.sql</p><p>基本命令格（[xxx]中的内容根据实际情况改动）</p><p>mysqldump -u [username] -p -d [databaseName] [tableName] &gt;<br>[路径及导出的sql文件名];</p><p>1、导出数据库dbname的表结构<br>mysqldump -u root -p -d dbname &gt;db.sql;</p><p>2、导出数据库dbname所有表结构及表數據（不加-d）<br>mysqldump -u root -p dbname &gt;db.sql;</p><p>3、导出数据库dbname某张表的结构<br>mysqldump -uroot -pdbpasswd -d dbname test&gt;db.sql;</p><p>4、导出数据库dbname某张表(test)结构及表数据（不加-d）<br>mysqldump -u root -p dbname test&gt;db.sql;</p><h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><p>centos从7开始默认用的是firewalld，这个是基于iptables的，虽然有iptables的核心，但是iptables的服务是没安装的。所以你只要停止firewalld服务即可：</p><p>sudo systemctl stop firewalld.service &amp;&amp; sudo systemctl disable firewalld.service</p><p>如果你要改用iptables的话，需要安装iptables服务：<br>sudo yum install iptables-services<br>sudo systemctl enable iptables &amp;&amp; sudo systemctl enable ip6tables<br>sudo systemctl start iptables &amp;&amp; sudo systemctl start ip6tables</p><h3 id="搜索文件，查看文件内容"><a href="#搜索文件，查看文件内容" class="headerlink" title="搜索文件，查看文件内容"></a>搜索文件，查看文件内容</h3><p>find . -name ‘srm*’ 　　#表示当前目录下查找文件名开头是字符串‘srm’的文件</p><p>grep -A 5 foo file 显示file文件里匹配foo字串那行以foo及后5行<br>grep -B 5 foo file 显示file文件里匹配foo字串那行以foo及前5行<br>grep -C 5 foo file 显示file文件里匹配foo字串那行以及上下5行</p><p>1、查看最后1000行的数据<br>cat filename | tail -n 1000<br>2、查看1000到3000行的数据<br>cat filename | head -n 3000 | tail -n +1000<br>注：管道符的作用 | 将前面的结果作为后面结果的输出。<br>3、打印文件所有内容<br>cat filename<br>4、打印文件最后1000行的数据<br>tail -n 1000<br>5、打印文件第1000行开始以后的内容<br>tail -n +1000<br>6、打印前1000的内容<br>head -n 1000<br>7、显示1000到300行的数据<br>sed -n ‘1000,3000p’ filename</p><h3 id="创建软连接（ln-s-命令）"><a href="#创建软连接（ln-s-命令）" class="headerlink" title="创建软连接（ln -s 命令）"></a>创建软连接（ln -s 命令）</h3><p>具体用法：ln -s 源文件 软连接的位置<br>例：安装maven后直接使用mvn会出现 -bash: mvn: command not found的错误，这就需要增加一个软连接：<br>ln -s &#x2F;home&#x2F;maven&#x2F;bin&#x2F;mvn &#x2F;usr&#x2F;bin&#x2F;mvn<br>执行完，即可使用mvn命令。</p><h2 id="查看服务器硬件资源信息"><a href="#查看服务器硬件资源信息" class="headerlink" title="查看服务器硬件资源信息"></a>查看服务器硬件资源信息</h2><h3 id="内存：free-h"><a href="#内存：free-h" class="headerlink" title="内存：free -h"></a>内存：free -h</h3><p><img src="/2022/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1650765357355.png" alt="1650765357355"></p><h3 id="硬盘：df-h"><a href="#硬盘：df-h" class="headerlink" title="硬盘：df -h"></a>硬盘：df -h</h3><p><img src="/2022/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1650765373449.png" alt="1650765373449"></p><h3 id="负载：top（进入后-按Q键退出）-或者-w-（此处使用w）"><a href="#负载：top（进入后-按Q键退出）-或者-w-（此处使用w）" class="headerlink" title="负载：top（进入后 按Q键退出） 或者 w （此处使用w）"></a>负载：top（进入后 按<strong>Q键</strong>退出） 或者 w （此处使用w）</h3><p><img src="/2022/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1650765489808.png" alt="1650765489808"></p><p>load average 后的三个值表示最近一分钟、最近五分钟、最近15分钟的负载。若接近1，服务器就满负荷运载了。</p><h3 id="查看cpu信息：cat-x2F-proc-x2F-cpuinfo"><a href="#查看cpu信息：cat-x2F-proc-x2F-cpuinfo" class="headerlink" title="查看cpu信息：cat &#x2F;proc&#x2F;cpuinfo"></a>查看cpu信息：cat &#x2F;proc&#x2F;cpuinfo</h3><p><img src="/2022/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1650765598491.png" alt="1650765598491"></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>1、cd                                    作用： 进入文件夹</p><p>2、ps  -ef|grep   服务包名称     作用：查看服务的进程号以及判断该服务是否处于生存状态</p><p>3、kill -9   xxxx     作用：杀死进程号为xxxx的进程。</p><p>4、gedit      xxx                  作用：打开并编辑xxx文件</p><p>5、vi  xxx                          作用：编辑xxx文件 </p><p>6、vi配套命令，按住i，进入插入模式，编辑完成后按esc键退出编辑模式，:wq 回车保存，:q!强制退出不保存 。</p><p>7、ls                                     作用：查看当前文件夹下的文件列表</p><p>8、ls -l                  作用：查看当前文件夹下的文件列表以及相关信息比如创建时间、权限信息。</p><p> 9、find    &#x2F;  -name  xxx        作用：从根目录开始查找名为xxx的文件或文件夹</p><p>10、pwd               作用：查看当前所在目录</p><p>11、whereis  xxx    作用：搜索xxx文件或者命令</p><p>12、chmod  777  xxx     作用：是给xxx文件或者文件夹授予最高权限</p><p>13、sudo su    作用：切换为超级管理员</p><p>14、cat  xxx    作用：查看某个文件或者配置信息，经常用来查看日志</p><p>15、tail xxx   作用：查看某个文件，默认最后十行</p><p>16、apt  install  xxxx  作用：在线包管理安装命令,安装xxxx软件</p><p>17、dpkg -i   xxxx     作用：安装离线本地包xxxx</p><p>18、cp -r  原路径文件夹或文件      目的路径文件夹   作用：将文件夹或文件 复制到目的文件夹下</p><p>19、tar zxvf xxxx.tar   作用：解压后缀为.tar的压缩包。（注：压缩命令较多，压缩包后缀不同使用的解压和压缩的命令也不相同）</p><p>20、ip addr 或 ifconfig   作用：查看当前ip地址</p><h2 id="后台启动Java项目"><a href="#后台启动Java项目" class="headerlink" title="后台启动Java项目"></a>后台启动Java项目</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar springboot-0.0.1-SNAPSHOT.jar &amp;</span><br></pre></td></tr></table></figure><p><img src="/2022/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1650846711516.png" alt="1650846711516"></p><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat nohup.out</span><br></pre></td></tr></table></figure><p><img src="/2022/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1650846949085.png" alt="1650846949085"></p><h3 id="查看java启动情况"><a href="#查看java启动情况" class="headerlink" title="查看java启动情况"></a>查看java启动情况</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep java</span><br></pre></td></tr></table></figure><p><img src="/2022/04/24/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1650848408672.png" alt="1650848408672"></p><h3 id="关闭java"><a href="#关闭java" class="headerlink" title="关闭java"></a>关闭java</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 19209</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库导出文件</title>
      <link href="/2022/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%BC%E5%87%BA%E6%96%87%E4%BB%B6/"/>
      <url>/2022/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%BC%E5%87%BA%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h2><p>DataGrip有多种数据导出模式，常用的有两种：</p><ul><li><code>Dump Data to File</code></li><li><code>Dump with &#39;mysqldump&#39;</code></li></ul><p><img src="https://img.jbzj.com/file_images/article/202109/20210917114438109.png" alt="图片"></p><p>&#96;&#96;Dump Data to File&#96;模式，该模式是导出各种单个文件，比如，SQL，HTML，TSV，CSV等文件，当然这是我们在对某个表进行操作的时候使用的。</p><p><img src="https://img.jbzj.com/file_images/article/202109/20210917114438110.png" alt="图片"></p><p><code>Dump with &#39;mysqldump&#39;</code>模式，该模式是使用MySql的<code>mysqldump</code>组件进行数据导出，该方法导出的SQL文件，可以选择，是否包含数据或者是只导出数据结构。该模式是我们常用的数据库导出。下面对该模式进行说明。</p><ul><li><code>Path to mysqldump</code>选择你的<code>mysqldump</code>在本地磁盘的位置</li><li><code>Statements</code>选择模式</li><li><code>Databases</code>需要导出的数据库(不可选择，默认当前右键选中的)</li><li><code>Tables</code>需要导出的表(不可选择，默认当前右键选中的)</li><li>多选框，根据自己需求进行选择，一般默认即可</li><li><code>Out path</code>导出路径</li></ul><h2 id="导出数据结构及数据"><a href="#导出数据结构及数据" class="headerlink" title="导出数据结构及数据"></a>导出数据结构及数据</h2><blockquote><p>如果第一次导出，应该会出现<code>Can&#39;t create/write to file</code>这个错误，这时候，需要在<code>Out path</code>后面，手动添加上，需要导出的文件，例如下图，<code>test.sql</code>即可</p></blockquote><p><img src="https://img.jbzj.com/file_images/article/202109/20210917114438111.png" alt="图片"></p><h3 id="导出结构"><a href="#导出结构" class="headerlink" title="导出结构"></a>导出结构</h3><blockquote><p>导出结构与上面基本一致，只是在下面命令行的表名前面，添加一个<code>-d</code>记住，后面要添加一个空格，如下图</p></blockquote><p><img src="https://img.jbzj.com/file_images/article/202109/20210917114439112.png" alt="图片"></p><h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><p>导入数据刚开始，是一直困惑我的问题，因为<code>Import Data from File</code>这个功能貌似不是那么回事，后来发现，一个很神奇的东西。</p><p>操作步骤如下</p><ul><li>将sql文件，拖拽到DataGrip中</li><li>在需要导入数据的sql的tab上，右键</li><li>点击最下面的<code>Run</code></li><li>选择需要操作的库</li><li>完成</li></ul><p>这些说着很复杂，其实操作起来，很方便。如下图所示</p><p><img src="https://img.jbzj.com/file_images/article/202109/20210917114439113.png" alt="img"></p><p>然后选择需要操作的库</p><p><img src="https://img.jbzj.com/file_images/article/202109/20210917114439114.png" alt="img"></p><p>问题：</p><ol><li><p>首次导出可能会提示没有权限的问题：Can’t create&#x2F;write to file</p><p><img src="/2022/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%BC%E5%87%BA%E6%96%87%E4%BB%B6/1650507320837.png" alt="1650507320837"></p></li></ol><p>解决方式：<br>  只需要在Outpath后面，手动添加，需要导出的文件：forestry.sql即可。</p><p><img src="/2022/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%BC%E5%87%BA%E6%96%87%E4%BB%B6/1650507355723.png" alt="1650507355723"></p><p>  2. 如果直接点击run可能会出现这个问题：A partial dump from a server that has GTIDs will by default include the GTID</p><p>   经过查询知道，GTID是5.6以后，加入了全局事务ID（GTID）来强化数据库的一致性，故障恢复以及容错能力。</p><p>  官方：</p><p>A global transaction identifier(GTID) is a unique identifier created and associated with each transaction committed on the server of origin(master).</p><p>  可以通过添加–set-gtid-purged&#x3D;off(已试，可行)或者-gtid-mode&#x3D;OFF(未试)这两个参数设置。</p><p>  这个命令直接添加到Out path 下面的命令行中即可，里面原来的命令不需要改动，直接添加空格，输入命令即可。</p><p>  很有可能是在导入库中重新生产GTID，而不用原来的。</p><p>  参考链接：<a href="https://www.jb51.net/article/109594.htm">https://www.jb51.net/article/109594.htm</a></p><p>  3. Couldn’t execute ‘SELECT COLUMN_NAME, JSON_EXTRACT(HISTOGRAM, ‘$.”number-of-</p><p>  这是因为当前执行导出操作的mysql版本是，但需要被导出的数据库是由之前版本创建的，在之前的版本中，information_schema数据库中没有COLLMN_STATISTICS数据表</p><p>  还在之前的命令行中打上空格，并且输入–column-statistics&#x3D;0 即可忽略这个表</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL主键自增</title>
      <link href="/2022/04/21/MySQL%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E/"/>
      <url>/2022/04/21/MySQL%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="auto-increment"><a href="#auto-increment" class="headerlink" title="auto_increment"></a>auto_increment</h2><p>在使用auto_increment时，应该注意一个小问题, 当进行delete from 表名称 清空表的时候，重新插入数据 , 发现auto_increment主键字段计数不是从1开始的,而是接着最新插入的数据id开始!</p><p>那么如何重新计数呢？</p><p>可以使用以下命令:</p><p>方法1</p><p> delete from 表名称; alter table 表名称 auto_increment&#x3D;1 #–这种方法处理的好处就是 可以设置auto_increment 为任意值开始自增 #–提示：如果表列和数据很多，速度会很慢，如90多万条，会在10分钟以上, 所以注意使用场景<br>方法2</p><p> #–直接一句话搞定 truncate table 表名称 #–(好处就是简单，auto_increment值重新开始从1计数)<br>重点注意 : 一般情况下我们使用第二个就可以了，记住以上情况都是彻底删除所有记录, 所以我们在设定之前要考虑周密，设计数据库表的时候也要考虑多方面因素!</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot解决跨域问题</title>
      <link href="/2022/04/10/SpringBoot%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/10/SpringBoot%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Springboot解决跨域问题"><a href="#Springboot解决跨域问题" class="headerlink" title="Springboot解决跨域问题"></a>Springboot解决跨域问题</h1><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F7632302-b1b8cb2830a1cd14.png&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1652162323&t=b6b4f1466718fea00a2036d8b17b21a1"></p><p>在Springboot项目里加上这个配置文件<code>CorsConfig.java</code>，重启之后即可实现跨域访问，前端无需再配置跨域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.zdk.springboot.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.filter.CorsFilter;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.cors.CorsConfiguration;</span><br><span class="line">import org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class CorsConfig &#123;</span><br><span class="line"></span><br><span class="line">    //当前跨域请求最大时长。默认一天</span><br><span class="line">    private static final long MAX_AGE = 24 * 60 * 60;</span><br><span class="line"></span><br><span class="line">    private CorsConfiguration buildConfig()&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = new CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(&quot;*&quot;);//1、设置访问源地址</span><br><span class="line">        corsConfiguration.addAllowedHeader(&quot;*&quot;);//2、设置访问源请求头</span><br><span class="line">        corsConfiguration.addAllowedMethod(&quot;*&quot;);//3、设置访问源请求方法</span><br><span class="line">        corsConfiguration.setMaxAge(MAX_AGE);</span><br><span class="line">        return corsConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public CorsFilter corsFilter()&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();</span><br><span class="line">        source.registerCorsConfiguration(&quot;/**&quot;,buildConfig());//4、对接口配置跨域设置</span><br><span class="line">        return new CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Springboot解决跨域问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库服务器性能分析</title>
      <link href="/2022/03/29/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
      <url>/2022/03/29/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>MySQL查看数据库性能常用命令<br>一、查询服务器状态和配置<br>列出MySQL服务器运行各种状态值：</p><p>mysql&gt; show global status;<br>查询MySQL服务器配置信息语句：</p><p>mysql&gt; show variables;<br>二、慢查询<br>　　mysql&gt; show variables like ‘%slow%’;<br>　　+——————+——-+<br>　　| Variable_name | Value |<br>　　+——————+——-+<br>　　| log_slow_queries | ON |<br>　　| slow_launch_time | 2 |<br>　　+——————+——-+<br>　　mysql&gt; show global status like ‘%slow%’;<br>　　+———————+——-+<br>　　| Variable_name | Value |<br>　　+———————+——-+<br>　　| Slow_launch_threads | 0 |<br>　　| Slow_queries | 4148 |<br>　　+———————+——-+　</p><pre><code>     配置中打开了记录慢查询，执行时间超过2秒的即为慢查询，系统显示有4148个慢查询，你可以分析慢查询日志，找出有问题的SQL语句，慢查询时间不宜设置过长，否则意义不大，最好在5秒以内，如果你需要微秒级别的慢查询，可以考虑给MySQL打补丁：http://www.percona.com/docs/wiki/release:start，记得找对应的版本。</code></pre><p>　　打开慢查询日志可能会对系统性能有一点点影响，如果你的MySQL是主-从结构，可以考虑打开其中一台从服务器的慢查询日志，这样既可以监控慢查询，对系统性能影响又小。</p><p>三、连接数 </p><p>　　经常会遇见”MySQL: ERROR 1040: Too many connections”的情况，一种是访问量确实很高，MySQL服务器抗不住，这个时候就要考虑增加从服务器分散读压力，另外一种情况是MySQL配置文件中max_connections值过小： </p><p>　　mysql&gt; show variables like ‘max_connections’;<br>　　+—————–+——-+<br>　　| Variable_name | Value |<br>　　+—————–+——-+<br>　　| max_connections | 256 |<br>　　+—————–+——-+　　<br>       这台MySQL服务器最大连接数是256，然后查询一下服务器响应的最大连接数： 　　</p><p>mysql&gt; show global status like ‘Max_used_connections’;</p><p>　　MySQL服务器过去的最大连接数是245，没有达到服务器连接数上限256，应该没有出现1040错误，比较理想的设置是：<br>　　Max_used_connections &#x2F; max_connections * 100% ≈ 85%<br>　　最大连接数占上限连接数的85%左右，如果发现比例在10%以下，MySQL服务器连接数上限设置的过高了。</p><p>四、Key_buffer_size </p><p>　　key_buffer_size是对MyISAM表性能影响最大的一个参数，下面一台以MyISAM为主要存储引擎服务器的配置： </p><p>　　mysql&gt; show variables like ‘key_buffer_size’;<br>　　+—————–+————+<br>　　| Variable_name | Value |<br>　　+—————–+————+<br>　　| key_buffer_size | 536870912 |<br>　　+—————–+————+　　<br>       分配了512MB内存给key_buffer_size，我们再看一下key_buffer_size的使用情况： </p><p>　　mysql&gt; show global status like ‘key_read%’;<br>　　+————————+————-+<br>　　| Variable_name | Value | mysql<br>　　+————————+————-+<br>　　| Key_read_requests | 27813678764 |<br>　　| Key_reads | 6798830 |<br>　　+————————+————-+　　<br>       一共有27813678764个索引读取请求，有6798830个请求在内存中没有找到直接从硬盘读取索引，计算索引未命中缓存的概率：<br>　　key_cache_miss_rate &#x3D; Key_reads &#x2F; Key_read_requests * 100%<br>　　比如上面的数据，key_cache_miss_rate为0.0244%，4000个索引读取请求才有一个直接读硬盘，已经很BT了,key_cache_miss_rate在0.1%以下都很好(每1000个请求有一个直接读硬盘)，如果key_cache_miss_rate在0.01%以下的话，key_buffer_size分配的过多，可以适当减少。<br>　　MySQL服务器还提供了key_blocks_*参数： </p><p>　　mysql&gt; show global status like ‘key_blocks_u%’;<br>　　+————————+————-+<br>　　| Variable_name | Value |<br>　　+————————+————-+<br>　　| Key_blocks_unused | 0 |<br>　　| Key_blocks_used | 413543 |<br>　　+————————+————-+　　</p><p>​        Key_blocks_unused表示未使用的缓存簇(blocks)数，Key_blocks_used表示曾经用到的最大的blocks数，比如这台服务器，所有的缓存都用到了，要么增加key_buffer_size，要么就是过渡索引了，把缓存占满了。比较理想的设置： </p><p>　　Key_blocks_used &#x2F; (Key_blocks_unused + Key_blocks_used) * 100% ≈ 80%</p><p>五、临时表<br>　　mysql&gt; show global status like ‘created_tmp%’;<br>　　+————————-+———+<br>　　| Variable_name | Value |<br>　　+————————-+———+<br>　　| Created_tmp_disk_tables | 21197 |<br>　　| Created_tmp_files | 58 |<br>　　| Created_tmp_tables | 1771587 |<br>　　+————————-+———+　　<br>       每次创建临时表，Created_tmp_tables增加，如果是在磁盘上创建临时表，Created_tmp_disk_tables也增加,Created_tmp_files表示MySQL服务创建的临时文件文件数，比较理想的配置是：<br>　　Created_tmp_disk_tables &#x2F; Created_tmp_tables * 100% &lt;&#x3D; 25%<br>　　比如上面的服务器Created_tmp_disk_tables &#x2F; Created_tmp_tables * 100% &#x3D; 1.20%，应该相当好了。我们再看一下MySQL服务器对临时表的配置： </p><p>　　mysql&gt; show variables where Variable_name in (‘tmp_table_size’, ‘max_heap_table_size’);<br>　　+———————+———–+<br>　　| Variable_name | Value |<br>　　+———————+———–+<br>　　| max_heap_table_size | 268435456 |<br>　　| tmp_table_size | 536870912 |<br>　　+———————+———–+　　<br>      只有256MB以下的临时表才能全部放内存，超过的就会用到硬盘临时表。</p><p>六、Open Table情况<br>　　mysql&gt; show global status like ‘open%tables%’;<br>　　+—————+——-+<br>　　| Variable_name | Value |<br>　　+—————+——-+<br>　　| Open_tables | 919 |<br>　　| Opened_tables | 1951 |<br>　　+—————+——-+　<br>　 Open_tables表示打开表的数量，Opened_tables表示打开过的表数量，如果Opened_tables数量过大，说明配置中table_cache(5.1.3之后这个值叫做table_open_cache)值可能太小，我们查询一下服务器table_cache值： </p><p>　　mysql&gt; show variables like ‘table_cache’;<br>　　+—————+——-+<br>　　| Variable_name | Value |<br>　　+—————+——-+<br>　　| table_cache | 2048 |<br>　　+—————+——-+</p><p>　　比较合适的值为：<br>　　Open_tables &#x2F; Opened_tables * 100% &gt;&#x3D; 85%<br>　　Open_tables &#x2F; table_cache * 100% &lt;&#x3D; 95%</p><p>七、进程使用情况</p><p>　　mysql&gt; show global status like ‘Thread%’;<br>　　+——————-+——-+<br>　　| Variable_name | Value |<br>　　+——————-+——-+<br>　　| Threads_cached | 46 |<br>　　| Threads_connected | 2 |<br>　　| Threads_created | 570 |<br>　　| Threads_running | 1 |<br>　　+——————-+——-+　　</p><pre><code> 如果我们在MySQL服务器配置文件中设置了thread_cache_size，当客户端断开之后，服务器处理此客户的线程将会缓存起来以响应下一个客户而不是销毁(前提是缓存数未达上限)。Threads_created表示创建过的线程数，如果发现Threads_created值过大的话，表明MySQL服务器一直在创建线程，这也是比较耗资源，可以适当增加配置文件中thread_cache_size值，查询服务器thread_cache_size配置： </code></pre><p>　　mysql&gt; show variables like ‘thread_cache_size’;<br>　　+——————-+——-+<br>　　| Variable_name | Value |<br>　　+——————-+——-+<br>　　| thread_cache_size | 64 |<br>　　+——————-+——-+　　<br>      服务器还是挺健康的。</p><p>八、查询缓存(query cache)<br>　<br>　mysql&gt; show global status like ‘qcache%’;<br>　　+————————-+———–+<br>　　| Variable_name | Value |<br>　　+————————-+———–+<br>　　| Qcache_free_blocks | 22756 |<br>　　| Qcache_free_memory | 76764704 |<br>　　| Qcache_hits | 213028692 |<br>　　| Qcache_inserts | 208894227 |<br>　　| Qcache_lowmem_prunes | 4010916 |<br>　　| Qcache_not_cached | 13385031 |<br>　　| Qcache_queries_in_cache | 43560 |<br>　　| Qcache_total_blocks | 111212 |<br>　　+————————-+———–+　　  </p><p>​     MySQL查询缓存变量解释：</p><p>Qcache_free_blocks：缓存中相邻内存块的个数。数目大说明可能有碎片。FLUSH QUERY CACHE会对缓存中的碎片进行整理，从而得到一个空闲块。<br>Qcache_free_memory：缓存中的空闲内存。<br>Qcache_hits：每次查询在缓存中命中时就增大<br>Qcache_inserts：每次插入一个查询时就增大。命中次数除以插入次数就是不中比率。<br>Qcache_lowmem_prunes：缓存出现内存不足并且必须要进行清理以便为更多查询提供空间的次数。这个数字最好长时间来看;如果这个数字在不断增长，就表示可能碎片非常严重，或者内存很少。(上面的 free_blocks和free_memory可以告诉您属于哪种情况)<br>Qcache_not_cached：不适合进行缓存的查询的数量，通常是由于这些查询不是 SELECT 语句或者用了now()之类的函数。<br>Qcache_queries_in_cache：当前缓存的查询(和响应)的数量。<br>Qcache_total_blocks：缓存中块的数量。<br>　　我们再查询一下服务器关于query_cache的配置： 　　</p><p>mysql&gt; show variables like ‘query_cache%’;<br>　　+——————————+———–+<br>　　| Variable_name | Value |<br>　　+——————————+———–+<br>　　| query_cache_limit | 2097152 |<br>　　| query_cache_min_res_unit | 4096 |<br>　　| query_cache_size | 203423744 |<br>　　| query_cache_type | ON |<br>　　| query_cache_wlock_invalidate | OFF |<br>       +——————————+———–+</p><p>　　各字段的解释：</p><p>query_cache_limit：超过此大小的查询将不缓存<br>query_cache_min_res_unit：缓存块的最小大小<br>query_cache_size：查询缓存大小<br>query_cache_type：缓存类型，决定缓存什么样的查询，示例中表示不缓存 select sql_no_cache 查询<br>query_cache_wlock_invalidate：当有其他客户端正在对MyISAM表进行写操作时，如果查询在query cache中，是否返回cache结果还是等写操作完成再读表获取结果。<br>query_cache_min_res_unit的配置是一柄”双刃剑”，默认是4KB，设置值大对大数据查询有好处，但如果你的查询都是小数据查询，就容易造成内存碎片和浪费。<br>　　查询缓存碎片率 &#x3D; Qcache_free_blocks &#x2F; Qcache_total_blocks * 100%<br>　　如果查询缓存碎片率超过20%，可以用FLUSH QUERY CACHE整理缓存碎片，或者试试减小query_cache_min_res_unit，如果你的查询都是小数据量的话。<br>　　查询缓存利用率 &#x3D; (query_cache_size - Qcache_free_memory) &#x2F; query_cache_size * 100%<br>　　查询缓存利用率在25%以下的话说明query_cache_size设置的过大，可适当减小;查询缓存利用率在80%以上而且Qcache_lowmem_prunes &gt; 50的话说明query_cache_size可能有点小，要不就是碎片太多。<br>　　查询缓存命中率 &#x3D; (Qcache_hits - Qcache_inserts) &#x2F; Qcache_hits * 100%<br>　　示例服务器 查询缓存碎片率 &#x3D; 20.46%，查询缓存利用率 &#x3D; 62.26%，查询缓存命中率 &#x3D; 1.94%，命中率很差，可能写操作比较频繁吧，而且可能有些碎片。</p><p>九、排序使用情况 </p><p>　　mysql&gt; show global status like ‘sort%’;<br>　　+——————-+————+<br>　　| Variable_name | Value |<br>　　+——————-+————+<br>　　| Sort_merge_passes | 29 |<br>　　| Sort_range | 37432840 |<br>　　| Sort_rows | 9178691532 |<br>　　| Sort_scan | 1860569 |<br>　　+——————-+————+　　</p><p>​        Sort_merge_passes 包括两步。MySQL 首先会尝试在内存中做排序，使用的内存大小由系统变量 Sort_buffer_size 决定，如果它的大小不够把所有的记录都读到内存中，MySQL 就会把每次在内存中排序的结果存到临时文件中，等MySQL找到所有记录之后，再把临时文件中的记录做一次排序。这再次排序就会增加 Sort_merge_passes。实际上，MySQL 会用另一个临时文件来存再次排序的结果，所以通常会看到 Sort_merge_passes 增加的数值是建临时文件数的两倍。因为用到了临时文件，所以速度可能会比较慢，增加 Sort_buffer_size 会减少Sort_merge_passes和创建临时文件的次数。但盲目的增加 Sort_buffer_size 并不一定能提高速度，见 How fast can you sort data with MySQL?(引自<a href="http://qroom.blogspot.com/2007/09/mysql-select-sort.html">http://qroom.blogspot.com/2007/09/mysql-select-sort.html</a>) 。</p><p>　　另外，增加read_rnd_buffer_size(3.2.3是record_rnd_buffer_size)的值对排序的操作也有一点的好处，参见：<a href="http://www.mysqlperformanceblog.com/2007/07/24/what-exactly-is-read_rnd_buffer_size/">http://www.mysqlperformanceblog.com/2007/07/24/what-exactly-is-read_rnd_buffer_size/</a></p><p>十、文件打开数(open_files) </p><p>　　mysql&gt; show global status like ‘open_files’;<br>　　+—————+——-+<br>　　| Variable_name | Value |<br>　　+—————+——-+<br>　　| Open_files | 1410 |<br>　　+—————+——-+<br>　　mysql&gt; show variables like ‘open_files_limit’;<br>　　+——————+——-+<br>　　| Variable_name | Value |<br>　　+——————+——-+<br>　　| open_files_limit | 4590 |<br>　　+——————+——-+　　</p><pre><code>  比较合适的设置：Open_files / open_files_limit * 100% &lt;= 75%</code></pre><p>十一、表锁情况<br>　<br>　mysql&gt; show global status like ‘table_locks%’;<br>　　+———————–+———–+<br>　　| Variable_name | Value |<br>　　+———————–+———–+<br>　　| Table_locks_immediate | 490206328 |<br>　　| Table_locks_waited | 2084912 |<br>　　+———————–+———–+　　<br>       Table_locks_immediate表示立即释放表锁数，Table_locks_waited表示需要等待的表锁数，如果Table_locks_immediate &#x2F; Table_locks_waited &gt; 5000，最好采用InnoDB引擎，因为InnoDB是行锁而MyISAM是表锁，对于高并发写入的应用InnoDB效果会好些。示例中的服务器Table_locks_immediate &#x2F; Table_locks_waited &#x3D; 235，MyISAM就足够了。</p><p>十二、表扫描情况<br>　　mysql&gt; show global status like ‘handler_read%’;<br>　　+———————–+————-+<br>　　| Variable_name | Value |<br>　　+———————–+————-+<br>　　| Handler_read_first | 5803750 |<br>　　| Handler_read_key | 6049319850 |<br>　　| Handler_read_next | 94440908210 |<br>　　| Handler_read_prev | 34822001724 |<br>　　| Handler_read_rnd | 405482605 |<br>　　| Handler_read_rnd_next | 18912877839 |<br>　　+———————–+————-+　　<br>        各字段解释参见<a href="http://hi.baidu.com/thinkinginlamp/blog/item/31690cd7c4bc5cdaa144df9c.html%EF%BC%8C%E8%B0%83%E5%87%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%8C%E6%88%90%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0%EF%BC%9A">http://hi.baidu.com/thinkinginlamp/blog/item/31690cd7c4bc5cdaa144df9c.html，调出服务器完成的查询请求次数：</a> </p><p>　　mysql&gt; show global status like ‘com_select’;<br>　　+—————+———–+<br>　　| Variable_name | Value |<br>　　+—————+———–+<br>　　| Com_select | 222693559 |<br>　　+—————+———–+　　<br>       计算表扫描率：<br>　　表扫描率 &#x3D; Handler_read_rnd_next &#x2F; Com_select<br>　　如果表扫描率超过4000，说明进行了太多表扫描，很有可能索引没有建好，增加read_buffer_size值会有一些好处，但最好不要超过8MB。<br>　　注意：<br>　　上文提到一些数字都是参考值，了解基本原理就可以，除了MySQL提供的各种status值外，操作系统的一些性能指标也很重要，比如常用的top,iostat等，尤其是iostat，现在的系统瓶颈一般都在磁盘IO上。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List五种去重方法</title>
      <link href="/2022/03/29/List%E4%BA%94%E7%A7%8D%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2022/03/29/List%E4%BA%94%E7%A7%8D%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="List-五种去重的方法"><a href="#List-五种去重的方法" class="headerlink" title="List 五种去重的方法"></a>List 五种去重的方法</h1><p>新建一个list数组: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List list = new ArrayList(); </span><br><span class="line">list.add(26); </span><br><span class="line">list.add(39); </span><br><span class="line">list.add(39); </span><br><span class="line">list.add(39); </span><br><span class="line">list.add(39); </span><br><span class="line">list.add(5); </span><br><span class="line">list.add(40); </span><br><span class="line">list.add(39); </span><br><span class="line">list.add(25); </span><br><span class="line">System.out.println(list); </span><br></pre></td></tr></table></figure><p><strong>方法一:使用java8新特性stream进行List去重</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List newList = list.stream().distinct().collect(Collectors.toList()); </span><br><span class="line">System.out.println(“java8新特性stream去重:”+newList); </span><br><span class="line">list.add(39); </span><br></pre></td></tr></table></figure><p><strong>方法二:双重for循环去重</strong> （不推荐使用，速度太慢）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">     for (int j = 0; j &lt; list.size(); ) &#123;</span><br><span class="line">        if (i != j &amp;&amp; list.get(i) == list.get(j)) &#123;</span><br><span class="line">               list.remove(j);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            j++;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(“双重for循环去重:”+list); </span><br><span class="line">list.add(39); </span><br></pre></td></tr></table></figure><p><strong>方法三:set集合判断去重,不打乱顺序</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Set set1 = new HashSet(); </span><br><span class="line">List newList1 = new ArrayList(); </span><br><span class="line">for (Integer integer : list) &#123; </span><br><span class="line">if(set1.add(integer)) &#123; </span><br><span class="line">newList1.add(integer); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">System.out.println(“set集合判断去重:”+list); </span><br><span class="line">list.add(39); </span><br></pre></td></tr></table></figure><p><strong>方法四:遍历后判断赋给另一个list集合</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List newList2 = new ArrayList(); </span><br><span class="line">for (Integer integer : list) &#123; </span><br><span class="line">if(!newList2.contains(integer))&#123; </span><br><span class="line">newList2.add(integer); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">System.out.println(“赋值新list去重:”+newList2); </span><br><span class="line">list.add(39); </span><br></pre></td></tr></table></figure><p><strong>方法五:set和list转换去重</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set set2 = new HashSet(); </span><br><span class="line">List newList3 = new ArrayList(); </span><br><span class="line">set2.addAll(list); </span><br><span class="line">newList3.addAll(set2); </span><br><span class="line">System.out.println(“set和list转换去重:”+newList3);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java_List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdbc statement</title>
      <link href="/2022/03/27/jdbc-statement/"/>
      <url>/2022/03/27/jdbc-statement/</url>
      
        <content type="html"><![CDATA[<h2 id="Statement、PreparedStatement和CallableStatement"><a href="#Statement、PreparedStatement和CallableStatement" class="headerlink" title="Statement、PreparedStatement和CallableStatement"></a>Statement、PreparedStatement和CallableStatement</h2><ol><li><p>Statement、PreparedStatement和CallableStatement都是接口(interface)。<br>&amp;nbsp; </p></li><li><p>Statement继承自Wrapper、PreparedStatement继承自Statement、CallableStatement继承自PreparedStatement。<br>&amp;nbsp;</p></li><li><p>Statement接口提供了执行语句和获取结果的基本方法；</p></li></ol><ul><li><p>PreparedStatement接口添加了处理 IN 参数的方法；   </p></li><li><p>CallableStatement接口添加了处理 OUT 参数的方法。<br>&amp;nbsp;</p></li></ul><ol start="4"><li>Statement、PreparedStatement和CallableStatement</li></ol><ul><li><p>Statement:<br>普通的不带参的查询SQL；支持批量更新,批量删除;    </p></li><li><p>PreparedStatement:<br>可变参数的SQL,编译一次,执行多次,效率高;<br>安全性好，有效防止Sql注入等问题;<br>支持批量更新,批量删除;   </p></li><li><p>CallableStatement:<br>继承自PreparedStatement,支持带参数的SQL操作;<br>支持调用存储过程,提供了对输出和输入&#x2F;输出参数(INOUT)的支持;<br>&amp;nbsp;</p></li></ul><ol start="5"><li>Statement每次执行sql语句，数据库都要执行sql语句的编译 ，<br>最好用于仅执行一次查询并返回结果的情形，效率高于PreparedStatement。<br>&amp;nbsp;</li></ol><h2 id="PreparedStatement是预编译的，使用PreparedStatement好处："><a href="#PreparedStatement是预编译的，使用PreparedStatement好处：" class="headerlink" title="PreparedStatement是预编译的，使用PreparedStatement好处："></a>PreparedStatement是预编译的，使用PreparedStatement好处：</h2><ol><li>在执行可变参数的一条SQL时，PreparedStatement比Statement的效率高，因为DBMS预编译一条SQL当然会比多次编译一条SQL的效率要高。 </li><li>安全性好，有效防止Sql注入等问题。 </li><li>对于多次重复执行的语句，使用PreparedStament效率会更高一点，并且在这种情况下也比较适合使用batch； </li><li>代码的可读性和可维护性。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAX_VALUE的含义</title>
      <link href="/2022/03/20/MAX-VALUE%E7%9A%84%E5%90%AB%E4%B9%89/"/>
      <url>/2022/03/20/MAX-VALUE%E7%9A%84%E5%90%AB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Integer-MAX-VALUE的含义"><a href="#Integer-MAX-VALUE的含义" class="headerlink" title="Integer.MAX_VALUE的含义"></a>Integer.MAX_VALUE的含义</h1><p>在了解Integer.MAX_VALUE的含义之前，我们得先知道java中的基本数据类型</p><p>在Java中，一共有8种基本数据类型：</p><p>整数型：int , short , long , byte 。  </p><p>浮点型：float , double 。  </p><p>字符类型：char 。  </p><p>表示真值的类型：boolean 。</p><p>（String属于Java中的字符串类型，也是一个引用类型，并不属于基本的数据类型）</p><p>整数型和浮点型取值范围如下：<br><img src="https://img-blog.csdnimg.cn/2020031010134471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyNDUwMA==,size_16,color_FFFFFF,t_70">  </p><ul><li>Integer.MAX_VALUE表示int数据类型的最大取值数：2 147 483 647</li><li>Integer.MIN_VALUE表示int数据类型的最小取值数：-2 147 483 648</li></ul><p>对应：</p><ul><li>Short.MAX_VALUE 为short类型的最大取值数 32 767</li><li>Short.MIN_VALUE 为short类型的最小取值数 -32 768</li></ul><p>其他数据类型同上含义</p><p>补充：  </p><p>Integer.MAX_VALUE+1&#x3D;Integer.MIN_VALUE  </p><p>因为：  </p><p>Integer.MAX_VALUE的二进制是0111 1111 1111 1111 1111 1111 1111 1111  </p><p>Integer.MIN_VALUE的二进制是 1000 0000 0000 0000 0000 0000 0000 0000</p><p>0111 1111 1111 1111 1111 1111 1111 1111+1&#x3D;1000 0000 0000 0000 0000 0000 0000 0000</p>]]></content>
      
      
      
        <tags>
            
            <tag> java_MAX_VALUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java关于substring(a)与substring(a,b)的用法</title>
      <link href="/2022/03/20/java%E5%85%B3%E4%BA%8Esubstrin(a)%E4%B8%8Esubstring(a,b)%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2022/03/20/java%E5%85%B3%E4%BA%8Esubstrin(a)%E4%B8%8Esubstring(a,b)%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="String-str-x3D-“abc“；和String-str-x3D-new-String-“abc“-；到底分别创建了几个对象？"><a href="#String-str-x3D-“abc“；和String-str-x3D-new-String-“abc“-；到底分别创建了几个对象？" class="headerlink" title="String str &#x3D; “abc“；和String str &#x3D;new String(“abc“)；到底分别创建了几个对象？"></a>String str &#x3D; “abc“；和String str &#x3D;new String(“abc“)；到底分别创建了几个对象？</h1><h2 id="一、到底创建了几个对象"><a href="#一、到底创建了几个对象" class="headerlink" title="一、到底创建了几个对象"></a>一、到底创建了几个对象</h2><p>1、String str &#x3D; “abc”; 创建了几个对象？0个 或者 1个</p><p>2、String str &#x3D; new String(“abc”);创建了几个对象？ 1个或2个</p><h2 id="二、首先了解几个基本的概念："><a href="#二、首先了解几个基本的概念：" class="headerlink" title="二、首先了解几个基本的概念："></a>二、首先了解几个基本的概念：</h2><p>1、String是一个特殊的包装类数据。即可以用String str &#x3D; new String(“abc”);的形式来创建，也可以用String str &#x3D; “abc”;的形式来创建。</p><p>2、JVM的堆中存放对象的实例，而JVM的栈中存储对象的引用。</p><p>3、字符串常量池：</p><ul><li><p>字符串的分配和其它对象一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多，JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分确定常量池中一定不存在两个相同的字符串。</p></li><li><p>Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。<br>静态常量池：即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串（数量 ）字面量，还包含类、方法的信息，占用class文件绝大部分空间。<br>运行时常量池：则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。</p></li></ul><h2 id="三、String对象的创建过程："><a href="#三、String对象的创建过程：" class="headerlink" title="三、String对象的创建过程："></a>三、String对象的创建过程：</h2><p><strong>String str &#x3D; “abc”;</strong></p><p>创建过程：<br>1、首先在常量池中查找是否存在内容为”abc”字符串对象。<br>2、如果不存在则在常量池中创建”abc”，并让str引用该对象。（也就是创建1个对象的情况）<br>3、如果存在则直接让str引用该对象（该对象是存在方法区的运行时常量池中的）。（也就是创建0个对象的情况）<br><img src="https://img-blog.csdnimg.cn/20191022114636934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI5NjkyOQ==,size_16,color_FFFFFF,t_70"></p><p><strong>String str &#x3D; new String(“abc”);</strong></p><p>创建过程：<br>1、首先在堆中（不是常量池）创建一个指定的对象”abc”，并让str引用指向该对象。（创建第1个对象）<br>2、在字符串常量池中查看是否存在内容为”abc”的字符串对象。<br>3、若存在，则让堆中创建好的字符串对象对字符串常量池的对象进行引用。（也就是只创建1个对象的情况）<br>4、若不存在，则在常量池中添加一个内容为”abc”的字符串对象，并将堆中的String对象进行引用。（也就是创建2个对象的情况）</p><p><img src="https://img-blog.csdnimg.cn/20191022115600305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDI5NjkyOQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>下面代码结果为true，说明同为常量池中的一个对象：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;abc&quot;;</span><br><span class="line">String str1 = &quot;ab&quot; + &quot;c&quot;;</span><br><span class="line">System.out.println(str == str1); //true</span><br></pre></td></tr></table></figure><p>因为String str1 &#x3D; “ab” + “c”;会查找常量池中是否存在内容为”abc”的对象，如果存在则直接让str1引用该对象，因为String str &#x3D; “abc”;已经在常量池中创建了abc对象，所以str1直接引用该对象，str &#x3D;&#x3D; str1；</p><p><strong>下面代码结果为false，说明产生了新的对象：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;abc&quot;;</span><br><span class="line">String str2 = &quot;ab&quot;; </span><br><span class="line">String str3 = str2 + &quot;c&quot;; </span><br><span class="line">System.out.println(str1 == str3);//false</span><br></pre></td></tr></table></figure><p>因为String str3 &#x3D; str2 + “c”涉及到变量（不全是常量）的相加，所以会产生新的对象，其内部实现是先new一个StringBuffer，然后append（str2）再append（“c”），然后让str3引用toString返回的对象。</p><p>tip:  </p><p>1.java中String元素下标从0开始，substring(a)是从第a个字符开始截取，包含第a个字符。可以看成数学中的[ ），表示左闭右开区间  </p><p>2.substring(a, b)表示截取下标从a开始到b结束的字符，包含第a个字符但是不包含第b个字符，可以看成[a,b)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java_String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分法案例</title>
      <link href="/2022/03/19/%E4%BA%8C%E5%88%86%E6%B3%95%E6%A1%88%E4%BE%8B/"/>
      <url>/2022/03/19/%E4%BA%8C%E5%88%86%E6%B3%95%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><h2 id="给定两个大小分别为-m-和-n-的正序（从小到大）数组-nums1-和-nums2。请你找出并返回这两个正序数组的-中位数-。算法的时间复杂度应该为-O-log-m-n-。"><a href="#给定两个大小分别为-m-和-n-的正序（从小到大）数组-nums1-和-nums2。请你找出并返回这两个正序数组的-中位数-。算法的时间复杂度应该为-O-log-m-n-。" class="headerlink" title="给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。算法的时间复杂度应该为 O(log (m+n)) 。"></a>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。算法的时间复杂度应该为 O(log (m+n)) 。</h2><p>题目是求中位数，其实就是求第 k 小数的一种特殊情况，而求第 k 小数有一种算法。<br>我们一次遍历就相当于去掉不可能是中位数的一个值，也就是一个一个排除。由于数列是有序的，其实我们完全可以一半儿一半儿的排除。假设我们要找第 k 小数，我们可以每次循环排除掉 k&#x2F;2 个数。看下边一个例子。</p><p>假设我们要找第 7 小的数字。  </p><p><img src="https://pic.leetcode-cn.com/735ea8129ab5b56b7058c6286217fa4bb5f8a198e4c8b2172fe0f75b29a966cd-image.png"></p><p>我们比较两个数组的第 k&#x2F;2 个数字，如果 k 是奇数，向下取整。也就是比较第 33 个数字，上边数组中的 44 和下边数组中的 33，如果哪个小，就表明该数组的前 k&#x2F;2 个数字都不是第 k 小数字，所以可以排除。也就是 11，22，33 这三个数字不可能是第 77 小的数字，我们可以把它排除掉。将 13491349 和 4567891045678910 两个数组作为新的数组进行比较。</p><p>更一般的情况 A[1] ，A[2] ，A[3]，A[k&#x2F;2] … ，B[1]，B[2]，B[3]，B[k&#x2F;2] … ，如果 A[k&#x2F;2]&lt;B[k&#x2F;2] ，那么A[1]，A[2]，A[3]，A[k&#x2F;2]都不可能是第 k 小的数字。</p><p>A 数组中比 A[k&#x2F;2] 小的数有 k&#x2F;2-1 个，B 数组中，B[k&#x2F;2] 比 A[k&#x2F;2] 小，假设 B[k&#x2F;2] 前边的数字都比 A[k&#x2F;2] 小，也只有 k&#x2F;2-1 个，所以比 A[k&#x2F;2] 小的数字最多有 k&#x2F;1-1+k&#x2F;2-1&#x3D;k-2个，所以 A[k&#x2F;2] 最多是第 k-1 小的数。而比 A[k&#x2F;2] 小的数更不可能是第 k 小的数了，所以可以把它们排除。</p><p>橙色的部分表示已经去掉的数字。  </p><p><img src="https://pic.leetcode-cn.com/09b8649cd2b8bbea74f7f632b098fed5f8404530ff44b5a0b54a360b3cf7dd8f-image.png"></p><p>由于我们已经排除掉了 3 个数字，就是这 3 个数字一定在最前边，所以在两个新数组中，我们只需要找第 7 - 3 &#x3D; 4 小的数字就可以了，也就是 k &#x3D; 4。此时两个数组，比较第 2 个数字，3 &lt; 5，所以我们可以把小的那个数组中的 1 ，3 排除掉了。  </p><p><img src="https://pic.leetcode-cn.com/f2d72fd3dff109ad810895b9a0c8d8782f47df6b2f24f9de72704961bc547fcb-image.png"></p><p>我们又排除掉 2 个数字，所以现在找第 4 - 2 &#x3D; 2 小的数字就可以了。此时比较两个数组中的第 k &#x2F; 2 &#x3D; 1 个数，4 &#x3D;&#x3D; 4，怎么办呢？由于两个数相等，所以我们无论去掉哪个数组中的都行，因为去掉 1 个总会保留 1 个的，所以没有影响。为了统一，我们就假设 4 &gt; 4 吧，所以此时将下边的 4 去掉。  </p><p><img src="https://pic.leetcode-cn.com/3c89a8ea29f2e19057b57242c8bc37c5f09b6796b96c30f3d42caea21c12f294-image.png"></p><p>由于又去掉 1 个数字，此时我们要找第 1 小的数字，所以只需判断两个数组中第一个数字哪个小就可以了，也就是 4。所以第 7 小的数字是 4。我们每次都是取 k&#x2F;2 的数进行比较，有时候可能会遇到数组长度小于 k&#x2F;2的时候。  </p><p><img src="https://pic.leetcode-cn.com/ad87d1f63a9bbd99e12605686290800ce61b03f9fb98d87f1d8c020d404421ac-image.png"></p><p>此时 k &#x2F; 2 等于 3，而上边的数组长度是 2，我们此时将箭头指向它的末尾就可以了。这样的话，由于 2 &lt; 3，所以就会导致上边的数组 1，2 都被排除。造成下边的情况。  </p><p><img src="https://pic.leetcode-cn.com/7ea1963f184b1dcaddf951326ccbe7aa09cfbb9ebee7fffb2ede131853b3d1de-image.png"></p><p>由于 2 个元素被排除，所以此时 k &#x3D; 5，又由于上边的数组已经空了，我们只需要返回下边的数组的第 5 个数字就可以了。</p><p>从上边可以看到，无论是找第奇数个还是第偶数个数字，对我们的算法并没有影响，而且在算法进行中，k 的值都有可能从奇数变为偶数，最终都会变为 1 或者由于一个数组空了，直接返回结果。</p><p>所以我们采用递归的思路，为了防止数组长度小于 k&#x2F;2，所以每次比较 min(k&#x2F;2，len(数组) 对应的数字，把小的那个对应的数组的数字排除，将两个新数组进入递归，并且 k 要减去排除的数字的个数。递归出口就是当 k&#x3D;1 或者其中一个数字长度是 0 了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>public double findMedianSortedArrays(int[] nums1, int[] nums2) {<br>    int n &#x3D; nums1.length;<br>    int m &#x3D; nums2.length;<br>    int left &#x3D; (n + m + 1) &#x2F; 2;<br>    int right &#x3D; (n + m + 2) &#x2F; 2;<br>    &#x2F;&#x2F;将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。<br>    return (getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) + getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)) * 0.5;<br>}</p><pre><code>private int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) &#123;    int len1 = end1 - start1 + 1;    int len2 = end2 - start2 + 1;    //让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1     if (len1 &gt; len2) return getKth(nums2, start2, end2, nums1, start1, end1, k);    if (len1 == 0) return nums2[start2 + k - 1];    if (k == 1) return Math.min(nums1[start1], nums2[start2]);    int i = start1 + Math.min(len1, k / 2) - 1;    int j = start2 + Math.min(len2, k / 2) - 1;    if (nums1[i] &gt; nums2[j]) &#123;        return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));    &#125;    else &#123;        return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1));    &#125;&#125;</code></pre><p>时间复杂度：每进行一次循环，我们就减少 k&#x2F;2 个元素，所以时间复杂度是 O(log(k)，而 k&#x3D;(m+n)&#x2F;2，所以最终的复杂也就是 O(log(m+n）O(log(m+n）。</p><p>空间复杂度：虽然我们用到了递归，但是可以看到这个递归属于尾递归，所以编译器不需要不停地堆栈，所以空间复杂度为 O(1)O(1)。</p><p>作者：windliang  </p><p>链接：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/</a>  </p><p>来源：力扣（LeetCode）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String数组初始化</title>
      <link href="/2022/03/17/String%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2022/03/17/String%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="String数组初始化"><a href="#String数组初始化" class="headerlink" title="String数组初始化"></a>String数组初始化</h1><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] str = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];   </span><br><span class="line"><span class="comment">//创建一个长度为5的String(字符串)型的一维数组</span></span><br><span class="line"></span><br><span class="line">String[] str = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;“”,””,””,””,””&#125;;</span><br><span class="line"></span><br><span class="line">String[] str = &#123;“”,””,””,””,””&#125;;</span><br></pre></td></tr></table></figure><h2 id="String数组初始化区别"><a href="#String数组初始化区别" class="headerlink" title="String数组初始化区别"></a>String数组初始化区别</h2><p>首先应该明白java数组里面存的是对象的引用，所以必须初始化才能用；</p><p>String[] str &#x3D; {“1″,”2″,”3”}与String[] str &#x3D; newString[]{“1″,”2″,”3”}在内存里有什么区别？</p><p>编译执行结果没有任何区别。更不可能像有些人想当然说的在栈上分配空间，Java的对象都是在堆上分配空间的。</p><p>这里的区别仅仅是代码书写上的：</p><ul><li><p>String[] str &#x3D; {“1″,”2″,”3”}; 这种形式叫数组初始化式(ArrayInitializer)，只能用在声明同时赋值的情况下。</p></li><li><p>String[] str &#x3D; new String[]{“1″,”2″,”3”}是一般形式的赋值，&#x3D;号的右边叫数组字面量(ArrayLiteral)，数组字面量可以用在任何需要一个数组的地方(类型兼容的情况下)。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String[] str = &#123;“<span class="number">1</span>″,”<span class="number">2</span>″,”<span class="number">3</span>”&#125;; <span class="comment">// 正确的</span></span><br><span class="line"></span><br><span class="line">String[] str = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;“<span class="number">1</span>″,”<span class="number">2</span>″,”<span class="number">3</span>”&#125; <span class="comment">// 也是正确的</span></span><br></pre></td></tr></table></figure></li></ul><p>而</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String[] str;</span><br><span class="line"></span><br><span class="line">str = &#123;“<span class="number">1</span>″,”<span class="number">2</span>″,”<span class="number">3</span>”&#125;; <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><p>因为数组初始化式只能用于声明同时赋值的情况下。</p><p>改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] str;</span><br><span class="line"></span><br><span class="line">str = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;“<span class="number">1</span>″,”<span class="number">2</span>″,”<span class="number">3</span>”&#125;; <span class="comment">// 正确了</span></span><br></pre></td></tr></table></figure><p>又如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">f</span><span class="params">(String[] str)</span> &#123;undefined&#125;</span><br><span class="line"></span><br><span class="line">f(&#123;“<span class="number">1</span>″,”<span class="number">2</span>″,”<span class="number">3</span>”&#125;); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><p>正确的应该是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">f(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123;“<span class="number">1</span>″,”<span class="number">2</span>″,”<span class="number">3</span>”&#125;);</span><br></pre></td></tr></table></figure><p>还可以  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">30</span>];</span><br></pre></td></tr></table></figure><p>如果没有显式赋值，则系统自动赋默认值null。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java_String </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
